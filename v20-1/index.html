<html><head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-115476228-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		// gtag('config', 'UA-115476228-1', { 'anonymize_ip': true });
	</script>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
	<title>MetaEthical.AI: AI that does what we should want it to do</title>
	<meta name="description" content="Ethical goal function for AI based on fully technical philosophical theories of metaethics and metasemantics">
	<meta name="Generator" content="Vim/8.1">
	<meta name="plugin-version" content="vim7.4_v2">
	<meta name="syntax" content="setlx">
	<meta name="settings" content="number_lines,use_css,pre_wrap,no_foldcolumn,expand_tabs,line_ids,prevent_copy=">
	<meta name="colorscheme" content="evening">
	<link href="https://fonts.googleapis.com/css?family=PT+Sans+Caption:400,700|Inconsolata|PT+Sans|Anonymous+Pro:400,700" rel="stylesheet">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> 
	<script src="https://cdn.rawgit.com/davestewart/jquery-scroll-into-view/c53c2f0b/lib/jquery.scroll-into-view.js"></script>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#da532c">
	<meta name="theme-color" content="#ffffff">

	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
	<script type="text/javascript">
		window.dev = false;
	</script>
	<script src="data.js"></script>
	<script src="app.js"></script>
	<link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="container">
    <div id="tract" class="vimCodeElement selected">
      <h1>Formal Metaethics and Metasemantics for AI Alignment</h1>
			<div id="abstract-div">
				<span id="abstract-arrow">?</span>				
				<span id="abstract-heading">Abstract</span>
				<div id="abstract">
					We construct a fully technical ethical goal function for AI by directly tackling the philosophical problems of metaethics and mental content. To simplify our reduction of these philosophical challenges into "merely" engineering ones, we suppose that unlimited computation and a complete low-level causal model of the world and the adult human brains in it are available.
					<br><br>
					Given such a model, the AI attributes beliefs and values to a brain in two stages. First, it identifies the syntax of a brain's mental content by selecting a decision algorithm which is i) isomorphic to the brain's causal processes and ii) best compresses its behavior while iii) maximizing charity. The semantics of that content then consists first in sense data that primitively refer to their own occurrence and then in logical and causal structural combinations of such content.
					<br><br>
					The resulting decision algorithm can capture how we decide what to <i>do</i>, but it can also identify the ethical factors that we seek to determine when we decide what to <i>value</i> or even how to <i>decide</i>. Unfolding the implications of those factors, we arrive at what we should do. All together, this allows us to imbue the AI with the necessary concepts to determine and do what we should program it to do.					
				</div>
			</div>
      <p style="padding-left: 20px; margin-top: 5px; margin-bottom: 30px; "><span style="font-family: 'PT Sans Caption', sans-serif; color: #ffaaff;">Video:</span> Check out the <a style="color: #ffaaff; font-family: 'PT', sans-serif;" href="https://youtu.be/2afdrE81yvg" target="_BLANK">25 min intro talk</a> with questions from Stuart Armstrong (Oxford FHI) and the AI Safety Reading Group.</p>
<ul>
<li id="t1"><a id="t-1" name="t-1" class="li-num">1</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>Given mathematical models of the world and the adult human brains in it, an ethical goal function for AI can be constructed by applying a social welfare function to the set of extensional rational utility functions of the brains. <a href="#metaethical_ai_u" class="to-code" title="#metaethical_ai_u">{…}</a><ul>
<li id="t1-1"><a id="t-1-1" name="t-1-1" class="li-num">1.1</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>The mathematical model of a world or brain is to be given as a causal Markov model. <a href="#cmm-1" class="to-code" title="#cmm-1">{…}</a><ul>
<li id="t1-1-1"><a id="t-1-1-1" name="t-1-1-1" class="li-num">1.1.1</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>A causal Markov model is a convenient model for generating a causal model. <a href="#cmm-cm" class="to-code" title="#cmm-cm">{…}</a><ul>
<li id="t1-1-1-1"><a id="t-1-1-1-1" name="t-1-1-1-1" class="li-num">1.1.1.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The notion of a causal model is taken directly from Judea Pearl. <a href="#cm-1" class="to-code" title="#cm-1">{…}</a><ul style="display: none;">
<li id="t1-1-1-1-1"><a id="t-1-1-1-1-1" name="t-1-1-1-1-1" class="li-num">1.1.1.1.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A causal model is composed of: <a href="#cm-5" class="to-code" title="#cm-5">{…}</a><ul style="display: none;">
<li id="t1-1-1-1-1-1"><a id="t-1-1-1-1-1-1" name="t-1-1-1-1-1-1" class="li-num">1.1.1.1.1.1</a><span class="t-li bullet">?</span>A set of exogenous variables. Their values are simply taken as given rather than having their causes modeled. <a href="#cm-6" class="to-code" title="#cm-6">{…}</a></li>
<li id="t1-1-1-1-1-2"><a id="t-1-1-1-1-1-2" name="t-1-1-1-1-1-2" class="li-num">1.1.1.1.1.2</a><span class="t-li bullet">?</span>A set of endogenous variables. Their causes are modeled. <a href="#cm-8" class="to-code" title="#cm-8">{…}</a></li>
<li id="t1-1-1-1-1-3"><a id="t-1-1-1-1-1-3" name="t-1-1-1-1-1-3" class="li-num">1.1.1.1.1.3</a><span class="t-li bullet">?</span>A function taking each variable to its set of possible values. <a href="#cm-10" class="to-code" title="#cm-10">{…}</a></li>
<li id="t1-1-1-1-1-4"><a id="t-1-1-1-1-1-4" name="t-1-1-1-1-1-4" class="li-num">1.1.1.1.1.4</a><span class="t-li bullet">?</span>A higher order function that takes each endogenous variable to its structural equation, which is a function from an assignment of values to all other variables to a value for the endogenous variable. <a href="#cm-19" class="to-code" title="#cm-19">{…}</a></li>
<li id="t1-1-1-1-1-5"><a id="t-1-1-1-1-1-5" name="t-1-1-1-1-1-5" class="li-num">1.1.1.1.1.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The causal response of a set of variables to a given assignment of values to endogenous and exogenous variables is an assignment of values to those responding variables. <a href="#cm-response" class="to-code" title="#cm-response">{…}</a><ul style="display: none;">
<li id="t1-1-1-1-1-5-1"><a id="t-1-1-1-1-1-5-1" name="t-1-1-1-1-1-5-1" class="li-num">1.1.1.1.1.5.1</a><span class="t-li bullet">?</span>To compute those values, a causal submodel is created that is identical to the original causal model except that the structural equations for any endogenous variables in the given assignment are replaced with a constant function equal to each such variable's given value. <a href="#effect_of_do" class="to-code" title="#effect_of_do">{…}</a></li>
<li id="t1-1-1-1-1-5-2"><a id="t-1-1-1-1-1-5-2" name="t-1-1-1-1-1-5-2" class="li-num">1.1.1.1.1.5.2</a><span class="t-li bullet">?</span>Then, using the submodel and the given values of the exogenous variables, the values of the endogenous variables can be computed with the structural equations. <a href="#solve_for" class="to-code" title="#solve_for">{…}</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-1-1-2"><a id="t-1-1-1-2" name="t-1-1-1-2" class="li-num">1.1.1.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A causal Markov model is composed of: <a href="#cmm-1" class="to-code" title="#cmm-1">{…}</a><ul style="display: none;">
<li id="t1-1-1-2-1"><a id="t-1-1-1-2-1" name="t-1-1-1-2-1" class="li-num">1.1.1.2.1</a><span class="t-li bullet">?</span>An integer for the number of time slices. <a href="#cmm-2" class="to-code" title="#cmm-2">{…}</a></li>
<li id="t1-1-1-2-2"><a id="t-1-1-1-2-2" name="t-1-1-1-2-2" class="li-num">1.1.1.2.2</a><span class="t-li bullet">?</span>A set of exogenous variables. Their values are simply taken as given rather than having their causes modeled. <a href="#cmm-3" class="to-code" title="#cmm-3">{…}</a></li>
<li id="t1-1-1-2-3"><a id="t-1-1-1-2-3" name="t-1-1-1-2-3" class="li-num">1.1.1.2.3</a><span class="t-li bullet">?</span>A set of endogenous variables. Their causes are modeled. <a href="#cmm-5" class="to-code" title="#cmm-5">{…}</a></li>
<li id="t1-1-1-2-4"><a id="t-1-1-1-2-4" name="t-1-1-1-2-4" class="li-num">1.1.1.2.4</a><span class="t-li bullet">?</span>A function taking each variable to its set of possible values. <a href="#cmm-7" class="to-code" title="#cmm-7">{…}</a></li>
<li id="t1-1-1-2-5"><a id="t-1-1-1-2-5" name="t-1-1-1-2-5" class="li-num">1.1.1.2.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A higher-order function that takes each endogenous variable to its structural equation, which is a function from an assignment of values to all variables to a value for that endogenous variable. <a href="#cmm-17" class="to-code" title="#cmm-17">{…}</a><ul style="display: none;">
<li id="t1-1-1-2-5-1"><a id="t-1-1-1-2-5-1" name="t-1-1-1-2-5-1" class="li-num">1.1.1.2.5.1</a><span class="t-li bullet">?</span>We allow the assignment of values to include the endogenous variable in question since when generating the causal model, it gets split into different variables for each time slice.</li>
</ul>
</li>
<li id="t1-1-1-2-6"><a id="t-1-1-1-2-6" name="t-1-1-1-2-6" class="li-num">1.1.1.2.6</a><span class="t-li bullet">?</span>A list of actual states, one for each time slice. Each state is an assignment of values to variables of the generated causal model for the given time. <a href="#cmm-22" class="to-code" title="#cmm-22">{…}</a></li>
</ul>
</li>
<li id="t1-1-1-3"><a id="t-1-1-1-3" name="t-1-1-1-3" class="li-num">1.1.1.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A causal Markov model (cmm) generates a causal model (cm) as follows: <a href="#cmm-cm" class="to-code" title="#cmm-cm">{…}</a><ul style="display: none;">
<li id="t1-1-1-3-1"><a id="t-1-1-1-3-1" name="t-1-1-1-3-1" class="li-num">1.1.1.3.1</a><span class="t-li bullet">?</span>For each cmm variable, a set of cm variables are created by indexing the cmm variable with a time subscript, from 1 to the number of cmm time slices.</li>
<li id="t1-1-1-3-2"><a id="t-1-1-1-3-2" name="t-1-1-1-3-2" class="li-num">1.1.1.3.2</a><span class="t-li bullet">?</span>The cm's exogenous variables is the set of time-indexed cmm exogenous variables plus the set of cmm endogenous variables time-indexed with 1, i.e. the variables forming the initial state. <a href="#cm_u" class="to-code" title="#cm_u">{…}</a></li>
<li id="t1-1-1-3-3"><a id="t-1-1-1-3-3" name="t-1-1-1-3-3" class="li-num">1.1.1.3.3</a><span class="t-li bullet">?</span>The cm’s endogenous variables are the rest of the time-indexed variables from the cmm endogenous variables, i.e. those indexed from 2 to the number of time slices. <a href="#cm_v" class="to-code" title="#cm_v">{…}</a></li>
<li id="t1-1-1-3-4"><a id="t-1-1-1-3-4" name="t-1-1-1-3-4" class="li-num">1.1.1.3.4</a><span class="t-li bullet">?</span>The cm's function mapping variables to their possible values just maps each time-indexed variable to the possible values of the original unindexed cmm variable. <a href="#cm_r" class="to-code" title="#cm_r">{…}</a></li>
<li id="t1-1-1-3-5"><a id="t-1-1-1-3-5" name="t-1-1-1-3-5" class="li-num">1.1.1.3.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Each cm variable's structural equation satisfies the Markov property:<ul style="display: none;">
<li id="t1-1-1-3-5-1"><a id="t-1-1-1-3-5-1" name="t-1-1-1-3-5-1" class="li-num">1.1.1.3.5.1</a><span class="t-li bullet">?</span>Its value depends only on the value of the previous time step's variables.</li>
<li id="t1-1-1-3-5-2"><a id="t-1-1-1-3-5-2" name="t-1-1-1-3-5-2" class="li-num">1.1.1.3.5.2</a><span class="t-li bullet">?</span>In particular, its value given an assignment of values to the other variables is the same as that specified by the cmm structural equation for the original variable given an assignment of the same values to the other respective original cmm variables. <a href="#cm_f" class="to-code" title="#cm_f">{…}</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2"><a id="t-1-2" name="t-1-2" class="li-num">1.2</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>A brain's rational utility function is the utility function that would be arrived at by the brain's decision algorithm if it were to make more optimal decisions while avoiding unrelated distortions of value. <a href="#ruf" class="to-code" title="#ruf">{…}</a><ul>
<li id="t1-2-1"><a id="t-1-2-1" name="t-1-2-1" class="li-num">1.2.1</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>A brain's decision algorithm is the one that best satisfies these desiderata: <a href="#better_explanation" class="to-code" title="#better_explanation">{…}</a><ul>
<li id="t1-2-1-1"><a id="t-1-2-1-1" name="t-1-2-1-1" class="li-num">1.2.1.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>First, it must take the mathematical form of a decision algorithm, which is a tuple composed of: <a href="#da-1" class="to-code" title="#da-1">{…}</a><ul style="display: none;">
<li id="t1-2-1-1-1"><a id="t-1-2-1-1-1" name="t-1-2-1-1-1" class="li-num">1.2.1.1.1</a><span class="t-li bullet">?</span>A set of input variables for sensory inputs. Generally this will be a subset of the range of the probability variable function below. <a href="#da-6" class="to-code" title="#da-6">{…}</a></li>
<li id="t1-2-1-1-2"><a id="t-1-2-1-1-2" name="t-1-2-1-1-2" class="li-num">1.2.1.1.2</a><span class="t-li bullet">?</span>A set of output variables for motor output. <a href="#da-35" class="to-code" title="#da-35">{…}</a></li>
<li id="t1-2-1-1-3"><a id="t-1-2-1-1-3" name="t-1-2-1-1-3" class="li-num">1.2.1.1.3</a><span class="t-li bullet">?</span>A probability variable function from logical expressions to probability variables. <a href="#da-44" class="to-code" title="#da-44">{…}</a></li>
<li id="t1-2-1-1-4"><a id="t-1-2-1-1-4" name="t-1-2-1-1-4" class="li-num">1.2.1.1.4</a><span class="t-li bullet">?</span>A function from ordered pairs of logical expressions to conditional probability variables. The variable would represent the probability of the first expression conditional on the second. <a href="#da-49" class="to-code" title="#da-49">{…}</a></li>
<li id="t1-2-1-1-5"><a id="t-1-2-1-1-5" name="t-1-2-1-1-5" class="li-num">1.2.1.1.5</a><span class="t-li bullet">?</span>A function from logical expressions to utility variables. <a href="#da-55" class="to-code" title="#da-55">{…}</a></li>
<li id="t1-2-1-1-6"><a id="t-1-2-1-1-6" name="t-1-2-1-1-6" class="li-num">1.2.1.1.6</a><span class="t-li bullet">?</span>A set of arbitrary memory variables. <a href="#da-62" class="to-code" title="#da-62">{…}</a></li>
<li id="t1-2-1-1-7"><a id="t-1-2-1-1-7" name="t-1-2-1-1-7" class="li-num">1.2.1.1.7</a><span class="t-li bullet">?</span>A second set of memory variables that will mediate between the probability and utility variables and the output variables. <a href="#da-67" class="to-code" title="#da-67">{…}</a></li>
<li id="t1-2-1-1-8"><a id="t-1-2-1-1-8" name="t-1-2-1-1-8" class="li-num">1.2.1.1.8</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A set of accepted norms / higher-order utility functions / decision criteria. <a href="#da-69" class="to-code" title="#da-69">{…}</a><ul style="display: none;">
<li id="t1-2-1-1-8-1"><a id="t-1-2-1-1-8-1" name="t-1-2-1-1-8-1" class="li-num">1.2.1.1.8.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Each of these is composed of:<ul style="display: none;">
<li id="t1-2-1-1-8-1-1"><a id="t-1-2-1-1-8-1-1" name="t-1-2-1-1-8-1-1" class="li-num">1.2.1.1.8.1.1</a><span class="t-li bullet">?</span>A function from logical expressions to evaluation / higher-order utility variables. <a href="#da-72" class="to-code" title="#da-72">{…}</a></li>
<li id="t1-2-1-1-8-1-2"><a id="t-1-2-1-1-8-1-2" name="t-1-2-1-1-8-1-2" class="li-num">1.2.1.1.8.1.2</a><span class="t-li bullet">?</span>A set of memory variables mediating between the probability and evaluation variables and the higher-order output variables. <a href="#da-78" class="to-code" title="#da-78">{…}</a></li>
<li id="t1-2-1-1-8-1-3"><a id="t-1-2-1-1-8-1-3" name="t-1-2-1-1-8-1-3" class="li-num">1.2.1.1.8.1.3</a><span class="t-li bullet">?</span>A set of higher-order output variables. These would be normative judgments or prescriptions which influence other utility variables. <a href="#da-80" class="to-code" title="#da-80">{…}</a></li>
</ul>
</li>
<li id="t1-2-1-1-8-2"><a id="t-1-2-1-1-8-2" name="t-1-2-1-1-8-2" class="li-num">1.2.1.1.8.2</a><span class="t-li bullet">?</span>Higher-order utility functions are mathematically isomorphic to utility functions but instead of governing motor outputs, they govern normative judgments or prescriptions which influence other utility variables.</li>
<li id="t1-2-1-1-8-3"><a id="t-1-2-1-1-8-3" name="t-1-2-1-1-8-3" class="li-num">1.2.1.1.8.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>It is very important to note that what makes these preferences or utilities higher-order is not their content but their causal or functional role.<ul style="display: none;">
<li id="t1-2-1-1-8-3-1"><a id="t-1-2-1-1-8-3-1" name="t-1-2-1-1-8-3-1" class="li-num">1.2.1.1.8.3.1</a><span class="t-li bullet">?</span>One can have in our sense, first-order preferences that prefer states involving other preferences.</li>
<li id="t1-2-1-1-8-3-2"><a id="t-1-2-1-1-8-3-2" name="t-1-2-1-1-8-3-2" class="li-num">1.2.1.1.8.3.2</a><span class="t-li bullet">?</span>Those might be referentially "higher-order" in some sense but they would still be first-order in our sense so long as they govern actions rather than normative judgments or prescriptions.</li>
</ul>
</li>
<li id="t1-2-1-1-8-4"><a id="t-1-2-1-1-8-4" name="t-1-2-1-1-8-4" class="li-num">1.2.1.1.8.4</a><span class="t-li bullet">?</span>If we wish to emphasize they are not ordinary utility functions or that term is contested, we may also call them evaluation functions.</li>
</ul>
</li>
<li id="t1-2-1-1-9"><a id="t-1-2-1-1-9" name="t-1-2-1-1-9" class="li-num">1.2.1.1.9</a><span class="t-li bullet">?</span>A function which maps the above variables to their set of possible values. <a href="#da-133" class="to-code" title="#da-133">{…}</a></li>
<li id="t1-2-1-1-10"><a id="t-1-2-1-1-10" name="t-1-2-1-1-10" class="li-num">1.2.1.1.10</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>An internal state transition function mapping assignments of value to input and internal state variables to the assignments of value to internal state variables that the decision algorithm would transition to in the next time step. <a href="#da-139" class="to-code" title="#da-139">{…}</a><ul style="display: none;">
<li id="t1-2-1-1-10-1"><a id="t-1-2-1-1-10-1" name="t-1-2-1-1-10-1" class="li-num">1.2.1.1.10.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>An assignment of values is just a function mapping variables to one of their possible values.<ul style="display: none;">
<li id="t1-2-1-1-10-1-1"><a id="t-1-2-1-1-10-1-1" name="t-1-2-1-1-10-1-1" class="li-num">1.2.1.1.10.1.1</a><span class="t-li bullet">?</span>We might also refer to this as a state or event, e.g. an input state. </li>
<li id="t1-2-1-1-10-1-2"><a id="t-1-2-1-1-10-1-2" name="t-1-2-1-1-10-1-2" class="li-num">1.2.1.1.10.1.2</a><span class="t-li bullet">?</span>State will generally imply that all variables of the given type have been assigned a value, whereas an event may only include some.</li>
</ul>
</li>
<li id="t1-2-1-1-10-2"><a id="t-1-2-1-1-10-2" name="t-1-2-1-1-10-2" class="li-num">1.2.1.1.10.2</a><span class="t-li bullet">?</span>Internal state variables are the probability, utility, memory, and second memory variables as well as all the variables composing each accepted norm. <a href="#s" class="to-code" title="#s">{…}</a></li>
</ul>
</li>
<li id="t1-2-1-1-11"><a id="t-1-2-1-1-11" name="t-1-2-1-1-11" class="li-num">1.2.1.1.11</a><span class="t-li bullet">?</span>An output state transition function mapping states of probability, utility and second memory variables to output states. <a href="#da-146" class="to-code" title="#da-146">{…}</a></li>
<li id="t1-2-1-1-12"><a id="t-1-2-1-1-12" name="t-1-2-1-1-12" class="li-num">1.2.1.1.12</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Given this definition, it is helpful to further define some terms:<ul style="display: none;">
<li id="t1-2-1-1-12-1"><a id="t-1-2-1-1-12-1" name="t-1-2-1-1-12-1" class="li-num">1.2.1.1.12.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>State transition function: The intuitive combination of the internal state transition function with the output state transition function. <a href="#t" class="to-code" title="#t">{…}</a><ul style="display: none;">
<li id="t1-2-1-1-12-1-1"><a id="t-1-2-1-1-12-1-1" name="t-1-2-1-1-12-1-1" class="li-num">1.2.1.1.12.1.1</a><span class="t-li bullet">?</span>It maps states of input and internal state variables to the states of internal state and output variables that would be transitioned to in the next time step.</li>
</ul>
</li>
<li id="t1-2-1-1-12-2"><a id="t-1-2-1-1-12-2" name="t-1-2-1-1-12-2" class="li-num">1.2.1.1.12.2</a><span class="t-li bullet">?</span>Parents of a variable: A variable's value assigned by the state transition function may depend on only a subset of the other variables' values. We'll call that subset the parents of that variable. <a href="#da-parents" class="to-code" title="#da-parents">{…}</a></li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-2"><a id="t-1-2-1-2" name="t-1-2-1-2" class="li-num">1.2.1.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Next, there must be an implementation function which maps brain states to decision states such that these two routes from a brain state to a decision event always arrive at the same result: <a href="#commutes" class="to-code" title="#commutes">{…}</a><ul style="display: none;">
<li id="t1-2-1-2-1"><a id="t-1-2-1-2-1" name="t-1-2-1-2-1" class="li-num">1.2.1.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>For the first route,<ul style="display: none;">
<li id="t1-2-1-2-1-1"><a id="t-1-2-1-2-1-1" name="t-1-2-1-2-1-1" class="li-num">1.2.1.2.1.1</a><span class="t-li bullet">?</span>From the brain state, find the causal response of the endogenous variables in the next time step.</li>
<li id="t1-2-1-2-1-2"><a id="t-1-2-1-2-1-2" name="t-1-2-1-2-1-2" class="li-num">1.2.1.2.1.2</a><span class="t-li bullet">?</span>Add arbitrary values for the exogenous variables, just to reach a complete brain state for the next step.</li>
<li id="t1-2-1-2-1-3"><a id="t-1-2-1-2-1-3" name="t-1-2-1-2-1-3" class="li-num">1.2.1.2.1.3</a><span class="t-li bullet">?</span>From that complete brain state, find the decision state the implementation function maps it to.</li>
<li id="t1-2-1-2-1-4"><a id="t-1-2-1-2-1-4" name="t-1-2-1-2-1-4" class="li-num">1.2.1.2.1.4</a><span class="t-li bullet">?</span>Finally, drop the portion of the decision state that assigns values to the input variables.</li>
</ul>
</li>
<li id="t1-2-1-2-2"><a id="t-1-2-1-2-2" name="t-1-2-1-2-2" class="li-num">1.2.1.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>For the second route,<ul style="display: none;">
<li id="t1-2-1-2-2-1"><a id="t-1-2-1-2-2-1" name="t-1-2-1-2-2-1" class="li-num">1.2.1.2.2.1</a><span class="t-li bullet">?</span>First find the decision state the implementation function maps the initial brain state to.</li>
<li id="t1-2-1-2-2-2"><a id="t-1-2-1-2-2-2" name="t-1-2-1-2-2-2" class="li-num">1.2.1.2.2.2</a><span class="t-li bullet">?</span>Then drop the portion of that decision state that assigns values to output variables.</li>
<li id="t1-2-1-2-2-3"><a id="t-1-2-1-2-2-3" name="t-1-2-1-2-2-3" class="li-num">1.2.1.2.2.3</a><span class="t-li bullet">?</span>Finally, identify the decision event that the previous step's result gets mapped to by the state transition function.</li>
</ul>
</li>
<li id="t1-2-1-2-3"><a id="t-1-2-1-2-3" name="t-1-2-1-2-3" class="li-num">1.2.1.2.3</a><span class="t-li bullet">?</span>This criterion comes from David Chalmers' <a href="http://consc.net/papers/rock.html">Does a Rock Implement Every Finite-State Automaton?</a></li>
</ul>
</li>
<li id="t1-2-1-3"><a id="t-1-2-1-3" name="t-1-2-1-3" class="li-num">1.2.1.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>It achieves a high rate of compression of the brain's causal transition function. <a href="#complexity" class="to-code" title="#complexity">{…}</a><ul style="display: none;">
<li id="t1-2-1-3-1"><a id="t-1-2-1-3-1" name="t-1-2-1-3-1" class="li-num">1.2.1.3.1</a><span class="t-li bullet">?</span>A brain's causal transition function maps each brain state to the state of its endogenous variables that would be the causal response in the next time step to that brain state. <a href="#t_to_str" class="to-code" title="#t_to_str">{…}</a></li>
<li id="t1-2-1-3-2"><a id="t-1-2-1-3-2" name="t-1-2-1-3-2" class="li-num">1.2.1.3.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Higher compression rate means it explains more of the transition function with a smaller encoding.<ul style="display: none;">
<li id="t1-2-1-3-2-1"><a id="t-1-2-1-3-2-1" name="t-1-2-1-3-2-1" class="li-num">1.2.1.3.2.1</a><span class="t-li bullet">?</span>This can be seen as a more realist and formal version of Daniel Dennett's <a href="https://sites.google.com/site/minddict/intentional-stance-the">intentional stance</a>.</li>
<li id="t1-2-1-3-2-2"><a id="t-1-2-1-3-2-2" name="t-1-2-1-3-2-2" class="li-num">1.2.1.3.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>This is measured by K(df), the Kolmogorov complexity of a string encoding of the decision algorithm and its implementation function, plus K(b|df), the Kolmogorov complexity of a string encoding of the brain's transition function given that first string. <a href="#complexity" class="to-code" title="#complexity">{…}</a><ul style="display: none;">
<li id="t1-2-1-3-2-2-1"><a id="t-1-2-1-3-2-2-1" name="t-1-2-1-3-2-2-1" class="li-num">1.2.1.3.2.2.1</a><span class="t-li bullet">?</span>Lower complexity values indicate higher compression rate.</li>
<li id="t1-2-1-3-2-2-2"><a id="t-1-2-1-3-2-2-2" name="t-1-2-1-3-2-2-2" class="li-num">1.2.1.3.2.2.2</a><span class="t-li bullet">?</span>Unfortunately, this is uncomputable, but it could be replaced by some finite approximation.</li>
<li id="t1-2-1-3-2-2-3"><a id="t-1-2-1-3-2-2-3" name="t-1-2-1-3-2-2-3" class="li-num">1.2.1.3.2.2.3</a><span class="t-li bullet">?</span>K(df) measures the simplicity/complexity of the model or hypothesis. <a href="#k" class="to-code" title="#k">{…}</a></li>
<li id="t1-2-1-3-2-2-4"><a id="t-1-2-1-3-2-2-4" name="t-1-2-1-3-2-2-4" class="li-num">1.2.1.3.2.2.4</a><span class="t-li bullet">?</span>K(b|df) measures how well the decision model explains the brain's transitions by indicating how much of that data remains to be captured as noise or with auxiliary hypotheses after the model is applied. <a href="#k_given" class="to-code" title="#k_given">{…}</a></li>
</ul>
</li>
<li id="t1-2-1-3-2-3"><a id="t-1-2-1-3-2-3" name="t-1-2-1-3-2-3" class="li-num">1.2.1.3.2.3</a><span class="t-li bullet">?</span>See the closely related literature on Minimum Description Length, which is a finite approximation.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-4"><a id="t-1-2-1-4" name="t-1-2-1-4" class="li-num">1.2.1.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>It is probabilistically coherent, including with its represented causal models. <a href="#incoherence" class="to-code" title="#incoherence">{…}</a><ul style="display: none;">
<li id="t1-2-1-4-1"><a id="t-1-2-1-4-1" name="t-1-2-1-4-1" class="li-num">1.2.1.4.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Represented causal models are composed of credences in subjunctive conditionals, i.e. an expression of the form: A []-&gt; B. (BoxArrow in the code.) <a href="#da-43" class="to-code" title="#da-43">{…}</a><ul style="display: none;">
<li id="t1-2-1-4-1-1"><a id="t-1-2-1-4-1-1" name="t-1-2-1-4-1-1" class="li-num">1.2.1.4.1.1</a><span class="t-li bullet">?</span>We borrow the more convenient syntax from David Lewis but interpret it in line with Pearl's causal models.</li>
<li id="t1-2-1-4-1-2"><a id="t-1-2-1-4-1-2" name="t-1-2-1-4-1-2" class="li-num">1.2.1.4.1.2</a><span class="t-li bullet">?</span>Subjunctive conditionals that are not mediated by other subjunctive conditionals would correspond to structural equations.</li>
<li id="t1-2-1-4-1-3"><a id="t-1-2-1-4-1-3" name="t-1-2-1-4-1-3" class="li-num">1.2.1.4.1.3</a><span class="t-li bullet">?</span>In contrast, mediated subjunctive conditionals would constitute credences about causal responses.</li>
<li id="t1-2-1-4-1-4"><a id="t-1-2-1-4-1-4" name="t-1-2-1-4-1-4" class="li-num">1.2.1.4.1.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>See section 4 of Galles and Pearl's <a href="https://ftp.cs.ucla.edu/pub/stat_ser/R250.pdf">An Axiomatic Characterization of Causal Counterfactuals</a> for further comparisons.<ul style="display: none;">
<li id="t1-2-1-4-1-4-1"><a id="t-1-2-1-4-1-4-1" name="t-1-2-1-4-1-4-1" class="li-num">1.2.1.4.1.4.1</a><span class="t-li bullet">?</span>"In sum, for recursive models, the causal model framework does not add any restrictions to counterfactual statements beyond those imposed by Lewis's framework; the very general system of closest worlds is sufficient for recursive systems."</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-4-2"><a id="t-1-2-1-4-2" name="t-1-2-1-4-2" class="li-num">1.2.1.4.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Synchronic coherence is measured by taking the absolute distance to the closest perfectly coherent probability distribution. <a href="#prob_distance" class="to-code" title="#prob_distance">{…}</a><ul style="display: none;">
<li id="t1-2-1-4-2-1"><a id="t-1-2-1-4-2-1" name="t-1-2-1-4-2-1" class="li-num">1.2.1.4.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Advantages of the absolute distance measure for coherence:<ul style="display: none;">
<li id="t1-2-1-4-2-1-1"><a id="t-1-2-1-4-2-1-1" name="t-1-2-1-4-2-1-1" class="li-num">1.2.1.4.2.1.1</a><span class="t-li bullet">?</span>For unconditional credences, this is equivalent to the "greatest guaranteed Dutch book loss that can be achieved using each of the agent's credences for at most one bet." (Staffel, <a href="https://link.springer.com/article/10.1007/s11229-014-0640-x">Measuring the Overall Incoherence of Credence Functions</a> and Bona &amp; Finger, <a href="https://www.ime.usp.br/~mfinger/www-home/papers/DBF2014-reltec.pdf">Notes on Measuring Inconsistency in Probabilistic Logic</a>)</li>
<li id="t1-2-1-4-2-1-2"><a id="t-1-2-1-4-2-1-2" name="t-1-2-1-4-2-1-2" class="li-num">1.2.1.4.2.1.2</a><span class="t-li bullet">?</span>In a study of election forecasts, subjects with the most coherent forecasts were found to be the most accurate. (Wang et al., <a href="https://www.princeton.edu/~osherson/papers/agg6Arvid.pdf">Aggregating Large Sets of Probabilistic Forecasts by Weighted Coherent Adjustment</a>)</li>
<li id="t1-2-1-4-2-1-3"><a id="t-1-2-1-4-2-1-3" name="t-1-2-1-4-2-1-3" class="li-num">1.2.1.4.2.1.3</a><span class="t-li bullet">?</span>Unlike some other measures, it doesn't end up narrowly focusing on just a subset of credences as a worst case. (Staffel, <a href="https://link.springer.com/article/10.1007/s11229-014-0640-x">Measuring the Overall Incoherence of Credence Functions</a>)</li>
<li id="t1-2-1-4-2-1-4"><a id="t-1-2-1-4-2-1-4" name="t-1-2-1-4-2-1-4" class="li-num">1.2.1.4.2.1.4</a><span class="t-li bullet">?</span>It is simple and tractable.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-4-3"><a id="t-1-2-1-4-3" name="t-1-2-1-4-3" class="li-num">1.2.1.4.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Diachronic coherence is measured in the same way as <a href="#t1-2-3-3-2">agential identity for credences</a>. <a href="#p_conn_continuity" class="to-code" title="#p_conn_continuity">{…}</a><ul style="display: none;">
<li id="t1-2-1-4-3-1"><a id="t-1-2-1-4-3-1" name="t-1-2-1-4-3-1" class="li-num">1.2.1.4.3.1</a><span class="t-li bullet">?</span>Probabilities either stay the same or get updated to be close to what a (locally) ideally rational inference would result in.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-5"><a id="t-1-2-1-5" name="t-1-2-1-5" class="li-num">1.2.1.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>It is instrumentally rational in both its first-order and higher-order utility functions. <a href="#instr_irrat" class="to-code" title="#instr_irrat">{…}</a><ul style="display: none;">
<li id="t1-2-1-5-1"><a id="t-1-2-1-5-1" name="t-1-2-1-5-1" class="li-num">1.2.1.5.1</a><span class="t-li bullet">?</span>The instrumental irrationality of a brain's decision algorithm is the average instrumental irrationality of its time slices.</li>
<li id="t1-2-1-5-2"><a id="t-1-2-1-5-2" name="t-1-2-1-5-2" class="li-num">1.2.1.5.2</a><span class="t-li bullet">?</span>The instrumental irrationality of a time slice is the average instrumental irrationality of its first- and higher-order utility functions' output states. <a href="#e_dist" class="to-code" title="#e_dist">{…}</a></li>
<li id="t1-2-1-5-3"><a id="t-1-2-1-5-3" name="t-1-2-1-5-3" class="li-num">1.2.1.5.3</a><span class="t-li bullet">?</span>Given an output state, its instrumental irrationality is the ordinal rank of its expected utility among that of all other possible states of those output variables, normalized by the number of those possible output states. <a href="#e_i_dist" class="to-code" title="#e_i_dist">{…}</a></li>
<li id="t1-2-1-5-4"><a id="t-1-2-1-5-4" name="t-1-2-1-5-4" class="li-num">1.2.1.5.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Given a possible output state, its expected utility is computed by: <a href="#exp_u" class="to-code" title="#exp_u">{…}</a><ul style="display: none;">
<li id="t1-2-1-5-4-1"><a id="t-1-2-1-5-4-1" name="t-1-2-1-5-4-1" class="li-num">1.2.1.5.4.1</a><span class="t-li bullet">?</span>First, finding an expression that refers to the given output state.</li>
<li id="t1-2-1-5-4-2"><a id="t-1-2-1-5-4-2" name="t-1-2-1-5-4-2" class="li-num">1.2.1.5.4.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Then, summing, for each utility expression governing the output variables, the product of:<ul style="display: none;">
<li id="t1-2-1-5-4-2-1"><a id="t-1-2-1-5-4-2-1" name="t-1-2-1-5-4-2-1" class="li-num">1.2.1.5.4.2.1</a><span class="t-li bullet">?</span>The subjective probability assigned to the subjunctive conditional that the output expression causes the utility expression, and</li>
<li id="t1-2-1-5-4-2-2"><a id="t-1-2-1-5-4-2-2" name="t-1-2-1-5-4-2-2" class="li-num">1.2.1.5.4.2.2</a><span class="t-li bullet">?</span>The cardinal utility assigned to the utility expression.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-6"><a id="t-1-2-1-6" name="t-1-2-1-6" class="li-num">1.2.1.6</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>It is ambitious, trying to explain as much as possible with the decision algorithm. <a href="#ambitiousness" class="to-code" title="#ambitiousness">{…}</a><ul style="display: none;">
<li id="t1-2-1-6-1"><a id="t-1-2-1-6-1" name="t-1-2-1-6-1" class="li-num">1.2.1.6.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Without this, there is a worry that the best compression officially involves a minimal decision algorithm but in actuality, sneaks in a decision algorithmic explanation through other channels.<ul style="display: none;">
<li id="t1-2-1-6-1-1"><a id="t-1-2-1-6-1-1" name="t-1-2-1-6-1-1" class="li-num">1.2.1.6.1.1</a><span class="t-li bullet">?</span>Suppose our syntax for specifying decision algorithms is somewhat inefficient.</li>
<li id="t1-2-1-6-1-2"><a id="t-1-2-1-6-1-2" name="t-1-2-1-6-1-2" class="li-num">1.2.1.6.1.2</a><span class="t-li bullet">?</span>Then the smallest compression might be produced by an empty d with all the work being done by a turing machine associated with the k(b|df) term which generates b using essentially the same decision algorithm we would have wanted to use as d but with a more efficient syntax.</li>
<li id="t1-2-1-6-1-3"><a id="t-1-2-1-6-1-3" name="t-1-2-1-6-1-3" class="li-num">1.2.1.6.1.3</a><span class="t-li bullet">?</span>The k(b|df) term's turing machine was supposed to just encode noise or perhaps things like reflexes which are not decision algorithmic in nature.</li>
<li id="t1-2-1-6-1-4"><a id="t-1-2-1-6-1-4" name="t-1-2-1-6-1-4" class="li-num">1.2.1.6.1.4</a><span class="t-li bullet">?</span>It seems what we'd need is something like a not-a-decision-algorithmic-explanation predicate to apply to the turing machine.</li>
<li id="t1-2-1-6-1-5"><a id="t-1-2-1-6-1-5" name="t-1-2-1-6-1-5" class="li-num">1.2.1.6.1.5</a><span class="t-li bullet">?</span>Or we want d to be ambitious, packing as much of a decision-algorithmic explanation as possible, or at least positively weighing its ambitiousness against potential increases in complexity.</li>
</ul>
</li>
<li id="t1-2-1-6-2"><a id="t-1-2-1-6-2" name="t-1-2-1-6-2" class="li-num">1.2.1.6.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>We come up with a measure for a decision algorithm's ambitiousness, which quantifies the extent to which it leaves out decision-algorithmic explanations.<ul style="display: none;">
<li id="t1-2-1-6-2-1"><a id="t-1-2-1-6-2-1" name="t-1-2-1-6-2-1" class="li-num">1.2.1.6.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>For a given decision algorithm d, consider the auxiliary hypothesis h, which together with d (and the implementation function f) best explains the brain b. <a href="#h" class="to-code" title="#h">{…}</a><ul style="display: none;">
<li id="t1-2-1-6-2-1-1"><a id="t-1-2-1-6-2-1-1" name="t-1-2-1-6-2-1-1" class="li-num">1.2.1.6.2.1.1</a><span class="t-li bullet">?</span>K(b|df) would be the length of h.</li>
</ul>
</li>
<li id="t1-2-1-6-2-2"><a id="t-1-2-1-6-2-2" name="t-1-2-1-6-2-2" class="li-num">1.2.1.6.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>We then look for the worst case decomposition of h into hs_k, or [h_i, h_j], where hs_k is most similar to h and hs_k makes d least ambitious. <a href="#hs_score" class="to-code" title="#hs_score">{…}</a><ul style="display: none;">
<li id="t1-2-1-6-2-2-1"><a id="t-1-2-1-6-2-2-1" name="t-1-2-1-6-2-2-1" class="li-num">1.2.1.6.2.2.1</a><span class="t-li bullet">?</span>The similarity of hs_k to h is measured by -1 * ( K(h|hs_k) + K(hs_k|h) ). <a href="#hs_similarity" class="to-code" title="#hs_similarity">{…}</a></li>
<li id="t1-2-1-6-2-2-2"><a id="t-1-2-1-6-2-2-2" name="t-1-2-1-6-2-2-2" class="li-num">1.2.1.6.2.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Given an hs_k, we look for the best d* which is <a href="#ambitiousness_with_hs" class="to-code" title="#ambitiousness_with_hs">{…}</a><ul style="display: none;">
<li id="t1-2-1-6-2-2-2-1"><a id="t-1-2-1-6-2-2-2-1" name="t-1-2-1-6-2-2-2-1" class="li-num">1.2.1.6.2.2.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>a "superset" of d <a href="#is_subset_of" class="to-code" title="#is_subset_of">{…}</a><ul style="display: none;">
<li id="t1-2-1-6-2-2-2-1-1"><a id="t-1-2-1-6-2-2-2-1-1" name="t-1-2-1-6-2-2-2-1-1" class="li-num">1.2.1.6.2.2.2.1.1</a><span class="t-li bullet">?</span>It has additional variables and therefore states, but when considering just the shared variables, it is isomorphic.</li>
</ul>
</li>
<li id="t1-2-1-6-2-2-2-2"><a id="t-1-2-1-6-2-2-2-2" name="t-1-2-1-6-2-2-2-2" class="li-num">1.2.1.6.2.2.2.2</a><span class="t-li bullet">?</span>most similar to d + h_i, and <a href="#d_star_sim" class="to-code" title="#d_star_sim">{…}</a></li>
<li id="t1-2-1-6-2-2-2-3"><a id="t-1-2-1-6-2-2-2-3" name="t-1-2-1-6-2-2-2-3" class="li-num">1.2.1.6.2.2.2.3</a><span class="t-li bullet">?</span>most coherent <a href="#incoherence" class="to-code" title="#incoherence">{…}</a></li>
</ul>
</li>
<li id="t1-2-1-6-2-2-3"><a id="t-1-2-1-6-2-2-3" name="t-1-2-1-6-2-2-3" class="li-num">1.2.1.6.2.2.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The ambitiousness given the hs_k can then be measured by: <a href="#ambitiousness_with_hs" class="to-code" title="#ambitiousness_with_hs">{…}</a><ul style="display: none;">
<li id="t1-2-1-6-2-2-3-1"><a id="t-1-2-1-6-2-2-3-1" name="t-1-2-1-6-2-2-3-1" class="li-num">1.2.1.6.2.2.3.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>the relative change in incoherence and instrumental irrationality with d* vs d<ul style="display: none;">
<li id="t1-2-1-6-2-2-3-1-1"><a id="t-1-2-1-6-2-2-3-1-1" name="t-1-2-1-6-2-2-3-1-1" class="li-num">1.2.1.6.2.2.3.1.1</a><span class="t-li bullet">?</span>More incoherence and instrumental irrationality means more ambitious because there's less of real decision algorithmic stuff left in h_i.</li>
</ul>
</li>
<li id="t1-2-1-6-2-2-3-2"><a id="t-1-2-1-6-2-2-3-2" name="t-1-2-1-6-2-2-3-2" class="li-num">1.2.1.6.2.2.3.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>minus the relative change in complexity with d* vs d<ul style="display: none;">
<li id="t1-2-1-6-2-2-3-2-1"><a id="t-1-2-1-6-2-2-3-2-1" name="t-1-2-1-6-2-2-3-2-1" class="li-num">1.2.1.6.2.2.3.2.1</a><span class="t-li bullet">?</span>More complexity means less ambitious because there's more decision algorithmic stuff in h_i and not in d.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-1-6-2-2-4"><a id="t-1-2-1-6-2-2-4" name="t-1-2-1-6-2-2-4" class="li-num">1.2.1.6.2.2.4</a><span class="t-li bullet">?</span>In other words, the more there is a d* which is highly similar to d + some h_i and very coherent and instrumentally rational, the less ambitious d is.</li>
<li id="t1-2-1-6-2-2-5"><a id="t-1-2-1-6-2-2-5" name="t-1-2-1-6-2-2-5" class="li-num">1.2.1.6.2.2.5</a><span class="t-li bullet">?</span>It would leave out too much that could and should be explained using a decision algorithmic explanation.</li>
<li id="t1-2-1-6-2-2-6"><a id="t-1-2-1-6-2-2-6" name="t-1-2-1-6-2-2-6" class="li-num">1.2.1.6.2.2.6</a><span class="t-li bullet">?</span>If d is very ambitious, there's more like just noise left for the auxiliary hypothesis or you'd have to stray further from the auxiliary hypothesis to subsume it under a decision algorithmic explanation.</li>
</ul>
</li>
<li id="t1-2-1-6-2-3"><a id="t-1-2-1-6-2-3" name="t-1-2-1-6-2-3" class="li-num">1.2.1.6.2.3</a><span class="t-li bullet">?</span>The ambitiousness of d in the worst case decomposition is d's ambitiousness.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-2"><a id="t-1-2-2" name="t-1-2-2" class="li-num">1.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The final formulation specifying the rational utility function gets rather complicated but we can build up to it with a couple initial approximations:<ul style="display: none;">
<li id="t1-2-2-1"><a id="t-1-2-2-1" name="t-1-2-2-1" class="li-num">1.2.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>First pass: Suppose an agent's accepted norms form a hierarchy with one highest fundamental norm.<ul style="display: none;">
<li id="t1-2-2-1-1"><a id="t-1-2-2-1-1" name="t-1-2-2-1-1" class="li-num">1.2.2.1.1</a><span class="t-li bullet">?</span>In that case, we can work out what lower-order norms are prescribed by it and in turn, what those lower-order norms prescribe.</li>
<li id="t1-2-2-1-2"><a id="t-1-2-2-1-2" name="t-1-2-2-1-2" class="li-num">1.2.2.1.2</a><span class="t-li bullet">?</span>Eventually, we'd reach the prescribed first-order values, which would be the rational utility function.</li>
<li id="t1-2-2-1-3"><a id="t-1-2-2-1-3" name="t-1-2-2-1-3" class="li-num">1.2.2.1.3</a><span class="t-li bullet">?</span>However, the assumption that the accepted norms form a neat hierarchy seems to be overly restrictive and biologically / psychologically implausible.</li>
</ul>
</li>
<li id="t1-2-2-2"><a id="t-1-2-2-2" name="t-1-2-2-2" class="li-num">1.2.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Second pass: We might instead model the accepted norms as forming a network in which many of them may mutually influence each other.<ul style="display: none;">
<li id="t1-2-2-2-1"><a id="t-1-2-2-2-1" name="t-1-2-2-2-1" class="li-num">1.2.2.2.1</a><span class="t-li bullet">?</span>Assuming the transition to the next state depends only on the previous state, we can model this as a Markov network.</li>
<li id="t1-2-2-2-2"><a id="t-1-2-2-2-2" name="t-1-2-2-2-2" class="li-num">1.2.2.2.2</a><span class="t-li bullet">?</span>Credences that some higher-order output would cause a change in utility state that satisfies the higher-order criteria would tend to cause that output to be transitioned to.</li>
<li id="t1-2-2-2-3"><a id="t-1-2-2-2-3" name="t-1-2-2-2-3" class="li-num">1.2.2.2.3</a><span class="t-li bullet">?</span>In this scenario, we could iteratively choose outputs that best satisfy the higher-order criteria and allow them to simultaneously influence other utility / evaluation states until we reach a stationary distribution that would constitute the reflective equilibrium.</li>
<li id="t1-2-2-2-4"><a id="t-1-2-2-2-4" name="t-1-2-2-2-4" class="li-num">1.2.2.2.4</a><span class="t-li bullet">?</span>The first-order utility function in that equilibrium would be the rational utility function.</li>
<li id="t1-2-2-2-5"><a id="t-1-2-2-2-5" name="t-1-2-2-2-5" class="li-num">1.2.2.2.5</a><span class="t-li bullet">?</span>Even this, however, may still be biologically implausible. We would be assuming that the network topology of which norms affect which others would be constant, but it may be path dependent and vary with differing input states.</li>
<li id="t1-2-2-2-6"><a id="t-1-2-2-2-6" name="t-1-2-2-2-6" class="li-num">1.2.2.2.6</a><span class="t-li bullet">?</span>There may also be no guarantee of ever converging on a stable equilibrium.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-3"><a id="t-1-2-3" name="t-1-2-3" class="li-num">1.2.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Final specification: Simulate all possible continuations of an agent and apply a social welfare function to their utility functions while weighting them by optimality of prescriptions, agential identity and likelihood.<ul style="display: none;">
<li id="t1-2-3-1"><a id="t-1-2-3-1" name="t-1-2-3-1" class="li-num">1.2.3.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A continuation is a series of time slices in which each slice's internal and output states are determined by the transition state function from the previous slice. <a href="#bs_msr_paths" class="to-code" title="#bs_msr_paths">{…}</a><ul style="display: none;">
<li id="t1-2-3-1-1"><a id="t-1-2-3-1-1" name="t-1-2-3-1-1" class="li-num">1.2.3.1.1</a><span class="t-li bullet">?</span>Each time slice branches into different next step slices for each possible input state compatible with the next internal and output states. (We require compatibility since the sets of variables may overlap.)</li>
</ul>
</li>
<li id="t1-2-3-2"><a id="t-1-2-3-2" name="t-1-2-3-2" class="li-num">1.2.3.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>In future versions, we may incorporate subjective likelihood of the input states,  but currently we just give them equal weight.<ul style="display: none;">
<li id="t1-2-3-2-1"><a id="t-1-2-3-2-1" name="t-1-2-3-2-1" class="li-num">1.2.3.2.1</a><span class="t-li bullet">?</span>The lack of subjective likelihood is mitigated by our inclusion of agential identity.</li>
</ul>
</li>
<li id="t1-2-3-3"><a id="t-1-2-3-3" name="t-1-2-3-3" class="li-num">1.2.3.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Agential identity measures how much an agent is either the same or is the result of a locally rational update. <a href="#agential_identity" class="to-code" title="#agential_identity">{…}</a><ul style="display: none;">
<li id="t1-2-3-3-1"><a id="t-1-2-3-3-1" name="t-1-2-3-3-1" class="li-num">1.2.3.3.1</a><span class="t-li bullet">?</span>Agential identity is similar to personal identity but focuses on sameness of person for agency rather than care. It answers when a possible self truly reflects <em>your</em> underlying disposition as opposed to that of a stranger or distortion.</li>
<li id="t1-2-3-3-2"><a id="t-1-2-3-3-2" name="t-1-2-3-3-2" class="li-num">1.2.3.3.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>For credences, a locally rational update is a locally Bayesian update. <a href="#cog_change" class="to-code" title="#cog_change">{…}</a><ul style="display: none;">
<li id="t1-2-3-3-2-1"><a id="t-1-2-3-3-2-1" name="t-1-2-3-3-2-1" class="li-num">1.2.3.3.2.1</a><span class="t-li bullet">?</span>In other words, there are P(E), P(H), P(E|H) and at the next time step a P(H|E) such that the P(H|E) = P(E|H) * P(H) / P(E). </li>
</ul>
</li>
<li id="t1-2-3-3-3"><a id="t-1-2-3-3-3" name="t-1-2-3-3-3" class="li-num">1.2.3.3.3</a><span class="t-li bullet">?</span>For utilities, a locally rational change is one that involves i) recognition that some prescription would cause a utility change, ii) that recognition in fact causes the prescription and iii) that prescription causes the utility change. <a href="#u_conn" class="to-code" title="#u_conn">{…}</a></li>
<li id="t1-2-3-3-4"><a id="t-1-2-3-3-4" name="t-1-2-3-3-4" class="li-num">1.2.3.3.4</a><span class="t-li bullet">?</span>For both, it can be measured in degrees by reference to how much closer to a perfectly locally rational value the credence or utility was updated.</li>
<li id="t1-2-3-3-5"><a id="t-1-2-3-3-5" name="t-1-2-3-3-5" class="li-num">1.2.3.3.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Given a pair or triplet of time slices, the degree of agential connection between them takes the greater of sameness / closeness of values or degree of locally rational update.<ul style="display: none;">
<li id="t1-2-3-3-5-1"><a id="t-1-2-3-3-5-1" name="t-1-2-3-3-5-1" class="li-num">1.2.3.3.5.1</a><span class="t-li bullet">?</span>These are normalized to 0-1 scores. The remainder between the greater score and 1 can also be multiplied by the lesser score to add partial credit for partial similarity or rationality.</li>
</ul>
</li>
<li id="t1-2-3-3-6"><a id="t-1-2-3-3-6" name="t-1-2-3-3-6" class="li-num">1.2.3.3.6</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>For longer chains of time slices, agential identity can be broken down into the agential connection between the first and last plus the agential continuity throughout the chain.<ul style="display: none;">
<li id="t1-2-3-3-6-1"><a id="t-1-2-3-3-6-1" name="t-1-2-3-3-6-1" class="li-num">1.2.3.3.6.1</a><span class="t-li bullet">?</span>The agential continuity of a chain can incorporate both the average agential connection between consecutive time slices as well as the minimum maintained throughout.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-3-4"><a id="t-1-2-3-4" name="t-1-2-3-4" class="li-num">1.2.3.4</a><span class="t-li bullet">?</span>Optimality measures how well the prescriptions observed in a continuation satisfied the higher-order decision criteria compared to the alternative outputs. <a href="#optimal_rxs" class="to-code" title="#optimal_rxs">{…}</a></li>
<li id="t1-2-3-5"><a id="t-1-2-3-5" name="t-1-2-3-5" class="li-num">1.2.3.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The social welfare function might be thought of as choosing a center of gravity between the weighted utility functions of possible continuations.<ul style="display: none;">
<li id="t1-2-3-5-1"><a id="t-1-2-3-5-1" name="t-1-2-3-5-1" class="li-num">1.2.3.5.1</a><span class="t-li bullet">?</span>The resulting rational utility function is chosen from a set of cardinal additive utility functions ranging over the observed brain's logical / causal expressions.</li>
<li id="t1-2-3-5-2"><a id="t-1-2-3-5-2" name="t-1-2-3-5-2" class="li-num">1.2.3.5.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>From this set, we choose the one that minimizes the weighted squared distance to the continuations' utility functions.<ul style="display: none;">
<li id="t1-2-3-5-2-1"><a id="t-1-2-3-5-2-1" name="t-1-2-3-5-2-1" class="li-num">1.2.3.5.2.1</a><span class="t-li bullet">?</span>Continuations that have more optimal prescriptions, greater agential identity and likelihood are weighted more heavily. <a href="#voter_weight" class="to-code" title="#voter_weight">{…}</a></li>
<li id="t1-2-3-5-2-2"><a id="t-1-2-3-5-2-2" name="t-1-2-3-5-2-2" class="li-num">1.2.3.5.2.2</a><span class="t-li bullet">?</span>Squaring the distance allows for prioritarian consideration for farther off distances to otherwise equally weighted continuations.</li>
<li id="t1-2-3-5-2-3"><a id="t-1-2-3-5-2-3" name="t-1-2-3-5-2-3" class="li-num">1.2.3.5.2.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Distances between utility functions are measured as Hausdorff Kendall Tau distances between ordinal utility functions. <a href="#ord_u_dist" class="to-code" title="#ord_u_dist">{…}</a><ul style="display: none;">
<li id="t1-2-3-5-2-3-1"><a id="t-1-2-3-5-2-3-1" name="t-1-2-3-5-2-3-1" class="li-num">1.2.3.5.2.3.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Internal to a decision algorithm, utility functions are represented as additive cardinal utility functions.<ul style="display: none;">
<li id="t1-2-3-5-2-3-1-1"><a id="t-1-2-3-5-2-3-1-1" name="t-1-2-3-5-2-3-1-1" class="li-num">1.2.3.5.2.3.1.1</a><span class="t-li bullet">?</span>The utility placed in a state of affairs is the sum of the utility placed in any event / substate within that state.</li>
<li id="t1-2-3-5-2-3-1-2"><a id="t-1-2-3-5-2-3-1-2" name="t-1-2-3-5-2-3-1-2" class="li-num">1.2.3.5.2.3.1.2</a><span class="t-li bullet">?</span>This allows for a more psychologically plausible realization than representing utilities for each complete state.</li>
<li id="t1-2-3-5-2-3-1-3"><a id="t-1-2-3-5-2-3-1-3" name="t-1-2-3-5-2-3-1-3" class="li-num">1.2.3.5.2.3.1.3</a><span class="t-li bullet">?</span>However, by allowing utility to be placed in conjunctions to modify what the sum of their atomic events' utility would otherwise be, this doesn't actually constrain the space of utility functions.</li>
</ul>
</li>
<li id="t1-2-3-5-2-3-2"><a id="t-1-2-3-5-2-3-2" name="t-1-2-3-5-2-3-2" class="li-num">1.2.3.5.2.3.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>To set up the comparison to other utility functions, the additive cardinal utility function is first translated into an ordinal utility function.<ul style="display: none;">
<li id="t1-2-3-5-2-3-2-1"><a id="t-1-2-3-5-2-3-2-1" name="t-1-2-3-5-2-3-2-1" class="li-num">1.2.3.5.2.3.2.1</a><span class="t-li bullet">?</span>This, in turn, is done by an intermediate translation into a cardinal utility function ranging over expression states, i.e. assignments of values to all of the brain's atomic expressions. <a href="#add_u_to_card_u" class="to-code" title="#add_u_to_card_u">{…}</a></li>
<li id="t1-2-3-5-2-3-2-2"><a id="t-1-2-3-5-2-3-2-2" name="t-1-2-3-5-2-3-2-2" class="li-num">1.2.3.5.2.3.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Then, the ordinal utility function is constructed by collecting the preference relation for each pair of lotteries. <a href="#card_u_to_ord_u" class="to-code" title="#card_u_to_ord_u">{…}</a><ul style="display: none;">
<li id="t1-2-3-5-2-3-2-2-1"><a id="t-1-2-3-5-2-3-2-2-1" name="t-1-2-3-5-2-3-2-2-1" class="li-num">1.2.3.5.2.3.2.2.1</a><span class="t-li bullet">?</span>A lottery is an assignment of probabilities to states that sum to 1.</li>
<li id="t1-2-3-5-2-3-2-2-2"><a id="t-1-2-3-5-2-3-2-2-2" name="t-1-2-3-5-2-3-2-2-2" class="li-num">1.2.3.5.2.3.2.2.2</a><span class="t-li bullet">?</span>The utility of a lottery is the sum of the utilities of each state multiplied by their respective probabilities.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-3-5-2-3-3"><a id="t-1-2-3-5-2-3-3" name="t-1-2-3-5-2-3-3" class="li-num">1.2.3.5.2.3.3</a><span class="t-li bullet">?</span>Since Kendall Tau measures distances between strict ordinal rankings, we first associate each utility function with the set of strict ordinal utility functions that are compatible with the strict inequalities in that utility function.</li>
<li id="t1-2-3-5-2-3-4"><a id="t-1-2-3-5-2-3-4" name="t-1-2-3-5-2-3-4" class="li-num">1.2.3.5.2.3.4</a><span class="t-li bullet">?</span>The Hausdorff distance between the sets of strict ordinal utility functions measures the "greatest of all the distances from a [utility function] in one set to the closest [utility function] in the other set." <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Wikipedia</a> <a href="#hausdorff_dist" class="to-code" title="#hausdorff_dist">{…}</a></li>
<li id="t1-2-3-5-2-3-5"><a id="t-1-2-3-5-2-3-5" name="t-1-2-3-5-2-3-5" class="li-num">1.2.3.5.2.3.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The distance between the sharpened utility functions is the Kendall Tau distance. <a href="#kendalls_tau_dist" class="to-code" title="#kendalls_tau_dist">{…}</a><ul style="display: none;">
<li id="t1-2-3-5-2-3-5-1"><a id="t-1-2-3-5-2-3-5-1" name="t-1-2-3-5-2-3-5-1" class="li-num">1.2.3.5.2.3.5.1</a><span class="t-li bullet">?</span>This can be calculated by simply counting the number of pairwise disagreements between the two utility functions.</li>
<li id="t1-2-3-5-2-3-5-2"><a id="t-1-2-3-5-2-3-5-2" name="t-1-2-3-5-2-3-5-2" class="li-num">1.2.3.5.2.3.5.2</a><span class="t-li bullet">?</span>Equivalently, it is "the number of swaps that the bubble sort algorithm would take to place one [ranked] list in the same order as the other [ranked] list."  <a href="https://en.m.wikipedia.org/wiki/Kendall_tau_distance">Wikipedia</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-3-5-3"><a id="t-1-2-3-5-3" name="t-1-2-3-5-3" class="li-num">1.2.3.5.3</a><span class="t-li bullet">?</span>Interestingly, we read the utility functions directly off the brain rather than eliciting rankings through votes so unlike with most social choice / welfare contexts, we don't need to be concerned with strategic manipulation through insincere voting.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-2-4"><a id="t-1-2-4" name="t-1-2-4" class="li-num">1.2.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The advantages of <a href="http://www.metaethical.ai/norm_descriptivism.pdf">this metaethics</a> include:<ul style="display: none;">
<li id="t1-2-4-1"><a id="t-1-2-4-1" name="t-1-2-4-1" class="li-num">1.2.4.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Similar to non-cognitivist theories, it captures the essential connection to motivation in the first-personal case.<ul style="display: none;">
<li id="t1-2-4-1-1"><a id="t-1-2-4-1-1" name="t-1-2-4-1-1" class="li-num">1.2.4.1.1</a><span class="t-li bullet">?</span>If I judge that I have reason to do something, that will tend to cause me to have the motivation to do it.</li>
</ul>
</li>
<li id="t1-2-4-2"><a id="t-1-2-4-2" name="t-1-2-4-2" class="li-num">1.2.4.2</a><span class="t-li bullet">?</span>As a cognitivist, descriptivist theory, it explains how we can reason about what we should do and makes sense of mind-states like questioning or wondering what to do.</li>
<li id="t1-2-4-3"><a id="t-1-2-4-3" name="t-1-2-4-3" class="li-num">1.2.4.3</a><span class="t-li bullet">?</span>The theory focuses on normative deliberation. The third-personal case is understood as shared deliberation or advising rather than simply brow-beating or manipulation.</li>
<li id="t1-2-4-4"><a id="t-1-2-4-4" name="t-1-2-4-4" class="li-num">1.2.4.4</a><span class="t-li bullet">?</span>Like Kantian constructivism, normative authority ultimately derives from the nature of a person's agency. Normative questions are answered by reference to the standards or aims that are constitutive of a person's deliberation. </li>
<li id="t1-2-4-5"><a id="t-1-2-4-5" name="t-1-2-4-5" class="li-num">1.2.4.5</a><span class="t-li bullet">?</span>But as with Humean constructivism, it allows for contingency in what is actually constitutive of a given agent and avoids being saddled by implausible Kantian claims of what is universal to all agents.</li>
<li id="t1-2-4-6"><a id="t-1-2-4-6" name="t-1-2-4-6" class="li-num">1.2.4.6</a><span class="t-li bullet">?</span>Unlike most Humean theories though, it avoids a crude subjectivism by identifying the relevant aims deeper in an agent's cognitive architecture than just their current desires.</li>
<li id="t1-2-4-7"><a id="t-1-2-4-7" name="t-1-2-4-7" class="li-num">1.2.4.7</a><span class="t-li bullet">?</span>It's naturalistic and reductionist, yet still manages to make sense of Moorean open questions as wondering whether the deliberative standards endorse themselves.</li>
<li id="t1-2-4-8"><a id="t-1-2-4-8" name="t-1-2-4-8" class="li-num">1.2.4.8</a><span class="t-li bullet">?</span>It explains and vindicates an a priori normative epistemology that tests principles by use of cases and intuitions. It's analogous to linguists probing an unconscious  black box grammar by use of grammatical intuitions.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-3"><a id="t-1-3" name="t-1-3" class="li-num">1.3</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>Extension: The rational utility function of a brain above is couched in terms of the brain's own represented expressions, but for interpersonal comparisons, we first cash them out extensionally in terms of their referents in the world. <a href="#ext_ruf" class="to-code" title="#ext_ruf">{…}</a><ul>
<li id="t1-3-1"><a id="t-1-3-1" name="t-1-3-1" class="li-num">1.3.1</a><span class="t-li bullet">?</span>Recall our assumption that we are given a causal Markov model of the world.</li>
<li id="t1-3-2"><a id="t-1-3-2" name="t-1-3-2" class="li-num">1.3.2</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>The reference of a brain's represented expression can be defined recursively.<a href="#ref" class="to-code" title="#ref">{…}</a><ul>
<li id="t1-3-2-1"><a id="t-1-3-2-1" name="t-1-3-2-1" class="li-num">1.3.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>An expression's reference will be a set of complete world states.<ul style="display: none;">
<li id="t1-3-2-1-1"><a id="t-1-3-2-1-1" name="t-1-3-2-1-1" class="li-num">1.3.2.1.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>When the expression forms a proposition, that set of world states is the set of truth-makers or truth conditions for the expression.<ul style="display: none;">
<li id="t1-3-2-1-1-1"><a id="t-1-3-2-1-1-1" name="t-1-3-2-1-1-1" class="li-num">1.3.2.1.1.1</a><span class="t-li bullet">?</span>The expression is true if any one of those world states obtains.</li>
<li id="t1-3-2-1-1-2"><a id="t-1-3-2-1-1-2" name="t-1-3-2-1-1-2" class="li-num">1.3.2.1.1.2</a><span class="t-li bullet">?</span>An impossible or necessarily false proposition will refer to the empty set.</li>
<li id="t1-3-2-1-1-3"><a id="t-1-3-2-1-1-3" name="t-1-3-2-1-1-3" class="li-num">1.3.2.1.1.3</a><span class="t-li bullet">?</span>A necessarily true proposition will refer to the set of all world states.</li>
</ul>
</li>
<li id="t1-3-2-1-2"><a id="t-1-3-2-1-2" name="t-1-3-2-1-2" class="li-num">1.3.2.1.2</a><span class="t-li bullet">?</span>When it is treated as an object, the set of world states is the realization conditions for the object.</li>
</ul>
</li>
<li id="t1-3-2-2"><a id="t-1-3-2-2" name="t-1-3-2-2" class="li-num">1.3.2.2</a><span contextmenu="tree-menu" class="t-li arrow down">?</span>The base cases will cover atomic propositions, objects, predicates and relations. <a href="#poss_base_expr_refs" class="to-code" title="#poss_base_expr_refs">{…}</a><ul>
<li id="t1-3-2-2-1"><a id="t-1-3-2-2-1" name="t-1-3-2-2-1" class="li-num">1.3.2.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>As one part of the base cases, an input expression always refers to the implementation of its representation. <a href="#i_ref" class="to-code" title="#i_ref">{…}</a><ul style="display: none;">
<li id="t1-3-2-2-1-1"><a id="t-1-3-2-2-1-1" name="t-1-3-2-2-1-1" class="li-num">1.3.2.2.1.1</a><span class="t-li bullet">?</span>An input expression is the logical expression that gets mapped to an input variable by the probability variable function. <a href="#da-11" class="to-code" title="#da-11">{…}</a></li>
<li id="t1-3-2-2-1-2"><a id="t-1-3-2-2-1-2" name="t-1-3-2-2-1-2" class="li-num">1.3.2.2.1.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Given an implementation function mapping entire brain states to decision states, we can work out a local implementation function mapping local or partial brain events to decision events. <a href="#lf" class="to-code" title="#lf">{…}</a><ul style="display: none;">
<li id="t1-3-2-2-1-2-1"><a id="t-1-3-2-2-1-2-1" name="t-1-3-2-2-1-2-1" class="li-num">1.3.2.2.1.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>From the set of possible functions of that form, we choose the function that ensures these two routes always end up with the same result: <a href="#lf_commutes" class="to-code" title="#lf_commutes">{…}</a><ul style="display: none;">
<li id="t1-3-2-2-1-2-1-1"><a id="t-1-3-2-2-1-2-1-1" name="t-1-3-2-2-1-2-1-1" class="li-num">1.3.2.2.1.2.1.1</a><span class="t-li bullet">?</span>Starting from a brain event, find the decision event it is mapped to and then collect the set of complete decision states it is compatible with.</li>
<li id="t1-3-2-2-1-2-1-2"><a id="t-1-3-2-2-1-2-1-2" name="t-1-3-2-2-1-2-1-2" class="li-num">1.3.2.2.1.2.1.2</a><span class="t-li bullet">?</span>From the same brain event, first collect the set of compatible complete brain states and then collect a set of decision states by finding the decision state the given implementation function maps each such brain state to.</li>
</ul>
</li>
</ul>
</li>
<li id="t1-3-2-2-1-3"><a id="t-1-3-2-2-1-3" name="t-1-3-2-2-1-3" class="li-num">1.3.2.2.1.3</a><span class="t-li bullet">?</span>For a given input decision event, i.e. the assignment of probability to an input variable, the associated input expression refers to the set of world states that include a brain event locally implementing that decision event.</li>
</ul>
</li>
<li id="t1-3-2-2-2"><a id="t-1-3-2-2-2" name="t-1-3-2-2-2" class="li-num">1.3.2.2.2</a><span class="t-li bullet">?</span>The rest of the base cases follow a standard <a href="https://en.wikipedia.org/wiki/First-order_logic#Semantics">first-order structure</a> which defines the mathematical form of the referents of the base expressions. <a href="#poss_base_expr_refs" class="to-code" title="#poss_base_expr_refs">{…}</a></li>
<li id="t1-3-2-2-3"><a id="t-1-3-2-2-3" name="t-1-3-2-2-3" class="li-num">1.3.2.2.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>This leaves open a wide set of possible assignments of referents to base expressions, but we choose from among the set by applying a principle of charity.<ul style="display: none;">
<li id="t1-3-2-2-3-1"><a id="t-1-3-2-2-3-1" name="t-1-3-2-2-3-1" class="li-num">1.3.2.2.3.1</a><span class="t-li bullet">?</span>The base expression reference function chosen is the one that minimizes the squared error (under that interpretation of the base expressions) of all expressions that probability is placed in. <a href="#less_sq_err" class="to-code" title="#less_sq_err">{…}</a></li>
</ul>
</li>
</ul>
</li>
<li id="t1-3-2-3"><a id="t-1-3-2-3" name="t-1-3-2-3" class="li-num">1.3.2.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>In the recursive step, expressions formed from logical or causal connectives applied to subformulas have their reference defined in terms of their subformulas' reference. <a href="#full_ref" class="to-code" title="#full_ref">{…}</a><ul style="display: none;">
<li id="t1-3-2-3-1"><a id="t-1-3-2-3-1" name="t-1-3-2-3-1" class="li-num">1.3.2.3.1</a><span class="t-li bullet">?</span>A disjunction refers to the union of its two subformulas' reference.</li>
<li id="t1-3-2-3-2"><a id="t-1-3-2-3-2" name="t-1-3-2-3-2" class="li-num">1.3.2.3.2</a><span class="t-li bullet">?</span>A negation refers to the complement of its one subformula's reference within the universe of all complete world states.</li>
<li id="t1-3-2-3-3"><a id="t-1-3-2-3-3" name="t-1-3-2-3-3" class="li-num">1.3.2.3.3</a><span class="t-li bullet">?</span>A conjunction refers to the intersection of its two subformulas' reference.</li>
<li id="t1-3-2-3-4"><a id="t-1-3-2-3-4" name="t-1-3-2-3-4" class="li-num">1.3.2.3.4</a><span class="t-li bullet">?</span>An existentially quantified statement refers to all world states that are included in the reference of some version of the statement where some world event has been taken to be the reference of the variable.</li>
<li id="t1-3-2-3-5"><a id="t-1-3-2-3-5" name="t-1-3-2-3-5" class="li-num">1.3.2.3.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Some propositions will be treated as necessary truths or falsehoods.<ul style="display: none;">
<li id="t1-3-2-3-5-1"><a id="t-1-3-2-3-5-1" name="t-1-3-2-3-5-1" class="li-num">1.3.2.3.5.1</a><span class="t-li bullet">?</span>Thus, if true, their reference or truth-conditions will be the set of all complete world states.</li>
<li id="t1-3-2-3-5-2"><a id="t-1-3-2-3-5-2" name="t-1-3-2-3-5-2" class="li-num">1.3.2.3.5.2</a><span class="t-li bullet">?</span>If false, it will be the empty set.</li>
<li id="t1-3-2-3-5-3"><a id="t-1-3-2-3-5-3" name="t-1-3-2-3-5-3" class="li-num">1.3.2.3.5.3</a><span class="t-li bullet">?</span>The necessity is likely best interpreted as nomological, under the laws of nature as assumed in the given causal Markov model of the world.</li>
<li id="t1-3-2-3-5-4"><a id="t-1-3-2-3-5-4" name="t-1-3-2-3-5-4" class="li-num">1.3.2.3.5.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>A subjunctive conditional's truth will be assessed in terms of the causal model of the world and the references of the antecedent and consequent.<ul style="display: none;">
<li id="t1-3-2-3-5-4-1"><a id="t-1-3-2-3-5-4-1" name="t-1-3-2-3-5-4-1" class="li-num">1.3.2.3.5.4.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The antecedent and consequent's reference in terms of sets of complete world states can also be expressed as sets of more local or partial world events by omitting unnecessary variables from the states.<ul style="display: none;">
<li id="t1-3-2-3-5-4-1-1"><a id="t-1-3-2-3-5-4-1-1" name="t-1-3-2-3-5-4-1-1" class="li-num">1.3.2.3.5.4.1.1</a><span class="t-li bullet">?</span>A variable is unneeded when for all complete states in the reference, the states with the values of all the other variables remaining the same but with the candidate variable being assigned true and false are both in the reference.</li>
</ul>
</li>
<li id="t1-3-2-3-5-4-2"><a id="t-1-3-2-3-5-4-2" name="t-1-3-2-3-5-4-2" class="li-num">1.3.2.3.5.4.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>If the antecedent's partial world events reference has multiple events, the subjunctive conditional is true iff a subjunctive conditional with the same consequent and any of those events as the sole member of its antecedent's partial world events reference is true.<ul style="display: none;">
<li id="t1-3-2-3-5-4-2-1"><a id="t-1-3-2-3-5-4-2-1" name="t-1-3-2-3-5-4-2-1" class="li-num">1.3.2.3.5.4.2.1</a><span class="t-li bullet">?</span>This or that causes an effect if this does or that does.</li>
</ul>
</li>
<li id="t1-3-2-3-5-4-3"><a id="t-1-3-2-3-5-4-3" name="t-1-3-2-3-5-4-3" class="li-num">1.3.2.3.5.4.3</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Similarly, if the consequent's partial world events reference has multiple events, the subjunctive conditional is true iff a subjunctive conditional with the same antecedent and any of those events as the sole member of its consequent's partial world events reference is true.<ul style="display: none;">
<li id="t1-3-2-3-5-4-3-1"><a id="t-1-3-2-3-5-4-3-1" name="t-1-3-2-3-5-4-3-1" class="li-num">1.3.2.3.5.4.3.1</a><span class="t-li bullet">?</span>An event causes this or that if it causes this or causes that.</li>
</ul>
</li>
<li id="t1-3-2-3-5-4-4"><a id="t-1-3-2-3-5-4-4" name="t-1-3-2-3-5-4-4" class="li-num">1.3.2.3.5.4.4</a><span class="t-li bullet">?</span>If the antecedent and consequent events reference are both singletons, then the conditional is true iff the consequent's event is the causal response of its variables to the antecedent's event in the world's generated causal model.</li>
</ul>
</li>
<li id="t1-3-2-3-5-5"><a id="t-1-3-2-3-5-5" name="t-1-3-2-3-5-5" class="li-num">1.3.2.3.5.5</a><span class="t-li bullet">?</span>A predication is truth if the reference of the predicate (a set of objects) includes the reference of the predicate's subject (an object / set of world states in which it realized).</li>
<li id="t1-3-2-3-5-6"><a id="t-1-3-2-3-5-6" name="t-1-3-2-3-5-6" class="li-num">1.3.2.3.5.6</a><span class="t-li bullet">?</span>The positing of a relationship is true if the reference of the n-ary relation (a set of n-tuples) includes the n-tuple which collects the references of its arguments.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-3-3"><a id="t-1-3-3" name="t-1-3-3" class="li-num">1.3.3</a><span class="t-li bullet">?</span>An extensional rational utility function ranges over all world states. For each state, it sums the utility assigned by the intensional rational utility function to all expressions that include that state in its reference / truth conditions.</li>
</ul>
</li>
<li id="t1-4"><a id="t-1-4" name="t-1-4" class="li-num">1.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The social welfare function might be thought of as choosing a center of gravity between the extensional rational utility functions.<ul style="display: none;">
<li id="t1-4-1"><a id="t-1-4-1" name="t-1-4-1" class="li-num">1.4.1</a><span class="t-li bullet">?</span>The resulting utility function is chosen from a set of cardinal utility functions ranging over states of the world.</li>
<li id="t1-4-2"><a id="t-1-4-2" name="t-1-4-2" class="li-num">1.4.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>From this set, we choose the one that minimizes the squared distance to the extensional rational utility functions. <a href="#meai_psc_dist" class="to-code" title="#meai_psc_dist">{…}</a><ul style="display: none;">
<li id="t1-4-2-1"><a id="t-1-4-2-1" name="t-1-4-2-1" class="li-num">1.4.2.1</a><span class="t-li bullet">?</span>Squaring the distance allows for prioritarian consideration for farther distances.</li>
<li id="t1-4-2-2"><a id="t-1-4-2-2" name="t-1-4-2-2" class="li-num">1.4.2.2</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>Distances between utility functions are measured as Hausdorff Kendall Tau distances between ordinal utility functions. <a href="#ord_u_dist" class="to-code" title="#ord_u_dist">{…}</a><ul style="display: none;">
<li id="t1-4-2-2-1"><a id="t-1-4-2-2-1" name="t-1-4-2-2-1" class="li-num">1.4.2.2.1</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>To set up the comparison to other utility functions, each cardinal utility function is first translated into an ordinal one by collecting the preference relation for each pair of lotteries. <a href="#card_u_to_ord_u" class="to-code" title="#card_u_to_ord_u">{…}</a><ul style="display: none;">
<li id="t1-4-2-2-1-1"><a id="t-1-4-2-2-1-1" name="t-1-4-2-2-1-1" class="li-num">1.4.2.2.1.1</a><span class="t-li bullet">?</span>A lottery is an assignment of probabilities to states that sum to 1.</li>
<li id="t1-4-2-2-1-2"><a id="t-1-4-2-2-1-2" name="t-1-4-2-2-1-2" class="li-num">1.4.2.2.1.2</a><span class="t-li bullet">?</span>The utility of a lottery is the sum of the utilities of each state multiplied by their respective probabilities.</li>
</ul>
</li>
<li id="t1-4-2-2-2"><a id="t-1-4-2-2-2" name="t-1-4-2-2-2" class="li-num">1.4.2.2.2</a><span class="t-li bullet">?</span>Since Kendall Tau measures distances between strict ordinal rankings, we first associate each utility function with the set of strict ordinal utility functions that are compatible with the strict inequalities in that utility function.</li>
<li id="t1-4-2-2-3"><a id="t-1-4-2-2-3" name="t-1-4-2-2-3" class="li-num">1.4.2.2.3</a><span class="t-li bullet">?</span>The Hausdorff distance between the sets of strict ordinal utility functions measures the "greatest of all the distances from a [utility function] in one set to the closest [utility function] in the other set." <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Wikipedia</a> <a href="#hausdorff_dist" class="to-code" title="#hausdorff_dist">{…}</a></li>
<li id="t1-4-2-2-4"><a id="t-1-4-2-2-4" name="t-1-4-2-2-4" class="li-num">1.4.2.2.4</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The distance between the strict utility functions is the Kendall Tau distance. <a href="#kendalls_tau_dist" class="to-code" title="#kendalls_tau_dist">{…}</a><ul style="display: none;">
<li id="t1-4-2-2-4-1"><a id="t-1-4-2-2-4-1" name="t-1-4-2-2-4-1" class="li-num">1.4.2.2.4.1</a><span class="t-li bullet">?</span>This can be calculated by simply counting the number of pairwise disagreements between the two utility functions.</li>
<li id="t1-4-2-2-4-2"><a id="t-1-4-2-2-4-2" name="t-1-4-2-2-4-2" class="li-num">1.4.2.2.4.2</a><span class="t-li bullet">?</span>Equivalently, it is "the number of swaps that the bubble sort algorithm would take to place one [ranked] list in the same order as the other [ranked] list." <a href="https://en.m.wikipedia.org/wiki/Kendall_tau_distance">Wikipedia</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li id="t1-4-3"><a id="t-1-4-3" name="t-1-4-3" class="li-num">1.4.3</a><span class="t-li bullet">?</span>Interestingly, we compute the rational utility functions from the brain data rather than eliciting rankings through votes so unlike with most social choice / welfare contexts, we don't need to be concerned with strategic manipulation through insincere voting.</li>
</ul>
</li>
<li id="t1-5"><a id="t-1-5" name="t-1-5" class="li-num">1.5</a><span contextmenu="tree-menu" class="t-li arrow right">?</span>The details above form an initial prototype.<ul style="display: none;">
<li id="t1-5-1"><a id="t-1-5-1" name="t-1-5-1" class="li-num">1.5.1</a><span class="t-li bullet">?</span>I suspect that anyone who understands them will also see beyond them and their various simplifying assumptions to appreciate the broader framework unifying these still maturing philosophical theories.</li>
<li id="t1-5-2"><a id="t-1-5-2" name="t-1-5-2" class="li-num">1.5.2</a><span class="t-li bullet">?</span>It is thus, I hope not exactly a ladder to be thrown away as nonsense but nevertheless, a scaffold that is to be superceded.</li>
</ul>
</li>
</ul>
</li>
</ul>

<p style="margin-bottom: 4px; margin-top: 25px;">
	<span id="bib-arrow" style="font-size: 12px; color: #eeee00; cursor: pointer;">&#9654;</span>
	<script type="text/javascript">
		$('#bib-arrow').click(function() {
		  if ($('#bibliography').is(':visible')) { 
				$('#bib-arrow').html('&#9654;').css('font-size', '12px'); 
			} else { 
				$('#bib-arrow').html('&#9660;').css('font-size', '14px'); 
			} 
			$('#bibliography').toggle();
		});
	</script>
	<span style="color: #ffaaff; font-family: 'PT Sans Caption', sans-serif;"
>Select Bibliography</span>
</p>

<ul id="bibliography" style="list-style-type: disc; display: none; padding-left: 28px;">
  <li>Block, Ned. <a target="_BLANK" href="https://aardvark.ucsd.edu/mind/block_advertisement.pdf">Advertisement for a Semantics for Psychology.</a> <i>Midwest Studies in Philosophy</i> 10 (1986): 615-678.</li>
  <li>Chalmers, David J. <a target="_BLANK" href="http://consc.net/papers/rock.html">Does a Rock Implement Every Finite-State Automaton?</a> <i>Synthese</i> 108.3 (1996): 309-333.</li>
  <li>Dennett, Daniel C. <a target="_BLANK" href="https://www.cs.tufts.edu/comp/150AAA/DennettTrueBelievers.pdf">True Believers: The Intentional Strategy and Why It Works</a>. (1981).</li>
  <li>Galles, David, and Judea Pearl. <a target="_BLANK" href="https://ftp.cs.ucla.edu/pub/stat_ser/R250.pdf">An Axiomatic Characterization of Causal Counterfactuals</a>. <i>Foundations of Science</i> 3.1 (1998): 151-182.</li>
  <li>Halpern, Joseph Y., and Judea Pearl. <a target="_BLANK" href="http://ftp.cs.ucla.edu/pub/stat_ser/R266-part1.pdf">Causes and Explanations: A Structural-Model Approach. Part I: Causes</a>. <i>The British Journal for the Philosophy of Science</i> (2020).</li>
  <li>Lewis, David. <a target="_BLANK" href="https://www.princeton.edu/~hhalvors/teaching/phi520_f2012/lewis-theoretical-terms.pdf">How to Define Theoretical Terms</a>. <i>The Journal of Philosophy</i> 67.13 (1970): 427-446.</li>
  <li>Newberry, Toby and Ord, Toby. <a target="_BLANK" href="https://www.fhi.ox.ac.uk/wp-content/uploads/2021/06/Parliamentary-Approach-to-Moral-Uncertainty.pdf">The Parliamentary Approach to Moral Uncertainty</a>, Technical Report #2021-2, Future of Humanity Institute, University of Oxford 2021.</li>
  <li>Nye, Howard and Ku, June. <a target="_BLANK" href="/norm_descriptivism.pdf">Norm Descriptivism</a></li>
  <li>Parfit, Derek. <i>Reasons and Persons</i>. OUP Oxford, 1984.</li>
  <li>Staffel, Julia. <a target="_BLANK" href="https://link.springer.com/article/10.1007/s11229-014-0640-x">Measuring the Overall Incoherence of Credence Functions</a>. <i>Synthese</i> 192.5 (2015): 1467-1493.</li>
  <li>Street, Sharon. <a target="_BLANK" href="https://compass.onlinelibrary.wiley.com/doi/abs/10.1111/j.1747-9991.2009.00280.x">What is Constructivism in Ethics and Metaethics?</a>. <i>Philosophy Compass</i> 5.5 (2010): 363-384.</li>
  <li>Vitanyi, Paul MB, and Ming Li. <a target="_BLANK" href="https://arxiv.org/pdf/cs/9901014.pdf">Minimum Description Length Induction, Bayesianism, and Kolmogorov complexity</a>. <i>IEEE Transactions on Information Theory</i> 46.2 (2000): 446-464.</li>
	<li>Yudkowsky, Eliezer. <a target="_BLANK" href="https://intelligence.org/files/CEV.pdf">Coherent Extrapolated Volition</a> (2004).</li>
</ul>

</div>
<pre class="vimCodeElement" id="main"><span id="L1" class="LineNr"> 1 </span><span class="Comment Heading">/* MetaEthical.AI</span>
<span id="L2" class="LineNr"> 2 </span><span class="Comment Heading">   ==============</span>
<span id="L3" class="LineNr"> 3 </span><span class="Comment">   Read the Introduction at:</span>
<span id="L4" class="LineNr"> 4 </span><span class="Comment">   <a href="https://medium.com/@june_ku/formal-metaethics-and-metasemantics-for-ai-alignment-2e72533cad6d" target="_blank">https://medium.com/@june_ku/formal-metaethics-and-metasemantics-for-ai-alignment-2e72533cad6d</a></span>
<span id="L5" class="LineNr"> 5 </span>
<span id="L6" class="LineNr"> 6 </span><span class="Comment">   Developed by June Ku in the set theoretic programming language setlX v2.2.0</span>
<span id="L7" class="LineNr"> 7 </span><span class="Comment">   and interspersed with considerable non-technical philosophical commentary.</span>
<span id="L8" class="LineNr"> 8 </span><span class="Comment">     <a href="https://randoom.org/Software/SetlX/" target="_blank">https://randoom.org/Software/SetlX/</a> </span>
<span id="L9" class="LineNr"> 9 </span><span class="Comment">     <a href="https://download.randoom.org/setlX/pc/archive/setlX_v2-2-0.binary_only.zip" target="_blank">https://download.randoom.org/setlX/pc/archive/setlX_v2-2-0.binary_only.zip</a></span>
<span id="L10" class="LineNr">10 </span><span class="Comment">       - contains among other things, <a href="/images/setlX_v2-2-0_tutorial.pdf" target="_blank">tutorial.pdf</a> introduction and reference</span>
<span id="L11" class="LineNr">11 </span>
<span id="L12" class="LineNr">12 </span><span class="Comment">   I am very grateful to Howard Nye for our work together on metaethics as well </span>
<span id="L13" class="LineNr">13 </span><span class="Comment">   as many helpful comments and conversations during much of this development.</span>
<span id="L14" class="LineNr">14 </span><span class="Comment">   I also appreciate helpful discussions with Mahendra Prasad, Jessica Taylor, </span>
<span id="L15" class="LineNr">15 </span><span class="Comment">   Anna Salamon and Nate Soares.</span>
<span id="L16" class="LineNr">16 </span><span class="Comment">*/</span>
<span id="L17" class="LineNr">17 </span><span class="Identifier">load</span>(<span class="Constant">'lib.stlx'</span>);
<span id="L18" class="LineNr">18 </span><span class="Identifier">load</span>(<span class="Constant">'causal_model.stlx'</span>);
<span id="L19" class="LineNr">19 </span><span class="Identifier">load</span>(<span class="Constant">'causal_markov_model.stlx'</span>);
<span id="L20" class="LineNr">20 </span><span class="Identifier">load</span>(<span class="Constant">'decision_algorithm.stlx'</span>);
<span id="L21" class="LineNr">21 </span>
<span id="L22" class="LineNr">22 </span><span class="Comment Heading">/* MetaEthical.AI Utility Function</span>
<span id="L23" class="LineNr">23 </span><span class="Comment Heading">   ===============================</span>
<span id="L24" class="LineNr">24 </span><span class="Comment">   Takes a causal markov model of the world w and set of brains bs in w and </span>
<span id="L25" class="LineNr">25 </span><span class="Comment">   returns a metaethical.ai utility function. </span>
<span id="L26" class="LineNr">26 </span>
<span id="L27" class="LineNr">27 </span><span class="Comment">   Abstract: We construct a fully technical ethical goal function for AI by </span>
<span id="L28" class="LineNr">28 </span><span class="Comment">   directly tackling the philosophical problems of metaethics and mental </span>
<span id="L29" class="LineNr">29 </span><span class="Comment">   content. To simplify our reduction of these philosophical challenges into </span>
<span id="L30" class="LineNr">30 </span><span class="Comment">   "merely" engineering ones, we suppose that unlimited computation and a </span>
<span id="L31" class="LineNr">31 </span><span class="Comment">   complete low-level causal model of the world and the adult human brains in </span>
<span id="L32" class="LineNr">32 </span><span class="Comment">   it are available.</span>
<span id="L33" class="LineNr">33 </span>
<span id="L34" class="LineNr">34 </span><span class="Comment">   Given such a model, the AI attributes beliefs and values to a brain in two </span>
<span id="L35" class="LineNr">35 </span><span class="Comment">   stages. First, it identifies the syntax of a brain’s mental content by </span>
<span id="L36" class="LineNr">36 </span><span class="Comment">   selecting a decision algorithm which is i) isomorphic to the brain’s causal </span>
<span id="L37" class="LineNr">37 </span><span class="Comment">   processes and ii) best compresses its behavior while iii) maximizing charity.</span>
<span id="L38" class="LineNr">38 </span><span class="Comment">   The semantics of that content then consists first in sense data that </span>
<span id="L39" class="LineNr">39 </span><span class="Comment">   primitively refer to their own occurrence and then in logical and causal </span>
<span id="L40" class="LineNr">40 </span><span class="Comment">   structural combinations of such content.</span>
<span id="L41" class="LineNr">41 </span>
<span id="L42" class="LineNr">42 </span><span class="Comment">   The resulting decision algorithm can capture how we decide what to *do*, but </span>
<span id="L43" class="LineNr">43 </span><span class="Comment">   it can also identify the ethical factors that we seek to determine when we </span>
<span id="L44" class="LineNr">44 </span><span class="Comment">   decide what to *value* or even how to *decide*. Unfolding the implications </span>
<span id="L45" class="LineNr">45 </span><span class="Comment">   of those factors, we arrive at what we should do. All together, this allows </span>
<span id="L46" class="LineNr">46 </span><span class="Comment">   us to imbue the AI with the necessary concepts to determine and do what we </span>
<span id="L47" class="LineNr">47 </span><span class="Comment">   should want it to do.  </span>
<span id="L48" class="LineNr">48 </span><span class="Comment">*/</span>
<span id="L49" class="LineNr">49 <a title="1" class="back_to_li" href="#t-1"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">metaethical_ai_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, bs) {
<span id="L50" class="LineNr">50 </span>  <span class="Comment">/* Given a set of brain models, associate them with the decision algorithms</span>
<span id="L51" class="LineNr">51 </span><span class="Comment">     they implement.  */</span>
<span id="L52" class="LineNr">52 </span>  d <span class="Statement">:=</span> { [b, decision_algorithm.<a class="Identifier code-proc-link" href="#da-2277">implemented_by</a>(b, {})] <span class="Type">:</span> b <span class="Type">in</span> bs };
<span id="L53" class="LineNr">53 </span>  <span class="Comment">/* Then map each brain to its rational self's values (understood extensionally</span>
<span id="L54" class="LineNr">54 </span><span class="Comment">     i.e. cashing out the meaning of their mental concepts in terms of the </span>
<span id="L55" class="LineNr">55 </span><span class="Comment">     world events they refer to).  */</span>
<span id="L56" class="LineNr">56 </span>  ext_rufs <span class="Statement">:=</span> { [b, d[b].<a class="Identifier code-proc-link" href="#da-1866">ext_ruf</a>(w,b)] <span class="Type">:</span> b <span class="Type">in</span> bs };
<span id="L57" class="LineNr">57 </span>
<span id="L58" class="LineNr">58 </span>  state_space <span class="Statement">:=</span> w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>();
<span id="L59" class="LineNr">59 </span>  b <span class="Statement">:=</span> <span class="Identifier">first</span>(bs);
<span id="L60" class="LineNr">60 </span>  probs <span class="Statement">:=</span> b.r[<span class="Identifier">first</span>(b.p)];
<span id="L61" class="LineNr">61 </span>  <span class="Comment">// Possible social choice utility functions</span>
<span id="L62" class="LineNr">62 </span>  psc_us <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {[state, r_i] <span class="Type">:</span> r_i <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>state_space] }
<span id="L63" class="LineNr">63 </span>                      <span class="Type">:</span> state <span class="Type">in</span> state_space });
<span id="L64" class="LineNr">64 </span>  sc_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(psc_us, <span class="Type">procedure</span>(psc_u1, psc_u2) {
<span id="L65" class="LineNr">65 </span>                    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#m-71">meai_psc_dist</a>(psc_u1, ext_rufs, state_space, probs) <span class="Type">&lt;</span>
<span id="L66" class="LineNr">66 </span>                           <span class="Identifier">meai_psc_dist</span>(psc_u2, ext_rufs, state_space, probs);
<span id="L67" class="LineNr">67 </span>                   })[<span class="Constant">1</span>];
<span id="L68" class="LineNr">68 </span>  <span class="Statement">return</span> sc_u;
<span id="L69" class="LineNr">69 </span>};
<span id="L70" class="LineNr">70 </span>
<span id="L71" class="LineNr">71 <a title="1.4.2" class="back_to_li" href="#t-1-4-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">meai_psc_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(psc_u, ext_rufs, state_space, probs) {
<span id="L72" class="LineNr">72 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-674">ord_u_dist</a>(<a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>(ext_ruf, state_space, probs),
<span id="L73" class="LineNr">73 </span>                           <span class="Identifier">card_u_to_ord_u</span>(psc_u,   state_space, probs) ) <span class="Type">**</span> <span class="Constant">2</span>
<span id="L74" class="LineNr">74 </span>                <span class="Type">:</span> ext_ruf <span class="Type">in</span> ext_rufs };
<span id="L75" class="LineNr">75 </span>  };
<span id="L76" class="LineNr">76 </span>
<span id="L77" class="LineNr">77 </span><span class="Comment Heading">/* MIT License</span>
<span id="L78" class="LineNr">78 </span><span class="Comment Heading">   -----------</span>
<span id="L79" class="LineNr">79 </span><span class="Comment">   Copyright 2019 June Ku </span>
<span id="L80" class="LineNr">80 </span>
<span id="L81" class="LineNr">81 </span><span class="Comment">   Permission is hereby granted, free of charge, to any person obtaining a copy </span>
<span id="L82" class="LineNr">82 </span><span class="Comment">   of this software and associated documentation files (the "Software"), to deal</span>
<span id="L83" class="LineNr">83 </span><span class="Comment">   in the Software without restriction, including without limitation the rights </span>
<span id="L84" class="LineNr">84 </span><span class="Comment">   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell </span>
<span id="L85" class="LineNr">85 </span><span class="Comment">   copies of the Software, and to permit persons to whom the Software is </span>
<span id="L86" class="LineNr">86 </span><span class="Comment">   furnished to do so, subject to the following conditions:</span>
<span id="L87" class="LineNr">87 </span>
<span id="L88" class="LineNr">88 </span><span class="Comment">   The above copyright notice and this permission notice shall be included in </span>
<span id="L89" class="LineNr">89 </span><span class="Comment">   all copies or substantial portions of the Software.</span>
<span id="L90" class="LineNr">90 </span>
<span id="L91" class="LineNr">91 </span><span class="Comment">   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR </span>
<span id="L92" class="LineNr">92 </span><span class="Comment">   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, </span>
<span id="L93" class="LineNr">93 </span><span class="Comment">   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE </span>
<span id="L94" class="LineNr">94 </span><span class="Comment">   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER </span>
<span id="L95" class="LineNr">95 </span><span class="Comment">   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING </span>
<span id="L96" class="LineNr">96 </span><span class="Comment">   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS </span>
<span id="L97" class="LineNr">97 </span><span class="Comment">   IN THE SOFTWARE.</span>
<span id="L98" class="LineNr">98 </span><span class="Comment">*/</span>
</pre>
<pre class="vimCodeElement" id="decision_algorithm"><span id="L1" class="LineNr">   1 <a title="1.2.1.1" class="back_to_li" href="#t-1-2-1-1"><i class="fas fa-list-ol"></i></a></span><span class="Type">class</span> <span class="Identifier">decision_algorithm</span>(i, o, p, cp, u, m, m2, n, r, t_s, t_o,
<span id="L2" class="LineNr">   2 </span>                         cached_f, cached_lf, cached_ref) {
<span id="L3" class="LineNr">   3 </span><span class="Comment Heading">// Definition and Structure of Decision Algorithms </span>
<span id="L4" class="LineNr">   4 </span><span class="Comment Heading">// ===============================================</span>
<span id="L5" class="LineNr">   5 </span>
<span id="L6" class="LineNr">   6 <a title="1.2.1.1.1" class="back_to_li" href="#t-1-2-1-1-1"><i class="fas fa-list-ol"></i></a></span>  i <span class="Statement">:=</span> i; <span class="Comment">/* Set of input variables (or technically names, ie strings)</span>
<span id="L7" class="LineNr">   7 </span><span class="Comment">               which are a subset of range(p)</span>
<span id="L8" class="LineNr">   8 </span><span class="Comment">             e.g. { 'P(I_1)', 'P(I_2)', 'P(I_3)' } </span>
<span id="L9" class="LineNr">   9 </span><span class="Comment">             i.e. the agent's sense data. </span>
<span id="L10" class="LineNr">  10 </span><span class="Comment">             Generally, p should include it, e.g. { ['I_1', 'P(I_1)'], ... }</span>
<span id="L11" class="LineNr">  11 <a title="1.3.2.2.1.1" class="back_to_li" href="#t-1-3-2-2-1-1"><i class="fas fa-list-ol"></i></a></span><span class="Comment">  Technical footnote: There's some abuse of notation here. Each string like </span>
<span id="L12" class="LineNr">  12 </span><span class="Comment">  'I_1' can depending on context be treated as:</span>
<span id="L13" class="LineNr">  13 </span><span class="Comment">    i) an individual constant term / object. A predicate expression in the </span>
<span id="L14" class="LineNr">  14 </span><span class="Comment">       domain of p that has this string as an argument would be the </span>
<span id="L15" class="LineNr">  15 </span><span class="Comment">       prototypical context illustrating this usage. Semantically, these would </span>
<span id="L16" class="LineNr">  16 </span><span class="Comment">       refer to the brain events that implement them.  </span>
<span id="L17" class="LineNr">  17 </span><span class="Comment">    ii) a couple possibilities for this option: </span>
<span id="L18" class="LineNr">  18 </span><span class="Comment">      a) a 0-ary predicate or sentential expression. It takes no inputs and </span>
<span id="L19" class="LineNr">  19 </span><span class="Comment">         forms a proposition on its own. </span>
<span id="L20" class="LineNr">  20 </span><span class="Comment">      b) shorthand for a 1-place predicate that takes the constant in ii and </span>
<span id="L21" class="LineNr">  21 </span><span class="Comment">         simply asserts its existence, perhaps loosely inspired by Free Logic's</span>
<span id="L22" class="LineNr">  22 </span><span class="Comment">         E!. </span>
<span id="L23" class="LineNr">  23 </span><span class="Comment">      In either case, its truth-maker/referent would be the same as option i's.</span>
<span id="L24" class="LineNr">  24 </span><span class="Comment">      Treating the string as a sentential expression or forming an expression </span>
<span id="L25" class="LineNr">  25 </span><span class="Comment">      with it as the argument of a connective would indicate this usage.  </span>
<span id="L26" class="LineNr">  26 </span><span class="Comment">    All of these possibilities are expressions, or terms that could figure in an</span>
<span id="L27" class="LineNr">  27 </span><span class="Comment">    expression, i.e. the sort of thing that would be in the domain of p. They </span>
<span id="L28" class="LineNr">  28 </span><span class="Comment">    should be distinguished from the set i, which would be a subset of the range</span>
<span id="L29" class="LineNr">  29 </span><span class="Comment">    of p. These would be names of a decision algorithm variable, e.g. parents() </span>
<span id="L30" class="LineNr">  30 </span><span class="Comment">    of other variables. Assignments of value to this variable would be a </span>
<span id="L31" class="LineNr">  31 </span><span class="Comment">    subjective probability 0-1. That would form a local/partial decision state,</span>
<span id="L32" class="LineNr">  32 </span><span class="Comment">    which could get mapped to by a local/partial implementation functor lf() </span>
<span id="L33" class="LineNr">  33 </span><span class="Comment">    from a local brain state.  */</span>
<span id="L34" class="LineNr">  34 </span>
<span id="L35" class="LineNr">  35 <a title="1.2.1.1.2" class="back_to_li" href="#t-1-2-1-1-2"><i class="fas fa-list-ol"></i></a></span>  o <span class="Statement">:=</span> o; <span class="Comment">/* Set of output variables</span>
<span id="L36" class="LineNr">  36 </span><span class="Comment">             e.g. { 'O_1', 'O_2', 'O_3' }</span>
<span id="L37" class="LineNr">  37 </span><span class="Comment">             i.e. the agent's motor output. </span>
<span id="L38" class="LineNr">  38 </span><span class="Comment">             See also the technical note for i.  */</span>
<span id="L39" class="LineNr">  39 </span>
<span id="L40" class="LineNr">  40 </span>  <span class="Comment">/* Function from logical formulas (setlx functors/strings/terms) to </span>
<span id="L41" class="LineNr">  41 </span><span class="Comment">       probability variables</span>
<span id="L42" class="LineNr">  42 </span><span class="Comment">     e.g. { ['A', 'P(A)'], ['B', 'P(B)'], [And('A', 'B'), 'P(A &amp; B)'], </span>
<span id="L43" class="LineNr">  43 <a title="1.2.1.4.1" class="back_to_li" href="#t-1-2-1-4-1"><i class="fas fa-list-ol"></i></a></span><span class="Comment">            [BoxArrow('A', 'B'), 'P(A []-&gt; B)'] }  */</span>
<span id="L44" class="LineNr">  44 <a title="1.2.1.1.3" class="back_to_li" href="#t-1-2-1-1-3"><i class="fas fa-list-ol"></i></a></span>  p <span class="Statement">:=</span> p;
<span id="L45" class="LineNr">  45 </span>
<span id="L46" class="LineNr">  46 </span>  <span class="Comment">/* Function from ordered pairs [x, y] to conditional probability variables</span>
<span id="L47" class="LineNr">  47 </span><span class="Comment">     e.g. { [[x, y], 'P(x|y)'], ... } </span>
<span id="L48" class="LineNr">  48 </span><span class="Comment">     or more concretely: { [['C', And('A', 'B')], 'P(C|A,B)'], ... }  */</span>
<span id="L49" class="LineNr">  49 <a title="1.2.1.1.4" class="back_to_li" href="#t-1-2-1-1-4"><i class="fas fa-list-ol"></i></a></span>  cp <span class="Statement">:=</span> cp;
<span id="L50" class="LineNr">  50 </span>
<span id="L51" class="LineNr">  51 </span>  <span class="Comment">/* Function from logical formulas to utility variables </span>
<span id="L52" class="LineNr">  52 </span><span class="Comment">       e.g. { ['A', 'U(A)'], ... } </span>
<span id="L53" class="LineNr">  53 </span><span class="Comment">     u has the same structure as p above.</span>
<span id="L54" class="LineNr">  54 </span><span class="Comment">     See also accepted norms / higher-order utilities a few lines below. */</span>
<span id="L55" class="LineNr">  55 <a title="1.2.1.1.5" class="back_to_li" href="#t-1-2-1-1-5"><i class="fas fa-list-ol"></i></a></span>  u <span class="Statement">:=</span> u;
<span id="L56" class="LineNr">  56 </span>
<span id="L57" class="LineNr">  57 </span>  <span class="Comment">/* Set of memory variables </span>
<span id="L58" class="LineNr">  58 </span><span class="Comment">     This is a catch-all for other cognitive states that don't fit into the </span>
<span id="L59" class="LineNr">  59 </span><span class="Comment">     other sets of variables yet may be important to model, e.g. intermediate </span>
<span id="L60" class="LineNr">  60 </span><span class="Comment">     states in a calculation performing inference or decision. One can think of</span>
<span id="L61" class="LineNr">  61 </span><span class="Comment">     it as roughly analogous to a computer's RAM.  */</span>
<span id="L62" class="LineNr">  62 <a title="1.2.1.1.6" class="back_to_li" href="#t-1-2-1-1-6"><i class="fas fa-list-ol"></i></a></span>  m <span class="Statement">:=</span> m;
<span id="L63" class="LineNr">  63 </span>
<span id="L64" class="LineNr">  64 </span>  <span class="Comment">/* Set of memory variables for t_o </span>
<span id="L65" class="LineNr">  65 </span><span class="Comment">     Same idea as m above but these only mediate between p + cp + u and o. </span>
<span id="L66" class="LineNr">  66 </span><span class="Comment">     This helps ensure it is a genuinely decision algorithmic explanation.  */</span>
<span id="L67" class="LineNr">  67 <a title="1.2.1.1.7" class="back_to_li" href="#t-1-2-1-1-7"><i class="fas fa-list-ol"></i></a></span>  m2 <span class="Statement">:=</span> m2;
<span id="L68" class="LineNr">  68 </span>
<span id="L69" class="LineNr">  69 <a title="1.2.1.1.8" class="back_to_li" href="#t-1-2-1-1-8"><i class="fas fa-list-ol"></i></a></span>  <span class="Comment">/* List of accepted norms / higher-order utilities</span>
<span id="L70" class="LineNr">  70 </span><span class="Comment">     [ n_1, n_2, ... ]</span>
<span id="L71" class="LineNr">  71 </span><span class="Comment">     each n_i == { ['e', e_n_i], ['m2', m2_n_i], ['o', o_n_i] }</span>
<span id="L72" class="LineNr">  72 <a title="1.2.1.1.8.1.1" class="back_to_li" href="#t-1-2-1-1-8-1-1"><i class="fas fa-list-ol"></i></a></span><span class="Comment">       e_n_i is a function from logical formulas to evaluation variables</span>
<span id="L73" class="LineNr">  73 </span><span class="Comment">         e.g. { ['A', 'E_n_i(A)'], ... }</span>
<span id="L74" class="LineNr">  74 </span><span class="Comment">         They are basically utility function variables but since they are</span>
<span id="L75" class="LineNr">  75 </span><span class="Comment">         higher-order, i.e. they influence normative judgments or prescriptions</span>
<span id="L76" class="LineNr">  76 </span><span class="Comment">         rather than motor output, we call them evaluation variables instead</span>
<span id="L77" class="LineNr">  77 </span><span class="Comment">         when we want to emphasize that they don't directly govern action.</span>
<span id="L78" class="LineNr">  78 <a title="1.2.1.1.8.1.2" class="back_to_li" href="#t-1-2-1-1-8-1-2"><i class="fas fa-list-ol"></i></a></span><span class="Comment">       m2_n_i is a set of memory variables that only moderate p + e_n_i to </span>
<span id="L79" class="LineNr">  79 </span><span class="Comment">         o_n_i</span>
<span id="L80" class="LineNr">  80 <a title="1.2.1.1.8.1.3" class="back_to_li" href="#t-1-2-1-1-8-1-3"><i class="fas fa-list-ol"></i></a></span><span class="Comment">       o_n_i is a set of output variables that causally influence various u or</span>
<span id="L81" class="LineNr">  81 </span><span class="Comment">         e_n_j. In simplified models, we can make o_n_i trivially cause u or </span>
<span id="L82" class="LineNr">  82 </span><span class="Comment">         e_n_i states by just being identical to them </span>
<span id="L83" class="LineNr">  83 </span>
<span id="L84" class="LineNr">  84 </span><span class="Comment">     These are essentially decision criteria that govern how we change our</span>
<span id="L85" class="LineNr">  85 </span><span class="Comment">     preferences or other higher-order norms. The way in which they govern is </span>
<span id="L86" class="LineNr">  86 </span><span class="Comment">     analogous and mathematically isomorphic to how first-order utility </span>
<span id="L87" class="LineNr">  87 </span><span class="Comment">     functions or preferences govern action. There, beliefs that some motor</span>
<span id="L88" class="LineNr">  88 </span><span class="Comment">     output would cause some preferred state to be achieved will tend to cause</span>
<span id="L89" class="LineNr">  89 </span><span class="Comment">     such output and therefore the desired state. In the case of these accepted</span>
<span id="L90" class="LineNr">  90 </span><span class="Comment">     norms, beliefs that the output variables (which we can also understand as </span>
<span id="L91" class="LineNr">  91 </span><span class="Comment">     normative judgments or prescriptions) will cause or constitute a change </span>
<span id="L92" class="LineNr">  92 </span><span class="Comment">     in values (which is what the exprs of the domain of e_n_i would refer to) </span>
<span id="L93" class="LineNr">  93 </span><span class="Comment">     will tend to cause such outputs and therefore changes in value. </span>
<span id="L94" class="LineNr">  94 </span>
<span id="L95" class="LineNr">  95 </span><span class="Comment">     It is very important to note that what makes these preferences / utilities </span>
<span id="L96" class="LineNr">  96 </span><span class="Comment">     higher-order is their causal or functional roles and not the content of </span>
<span id="L97" class="LineNr">  97 </span><span class="Comment">     the expressions associated with the evaluation variables. One can have, in </span>
<span id="L98" class="LineNr">  98 </span><span class="Comment">     our sense, first-order preferences which prefer states involving other</span>
<span id="L99" class="LineNr">  99 </span><span class="Comment">     preferences. Those might be referentially "higher-order" in some sense but </span>
<span id="L100" class="LineNr"> 100 </span><span class="Comment">     they would still be first-order in our sense so long as they govern</span>
<span id="L101" class="LineNr"> 101 </span><span class="Comment">     actions rather than normative judgments or prescriptions.</span>
<span id="L102" class="LineNr"> 102 </span>
<span id="L103" class="LineNr"> 103 </span><span class="Comment">     See <a href="http://www.metaethical.ai/norm_descriptivism.pdf" target="_blank">http://www.metaethical.ai/norm_descriptivism.pdf</a> for more.</span>
<span id="L104" class="LineNr"> 104 </span>
<span id="L105" class="LineNr"> 105 </span><span class="Comment">     One might object that introducing these higher-order utility functions</span>
<span id="L106" class="LineNr"> 106 </span><span class="Comment">     invalidates what was supposed to be the utility function of the decision</span>
<span id="L107" class="LineNr"> 107 </span><span class="Comment">     algorithm. Since a utility function is supposed to encompass any factors   </span>
<span id="L108" class="LineNr"> 108 </span><span class="Comment">     explaining behavior, wouldn't it already include these allegedly</span>
<span id="L109" class="LineNr"> 109 </span><span class="Comment">     higher-order factors? Strictly speaking, that may be correct, but that kind</span>
<span id="L110" class="LineNr"> 110 </span><span class="Comment">     of utility function is not the most useful for our purposes.</span>
<span id="L111" class="LineNr"> 111 </span><span class="Comment">     </span>
<span id="L112" class="LineNr"> 112 </span><span class="Comment">     It may be better to think in terms of modeling a decision algorithm as a</span>
<span id="L113" class="LineNr"> 113 </span><span class="Comment">     society of subagents. The first-order utility function then is the utility</span>
<span id="L114" class="LineNr"> 114 </span><span class="Comment">     function of the subagent whose outputs are the decision algorithm's actions</span>
<span id="L115" class="LineNr"> 115 </span><span class="Comment">     rather than prescriptions that directly influence other subagents' </span>
<span id="L116" class="LineNr"> 116 </span><span class="Comment">     utilities. When we speak of the utility function of the decision algorithm,</span>
<span id="L117" class="LineNr"> 117 </span><span class="Comment">     this should just be understood as shorthand for this first-order utility </span>
<span id="L118" class="LineNr"> 118 </span><span class="Comment">     function.</span>
<span id="L119" class="LineNr"> 119 </span><span class="Comment">  */</span>
<span id="L120" class="LineNr"> 120 </span>  n <span class="Statement">:=</span> n;
<span id="L121" class="LineNr"> 121 </span>
<span id="L122" class="LineNr"> 122 </span>  <span class="Comment">// Internal states</span>
<span id="L123" class="LineNr"><a href="#tda-4" data-file="test_decision_algorithm" title="test_s" class="checkmark">&#10004;</a> 123 <a title="1.2.1.1.10.2" class="back_to_li" href="#t-1-2-1-1-10-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">s</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L124" class="LineNr"> 124 </span>    <span class="Statement">if</span> (n <span class="Type">==</span> {} <span class="Type">||</span> n <span class="Type">==</span> [] <span class="Type">||</span> n <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L125" class="LineNr"> 125 </span>      n_vs <span class="Statement">:=</span> {};
<span id="L126" class="LineNr"> 126 </span>    } <span class="Statement">else</span> {
<span id="L127" class="LineNr"> 127 </span>      n_vs <span class="Statement">:=</span> <span class="Type">+/</span> { <span class="Identifier">range</span>(n_i[<span class="Constant">'e'</span>]) <span class="Type">+</span> n_i[<span class="Constant">'m2'</span>] <span class="Type">+</span> n_i[<span class="Constant">'o'</span>] <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L128" class="LineNr"> 128 </span>    }
<span id="L129" class="LineNr"> 129 </span>    <span class="Statement">return</span> <span class="Identifier">range</span>(p) <span class="Type">+</span> <span class="Identifier">range</span>(cp) <span class="Type">+</span> <span class="Identifier">range</span>(u) <span class="Type">+</span> m <span class="Type">+</span> m2 <span class="Type">+</span> n_vs <span class="Type">-</span> i;
<span id="L130" class="LineNr"> 130 </span>  };
<span id="L131" class="LineNr"> 131 </span>
<span id="L132" class="LineNr"> 132 </span>  <span class="Comment">// Function from i + s() + o to ranges of values for those variables</span>
<span id="L133" class="LineNr"> 133 <a title="1.2.1.1.9" class="back_to_li" href="#t-1-2-1-1-9"><i class="fas fa-list-ol"></i></a></span>  r <span class="Statement">:=</span> r;
<span id="L134" class="LineNr"> 134 </span>
<span id="L135" class="LineNr"> 135 </span>  <span class="Comment">/* Higher order function from a function assigning values to all input and </span>
<span id="L136" class="LineNr"> 136 </span><span class="Comment">     internal states to a function assigning values to all next internal states </span>
<span id="L137" class="LineNr"> 137 </span><span class="Comment">       is -&gt; s</span>
<span id="L138" class="LineNr"> 138 </span><span class="Comment">  */</span>
<span id="L139" class="LineNr"> 139 <a title="1.2.1.1.10" class="back_to_li" href="#t-1-2-1-1-10"><i class="fas fa-list-ol"></i></a></span>  t_s <span class="Statement">:=</span> t_s;
<span id="L140" class="LineNr"> 140 </span>
<span id="L141" class="LineNr"> 141 </span>  <span class="Comment">/* Higher order function from a function assigning values to all probability </span>
<span id="L142" class="LineNr"> 142 </span><span class="Comment">     and utility variables as well as m2 to a function assigning values to </span>
<span id="L143" class="LineNr"> 143 </span><span class="Comment">     outputs </span>
<span id="L144" class="LineNr"> 144 </span><span class="Comment">       p u m2 -&gt; o</span>
<span id="L145" class="LineNr"> 145 </span><span class="Comment">  */</span>
<span id="L146" class="LineNr"> 146 <a title="1.2.1.1.11" class="back_to_li" href="#t-1-2-1-1-11"><i class="fas fa-list-ol"></i></a></span>  t_o <span class="Statement">:=</span> t_o;
<span id="L147" class="LineNr"> 147 </span>
<span id="L148" class="LineNr"> 148 </span>  <span class="Comment">/* State transitions</span>
<span id="L149" class="LineNr"> 149 </span><span class="Comment">     Returns a higher-order function from functions assigning values to i + s </span>
<span id="L150" class="LineNr"> 150 </span><span class="Comment">     to functions assigning values to s + o. This is the intuitive combination</span>
<span id="L151" class="LineNr"> 151 </span><span class="Comment">     of t_s and t_o. */</span>
<span id="L152" class="LineNr"><a href="#tda-16" data-file="test_decision_algorithm" title="test_t" class="checkmark">&#10004;</a> 152 </span>  <span class="Identifier">t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L153" class="LineNr"> 153 </span>    <span class="Statement">return</span> { [    <span class="Comment">// a higher-order function which takes </span>
<span id="L154" class="LineNr"> 154 </span>              is, <span class="Comment">// a function assigning values to i + s and returns a function</span>
<span id="L155" class="LineNr"> 155 </span>              t_s[is] <span class="Type">+</span> t_o[<a class="Identifier code-proc-link" href="#da-188">just_p_u_m2</a>(is)]
<span id="L156" class="LineNr"> 156 </span>                  <span class="Comment">// composed of the union of a func assigning values to s and </span>
<span id="L157" class="LineNr"> 157 </span>                  <span class="Comment">// a func assigning values to o</span>
<span id="L158" class="LineNr"> 158 </span>             ] <span class="Type">:</span> is <span class="Type">in</span> <span class="Identifier">domain</span>(t_s) };
<span id="L159" class="LineNr"> 159 </span>  };
<span id="L160" class="LineNr"> 160 </span>
<span id="L161" class="LineNr"> 161 </span>  <span class="Comment">/* We explicitly cache f after computing it. This allows us to directly set</span>
<span id="L162" class="LineNr"> 162 </span><span class="Comment">     its value when testing or when performing the brute force search would be</span>
<span id="L163" class="LineNr"> 163 </span><span class="Comment">     prohibitively costly.  */</span>
<span id="L164" class="LineNr"> 164 </span>  cached_f <span class="Statement">:=</span> cached_f;
<span id="L165" class="LineNr"> 165 </span>  cached_lf <span class="Statement">:=</span> cached_lf;
<span id="L166" class="LineNr"> 166 </span>
<span id="L167" class="LineNr"> 167 </span>  <span class="Comment">/* ns as in the plural of n. </span>
<span id="L168" class="LineNr"> 168 </span><span class="Comment">     Takes 'e', 'm2' or 'o' and returns the corresponding variables from all n.</span>
<span id="L169" class="LineNr"> 169 </span><span class="Comment">     e.g. ns('e') would return all e_n_i */</span>
<span id="L170" class="LineNr"><a href="#tda-43" data-file="test_decision_algorithm" title="test_ns" class="checkmark">&#10004;</a> 170 </span>  <span class="Identifier">ns</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(str) {
<span id="L171" class="LineNr"> 171 </span>    <span class="Statement">if</span> (str <span class="Type">==</span> <span class="Constant">'e'</span>) {
<span id="L172" class="LineNr"> 172 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Identifier">range</span>(n_i[str]) <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L173" class="LineNr"> 173 </span>    } <span class="Statement">else</span> {
<span id="L174" class="LineNr"> 174 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { n_i[str] <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L175" class="LineNr"> 175 </span>    }
<span id="L176" class="LineNr"> 176 </span>  };
<span id="L177" class="LineNr"> 177 </span>
<span id="L178" class="LineNr"><a href="#tda-72" data-file="test_decision_algorithm" title="test_p_vars" class="checkmark">&#10004;</a> 178 </span>  <span class="Identifier">p_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L179" class="LineNr"> 179 </span>    <span class="Statement">return</span> <span class="Identifier">range</span>(p) <span class="Type">+</span> <span class="Identifier">range</span>(cp);
<span id="L180" class="LineNr"> 180 </span>  };
<span id="L181" class="LineNr"> 181 </span>
<span id="L182" class="LineNr"><a href="#tda-62" data-file="test_decision_algorithm" title="test_p_u_vars" class="checkmark">&#10004;</a> 182 </span>  <span class="Identifier">p_u_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L183" class="LineNr"> 183 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-178">p_vars</a>() <span class="Type">+</span> <span class="Identifier">range</span>(u);
<span id="L184" class="LineNr"> 184 </span>  };
<span id="L185" class="LineNr"> 185 </span>
<span id="L186" class="LineNr"> 186 </span>  <span class="Comment">/* Takes a function (is) assigning values to input and internal state vars</span>
<span id="L187" class="LineNr"> 187 </span><span class="Comment">     and returns its partial function with only vars in p, u and m2  */</span>
<span id="L188" class="LineNr"><a href="#tda-74" data-file="test_decision_algorithm" title="test_just_p_u_m2" class="checkmark">&#10004;</a> 188 </span>  <span class="Identifier">just_p_u_m2</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(is) {
<span id="L189" class="LineNr"> 189 </span>    <span class="Statement">return</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> is <span class="Type">|</span> var <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-182">p_u_vars</a>() <span class="Type">+</span> m2 };
<span id="L190" class="LineNr"> 190 </span>  };
<span id="L191" class="LineNr"> 191 </span>
<span id="L192" class="LineNr"> 192 </span><span class="Comment Heading">// Variable Relationships </span>
<span id="L193" class="LineNr"> 193 </span><span class="Comment Heading">// ----------------------</span>
<span id="L194" class="LineNr"> 194 </span>
<span id="L195" class="LineNr"> 195 </span>  <span class="Comment">/* Takes a variable and returns its parents, i.e. the variables that </span>
<span id="L196" class="LineNr"> 196 </span><span class="Comment">     are necessary to determine its next state in the state transition t(). */</span>
<span id="L197" class="LineNr"><a href="#tda-88" data-file="test_decision_algorithm" title="test_parents" class="checkmark">&#10004;</a> 197 <a title="1.2.1.1.12.2" class="back_to_li" href="#t-1-2-1-1-12-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">parents</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y) {
<span id="L198" class="LineNr"> 198 </span>    result <span class="Statement">:=</span> { z <span class="Type">:</span> z <span class="Type">in</span> (i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>()) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-202">is_necessary_parent_of</a>(z, y) };
<span id="L199" class="LineNr"> 199 </span>    <span class="Statement">return</span> result;
<span id="L200" class="LineNr"> 200 </span>  };
<span id="L201" class="LineNr"> 201 </span>
<span id="L202" class="LineNr"><a href="#tda-106" data-file="test_decision_algorithm" title="test_is_necessary_parent_of" class="checkmark">&#10004;</a> 202 </span>    <span class="Identifier">is_necessary_parent_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(z, y) {
<span id="L203" class="LineNr"> 203 </span>      vs <span class="Statement">:=</span> {v <span class="Type">:</span> v <span class="Type">in</span> i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">|</span> v <span class="Type">!=</span> z}; <span class="Comment">// all other variables but z</span>
<span id="L204" class="LineNr"> 204 </span>      f_vs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(vs, r);
<span id="L205" class="LineNr"> 205 </span>      bool <span class="Statement">:=</span> <span class="Type">exists</span>(f_v <span class="Type">in</span> f_vs <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-212">vals_diff</a>(f_v, y, z));
<span id="L206" class="LineNr"> 206 </span>      <span class="Statement">return</span> bool;
<span id="L207" class="LineNr"> 207 </span>    };
<span id="L208" class="LineNr"> 208 </span>
<span id="L209" class="LineNr"> 209 </span>    <span class="Comment">/* Check whether there exists an assignment of values to the other </span>
<span id="L210" class="LineNr"> 210 </span><span class="Comment">       variables such that there are still different values of y depending </span>
<span id="L211" class="LineNr"> 211 </span><span class="Comment">       on values of z.  */</span>
<span id="L212" class="LineNr"><a href="#tda-107" data-file="test_decision_algorithm" title="test_vals_diff" class="checkmark">&#10004;</a> 212 </span>    <span class="Identifier">vals_diff</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(f_v, y, z) {
<span id="L213" class="LineNr"> 213 </span>      vals <span class="Statement">:=</span> { t_s[ f_v <span class="Type">+</span> {[z,r_i]} ][y] <span class="Type">:</span> r_i <span class="Type">in</span> r[z] };
<span id="L214" class="LineNr"> 214 </span>      <span class="Statement">return</span> <span class="Type">#</span>vals <span class="Type">&gt;</span> <span class="Constant">1</span>;
<span id="L215" class="LineNr"> 215 </span>    };
<span id="L216" class="LineNr"> 216 </span>
<span id="L217" class="LineNr"> 217 </span>  <span class="Comment">// Takes a variable and returns its children</span>
<span id="L218" class="LineNr"><a href="#tda-105" data-file="test_decision_algorithm" title="test_children" class="checkmark">&#10004;</a> 218 </span>  <span class="Identifier">children</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y) {
<span id="L219" class="LineNr"> 219 </span>    <span class="Statement">return</span> { v <span class="Type">:</span> v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> o <span class="Type">|</span> y <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-197">parents</a>(v) };
<span id="L220" class="LineNr"> 220 </span>  };
<span id="L221" class="LineNr"> 221 </span>
<span id="L222" class="LineNr"> 222 </span>  <span class="Comment">/* Takes a variable v and a set of variables vs (with v usually in vs)</span>
<span id="L223" class="LineNr"> 223 </span><span class="Comment">     and returns the first ancestors within any given branch of v's ancestors </span>
<span id="L224" class="LineNr"> 224 </span><span class="Comment">     that are not in vs */</span>
<span id="L225" class="LineNr"><a href="#tda-115" data-file="test_decision_algorithm" title="test_non_shared_ancestors" class="checkmark">&#10004;</a> 225 </span>  <span class="Identifier">non_shared_ancestors</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(v, vs) {
<span id="L226" class="LineNr"> 226 </span>    result <span class="Statement">:=</span> {};
<span id="L227" class="LineNr"> 227 </span>    <span class="Statement">for</span> (parent <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-197">parents</a>(v)) {
<span id="L228" class="LineNr"> 228 </span>      <span class="Statement">if</span> (parent <span class="Type">in</span> vs) {
<span id="L229" class="LineNr"> 229 </span>        result <span class="Statement">:=</span> result <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-225">non_shared_ancestors</a>(parent, vs);
<span id="L230" class="LineNr"> 230 </span>      } <span class="Statement">else</span> {
<span id="L231" class="LineNr"> 231 </span>        result <span class="Statement">:=</span> result <span class="Type">+</span> { parent };
<span id="L232" class="LineNr"> 232 </span>      }
<span id="L233" class="LineNr"> 233 </span>    }
<span id="L234" class="LineNr"> 234 </span>    <span class="Statement">return</span> result;
<span id="L235" class="LineNr"> 235 </span>  };
<span id="L236" class="LineNr"> 236 </span>
<span id="L237" class="LineNr"> 237 </span>  <span class="Comment">/* Takes a variable v and a set of variables vs (with v usually in vs)</span>
<span id="L238" class="LineNr"> 238 </span><span class="Comment">     and returns the first descendants within any given branch of v's </span>
<span id="L239" class="LineNr"> 239 </span><span class="Comment">     descendants that are not in vs */</span>
<span id="L240" class="LineNr"><a href="#tda-172" data-file="test_decision_algorithm" title="test_non_shared_descendants" class="checkmark">&#10004;</a> 240 </span>  <span class="Identifier">non_shared_descendants</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(v, vs) {
<span id="L241" class="LineNr"> 241 </span>    result <span class="Statement">:=</span> {};
<span id="L242" class="LineNr"> 242 </span>    <span class="Statement">for</span> (child <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-218">children</a>(v)) {
<span id="L243" class="LineNr"> 243 </span>      <span class="Statement">if</span> (child <span class="Type">in</span> vs) {
<span id="L244" class="LineNr"> 244 </span>        result <span class="Statement">:=</span> result <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-240">non_shared_descendants</a>(child, vs);
<span id="L245" class="LineNr"> 245 </span>      } <span class="Statement">else</span> {
<span id="L246" class="LineNr"> 246 </span>        result <span class="Statement">:=</span> result <span class="Type">+</span> { child };
<span id="L247" class="LineNr"> 247 </span>      }
<span id="L248" class="LineNr"> 248 </span>    }
<span id="L249" class="LineNr"> 249 </span>    <span class="Statement">return</span> result;
<span id="L250" class="LineNr"> 250 </span>  };
<span id="L251" class="LineNr"> 251 </span>
<span id="L252" class="LineNr"> 252 </span>
<span id="L253" class="LineNr"> 253 </span><span class="Comment Heading">// Syntax and Implementation</span>
<span id="L254" class="LineNr"> 254 </span><span class="Comment Heading">// =========================</span>
<span id="L255" class="LineNr"> 255 </span><span class="Comment">// See also better_explanation and the section starting with complexity.</span>
<span id="L256" class="LineNr"> 256 </span>
<span id="L257" class="LineNr"> 257 </span>  <span class="Comment">/* Function from a causal_markov_moodel of a brain to an implementation </span>
<span id="L258" class="LineNr"> 258 </span><span class="Comment">     mapping f which is a higher-order function from a function assigning </span>
<span id="L259" class="LineNr"> 259 </span><span class="Comment">     states to the brain's variables to a function assigning states to internal </span>
<span id="L260" class="LineNr"> 260 </span><span class="Comment">     state variables s() meeting certain criteria. </span>
<span id="L261" class="LineNr"> 261 </span><span class="Comment">  */</span>
<span id="L262" class="LineNr"> 262 </span>  <span class="Identifier">f</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L263" class="LineNr"> 263 </span>    <span class="Statement">if</span> (cached_f <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L264" class="LineNr"> 264 </span>      cached_f <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-269">compute_f</a>(b);
<span id="L265" class="LineNr"> 265 </span>    }
<span id="L266" class="LineNr"> 266 </span>    <span class="Statement">return</span> cached_f;
<span id="L267" class="LineNr"> 267 </span>  };
<span id="L268" class="LineNr"> 268 </span>
<span id="L269" class="LineNr"> 269 </span>  <span class="Identifier">compute_f</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b) {
<span id="L270" class="LineNr"> 270 </span>    fs <span class="Statement">:=</span> { pf <span class="Type">:</span> pf <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-285">possible_fs</a>(b) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-315">commutes</a>(pf, b) };
<span id="L271" class="LineNr"> 271 </span>    <span class="Comment">/* Todo: Sort by complexity and return the simplest? </span>
<span id="L272" class="LineNr"> 272 </span><span class="Comment">       Or also factor in ambitiousness? Coverage of more states?  */</span>
<span id="L273" class="LineNr"> 273 </span>    <span class="Statement">if</span> (<span class="Type">#</span>fs <span class="Type">&gt;</span> <span class="Constant">0</span>) {
<span id="L274" class="LineNr"> 274 </span>      <span class="Statement">return</span> <span class="Identifier">first</span>(fs);
<span id="L275" class="LineNr"> 275 </span>    } <span class="Statement">else</span> {
<span id="L276" class="LineNr"> 276 </span>      <span class="Statement">return</span> {};
<span id="L277" class="LineNr"> 277 </span>    }
<span id="L278" class="LineNr"> 278 </span>  };
<span id="L279" class="LineNr"> 279 </span>
<span id="L280" class="LineNr"> 280 </span>  <span class="Comment">/* Function from a causal_markov_model of a brain to the possible </span>
<span id="L281" class="LineNr"> 281 </span><span class="Comment">     implementation mappings f which map from a function assigning values to </span>
<span id="L282" class="LineNr"> 282 </span><span class="Comment">     the exogenous and endogenous variables of the causal_markov_model to </span>
<span id="L283" class="LineNr"> 283 </span><span class="Comment">     functions assigning values to the input, internal state, and output </span>
<span id="L284" class="LineNr"> 284 </span><span class="Comment">     variables. */</span>
<span id="L285" class="LineNr"> 285 </span>  <span class="Identifier">possible_fs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L286" class="LineNr"> 286 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-319">function_space</a>( b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>(), <a class="Identifier code-proc-link" href="#da-289">poss_states</a>() );
<span id="L287" class="LineNr"> 287 </span>  };
<span id="L288" class="LineNr"> 288 </span>
<span id="L289" class="LineNr"><a href="#tda-276" data-file="test_decision_algorithm" title="test_poss_states" class="checkmark">&#10004;</a> 289 </span>  <span class="Identifier">poss_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L290" class="LineNr"> 290 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> o, r);
<span id="L291" class="LineNr"> 291 </span>  };
<span id="L292" class="LineNr"> 292 </span>
<span id="L293" class="LineNr"><a href="#tda-323" data-file="test_decision_algorithm" title="test_is_implemented_by" class="checkmark">&#10004;</a> 293 </span>  <span class="Identifier">is_implemented_by</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L294" class="LineNr"> 294 </span>    <span class="Statement">return</span> <span class="Type">!</span>(<a class="Identifier code-proc-link" href="#da-262">f</a>(b) <span class="Type">==</span> {});
<span id="L295" class="LineNr"> 295 </span>  };
<span id="L296" class="LineNr"> 296 </span>
<span id="L297" class="LineNr"> 297 </span>  <span class="Comment Heading">/* Implementation Functor</span>
<span id="L298" class="LineNr"> 298 </span><span class="Comment Heading">     ----------------------</span>
<span id="L299" class="LineNr"> 299 </span><span class="Comment">     Check whether a possible implementation functor pf commutes. See f.</span>
<span id="L300" class="LineNr"> 300 </span>
<span id="L301" class="LineNr"> 301 </span><span class="Comment">     This basically implements Chalmers' criterion for when some causal system </span>
<span id="L302" class="LineNr"> 302 </span><span class="Comment">     implements a computation: <a href="http://consc.net/papers/rock.html" target="_blank">http://consc.net/papers/rock.html</a></span>
<span id="L303" class="LineNr"> 303 </span>
<span id="L304" class="LineNr"> 304 </span><span class="Comment">     In category theory terms, we can say that f is an implementation functor.</span>
<span id="L305" class="LineNr"> 305 </span><span class="Comment">     Given a category of brain states and the causal relations between them</span>
<span id="L306" class="LineNr"> 306 </span><span class="Comment">     and another of decision states and cognitive state transitions between</span>
<span id="L307" class="LineNr"> 307 </span><span class="Comment">     them, f would be a functor mapping i) brain states to decision states and</span>
<span id="L308" class="LineNr"> 308 </span><span class="Comment">     ii) causal transitions to decision state transitions such that it doesn't</span>
<span id="L309" class="LineNr"> 309 </span><span class="Comment">     matter whether one goes from a) a brain state to the brain state it causes </span>
<span id="L310" class="LineNr"> 310 </span><span class="Comment">     and then to the decision state f maps that brain state to or b) first from </span>
<span id="L311" class="LineNr"> 311 </span><span class="Comment">     the same original brain state to the decision state f says it implements </span>
<span id="L312" class="LineNr"> 312 </span><span class="Comment">     and then to the next decision state this decision algorithm transitions to.</span>
<span id="L313" class="LineNr"> 313 </span><span class="Comment">     Either way, you would end up at the same final decision state. </span>
<span id="L314" class="LineNr"> 314 </span><span class="Comment">  */</span>
<span id="L315" class="LineNr"><a href="#tda-291" data-file="test_decision_algorithm" title="test_commutes" class="checkmark">&#10004;</a> 315 <a title="1.2.1.2" class="back_to_li" href="#t-1-2-1-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">commutes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(pf, b) {
<span id="L316" class="LineNr"> 316 </span>    <span class="Comment Heading">/*                 pf</span>
<span id="L317" class="LineNr"> 317 </span><span class="Comment Heading">      bs_{b.uv_t_i-1} ------&gt; ds_iso_t_i-1</span>
<span id="L318" class="LineNr"> 318 </span><span class="Comment">       |                       |</span>
<span id="L319" class="LineNr"> 319 </span><span class="Comment">       | b.response            | restrict_domain</span>
<span id="L320" class="LineNr"> 320 </span><span class="Comment">       |                       | t()</span>
<span id="L321" class="LineNr"> 321 </span><span class="Comment Heading">       v                       v</span>
<span id="L322" class="LineNr"> 322 </span><span class="Comment Heading">      bs_{b.v_ti} ----------&gt; ds_so_t_i</span>
<span id="L323" class="LineNr"> 323 </span><span class="Comment">           +u  pf  restrict_domain</span>
<span id="L324" class="LineNr"> 324 </span>
<span id="L325" class="LineNr"> 325 </span><span class="Comment">      Roughly check that t( pf ) == pf( b.response ) </span>
<span id="L326" class="LineNr"> 326 </span><span class="Comment">    */</span>
<span id="L327" class="LineNr"> 327 </span>    <span class="Statement">return</span> <span class="Type">forall</span>(bs <span class="Type">in</span> <span class="Identifier">domain</span>(pf) <span class="Type">|</span>
<span id="L328" class="LineNr"> 328 </span>       <span class="Identifier">t</span>()[<a class="Identifier code-proc-link" href="#l-751">restrict_domain</a>(pf[bs], i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>())] <span class="Type">==</span>
<span id="L329" class="LineNr"> 329 </span>       <span class="Identifier">restrict_domain</span>(pf[
<span id="L330" class="LineNr"> 330 </span>         b.<span class="Identifier">response</span>(b.v, bs) <span class="Type">+</span> { [u_var, <span class="Identifier">first</span>(b.r[u_var])] <span class="Type">:</span> u_var <span class="Type">in</span> b.u }
<span id="L331" class="LineNr"> 331 </span>       ], <span class="Identifier">s</span>() <span class="Type">+</span> o)
<span id="L332" class="LineNr"> 332 </span>     );
<span id="L333" class="LineNr"> 333 </span>  };
<span id="L334" class="LineNr"> 334 </span>  <span class="Comment">/* Technical footnote: The above is almost true, but causal response and </span>
<span id="L335" class="LineNr"> 335 </span><span class="Comment">     decision state transitions don't quite take brain states to entire brain </span>
<span id="L336" class="LineNr"> 336 </span><span class="Comment">     states or entire decision states to entire decision states. The causal </span>
<span id="L337" class="LineNr"> 337 </span><span class="Comment">     response only specifies the endogenous variables on the next time step. So </span>
<span id="L338" class="LineNr"> 338 </span><span class="Comment">     in order to have a full brain state for pf, we just fill in the exogenous </span>
<span id="L339" class="LineNr"> 339 </span><span class="Comment">     variables with their first values, only to drop those values anyway after</span>
<span id="L340" class="LineNr"> 340 </span><span class="Comment">     obtaining the decision state it implements. Similarly, with the decision </span>
<span id="L341" class="LineNr"> 341 </span><span class="Comment">     state, the previous outputs are irrelevant to the state transition to the </span>
<span id="L342" class="LineNr"> 342 </span><span class="Comment">     next decision state so we drop those before finding the next decision </span>
<span id="L343" class="LineNr"> 343 </span><span class="Comment">     state which is almost full with the exception of the (exogenous) inputs.</span>
<span id="L344" class="LineNr"> 344 </span>
<span id="L345" class="LineNr"> 345 </span><span class="Comment">     The code should be correct and this only affects the intuitive explanation.</span>
<span id="L346" class="LineNr"> 346 </span><span class="Comment">     If we had used lf which is defined below, I think we could truly say it is</span>
<span id="L347" class="LineNr"> 347 </span><span class="Comment">     a functor. Since it maps partial brain states to (sets of) partial </span>
<span id="L348" class="LineNr"> 348 </span><span class="Comment">     decision states, it wouldn't need to make the aforementioned adjustments</span>
<span id="L349" class="LineNr"> 349 </span><span class="Comment">     which prevent it from quite being a functor. However, lf is defined in </span>
<span id="L350" class="LineNr"> 350 </span><span class="Comment">     terms of f, so we'd still need to understand f first and for now, </span>
<span id="L351" class="LineNr"> 351 </span><span class="Comment">     almost-a-functor might have to do.</span>
<span id="L352" class="LineNr"> 352 </span><span class="Comment">  */</span>
<span id="L353" class="LineNr"> 353 </span>
<span id="L354" class="LineNr"> 354 </span>  <span class="Comment">/* Takes a decision state assigning values to i + s() + o and returns a</span>
<span id="L355" class="LineNr"> 355 </span><span class="Comment">     function assigning values to just s() + o  */</span>
<span id="L356" class="LineNr"><a href="#tda-391" data-file="test_decision_algorithm" title="test_drop_i" class="checkmark">&#10004;</a> 356 </span>  <span class="Identifier">drop_i</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds) {
<span id="L357" class="LineNr"> 357 </span>    <span class="Statement">return</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> ds <span class="Type">|</span> <span class="Type">!</span>(var <span class="Type">in</span> i) };
<span id="L358" class="LineNr"> 358 </span>  };
<span id="L359" class="LineNr"> 359 </span>
<span id="L360" class="LineNr"> 360 </span>  <span class="Comment">/* Local / partial f</span>
<span id="L361" class="LineNr"> 361 </span><span class="Comment">     Returns a function mapping partial causal states to partial decision states</span>
<span id="L362" class="LineNr"> 362 </span><span class="Comment">     which commutes, i.e. it maps partial causal states to the partial decision </span>
<span id="L363" class="LineNr"> 363 </span><span class="Comment">     state which is forced by the complete mapping f.  */</span>
<span id="L364" class="LineNr"> 364 <a title="1.3.2.2.1.2" class="back_to_li" href="#t-1-3-2-2-1-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">lf</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L365" class="LineNr"> 365 </span>    <span class="Statement">if</span> (cached_lf <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L366" class="LineNr"> 366 </span>      cached_lf <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-371">compute_lf</a>(b);
<span id="L367" class="LineNr"> 367 </span>    }
<span id="L368" class="LineNr"> 368 </span>    <span class="Statement">return</span> cached_lf;
<span id="L369" class="LineNr"> 369 </span>  };
<span id="L370" class="LineNr"> 370 </span>
<span id="L371" class="LineNr"> 371 </span>  <span class="Identifier">compute_lf</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b) {
<span id="L372" class="LineNr"> 372 </span>    <span class="Comment">/* Possible local fs </span>
<span id="L373" class="LineNr"> 373 </span><span class="Comment">       Function space from union of partial causal states to the union of </span>
<span id="L374" class="LineNr"> 374 </span><span class="Comment">       partial decision states.  */</span>
<span id="L375" class="LineNr"> 375 </span>    plfs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-319">function_space</a>(
<span id="L376" class="LineNr"> 376 </span>      <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-336">partial_functions</a>(cs) <span class="Type">:</span> cs <span class="Type">in</span> b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() }, <span class="Comment">// causal states</span>
<span id="L377" class="LineNr"> 377 </span>      <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-336">partial_functions</a>(ds) <span class="Type">:</span> ds <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-289">poss_states</a>() } <span class="Comment">// decision states</span>
<span id="L378" class="LineNr"> 378 </span>    );
<span id="L379" class="LineNr"> 379 </span>    lfs <span class="Statement">:=</span> [ plf <span class="Type">:</span> plf <span class="Type">in</span> plfs <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-386">lf_commutes</a>(plf, b) ];
<span id="L380" class="LineNr"> 380 </span>    lfs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(lfs, <span class="Type">procedure</span>(plf1, plf2) { <span class="Statement">return</span> <span class="Type">#</span>plf1 <span class="Type">&gt;</span> <span class="Type">#</span>plf2; });
<span id="L381" class="LineNr"> 381 </span>    <span class="Statement">return</span> lfs[<span class="Constant">1</span>];
<span id="L382" class="LineNr"> 382 </span>  };
<span id="L383" class="LineNr"> 383 </span>
<span id="L384" class="LineNr"> 384 </span>  <span class="Comment">/* Function from possible local function plf and a causal model of brain b </span>
<span id="L385" class="LineNr"> 385 </span><span class="Comment">     to boolean value whether it commutes. */</span>
<span id="L386" class="LineNr"><a href="#tda-301" data-file="test_decision_algorithm" title="test_lf_commutes" class="checkmark">&#10004;</a> 386 <a title="1.3.2.2.1.2.1" class="back_to_li" href="#t-1-3-2-2-1-2-1"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">lf_commutes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(plf, b) {
<span id="L387" class="LineNr"> 387 </span>    <span class="Statement">return</span> <span class="Type">forall</span>(pcs <span class="Type">in</span> <span class="Identifier">domain</span>(plf) <span class="Type">|</span>  <span class="Comment">// pcs = partial causal state</span>
<span id="L388" class="LineNr"> 388 </span>      <span class="Comment">/* The set of complete decision states that is mapped by f from each </span>
<span id="L389" class="LineNr"> 389 </span><span class="Comment">         complete causal state compatible with the partial causal state is </span>
<span id="L390" class="LineNr"> 390 </span><span class="Comment">         equal to the set of complete decision states compatible with </span>
<span id="L391" class="LineNr"> 391 </span><span class="Comment">         the partial decision states mapped by the possible lf from the partial</span>
<span id="L392" class="LineNr"> 392 </span><span class="Comment">         causal state. */</span>
<span id="L393" class="LineNr"> 393 </span>      { <span class="Identifier">f</span>(b)[ccs] <span class="Type">:</span> ccs <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-352">compatible_complete_states</a>(pcs, b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>()) } <span class="Type">==</span>
<span id="L394" class="LineNr"> 394 </span>      <span class="Identifier">compatible_complete_states</span>(plf[pcs], <a class="Identifier code-proc-link" href="#da-289">poss_states</a>())
<span id="L395" class="LineNr"> 395 </span>    );
<span id="L396" class="LineNr"> 396 </span>  };
<span id="L397" class="LineNr"> 397 </span>
<span id="L398" class="LineNr"> 398 </span>  <span class="Comment">/* Local / partial f inverse</span>
<span id="L399" class="LineNr"> 399 </span><span class="Comment">  /* Returns a "function" from local / partial decision states to a set of </span>
<span id="L400" class="LineNr"> 400 </span><span class="Comment">     local / partial causal states, namely the inverse of lf.  */</span>
<span id="L401" class="LineNr"><a href="#tda-330" data-file="test_decision_algorithm" title="test_lf_inv" class="checkmark">&#10004;</a> 401 </span>  <span class="Identifier">lf_inv</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b) {
<span id="L402" class="LineNr"> 402 </span>    <span class="Statement">return</span> { [ds, { cs <span class="Type">:</span> cs <span class="Type">in</span> <span class="Identifier">domain</span>(<a class="Identifier code-proc-link" href="#da-364">lf</a>(b)) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-364">lf</a>(b)[cs] <span class="Type">==</span> ds} ] <span class="Type">:</span>
<span id="L403" class="LineNr"> 403 </span>             ds <span class="Type">in</span> <span class="Identifier">range</span>(<a class="Identifier code-proc-link" href="#da-364">lf</a>(b)) };
<span id="L404" class="LineNr"> 404 </span>  };
<span id="L405" class="LineNr"> 405 </span>
<span id="L406" class="LineNr"> 406 </span>  <span class="Comment">// Helper function. Same as lf_inv but time subscripts are added to the b vars</span>
<span id="L407" class="LineNr"><a href="#tda-340" data-file="test_decision_algorithm" title="test_lf_inv_at" class="checkmark">&#10004;</a> 407 </span>  <span class="Identifier">lf_inv_at</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, t_i) {
<span id="L408" class="LineNr"> 408 </span>    <span class="Statement">return</span> { [ds, { <a class="Identifier code-proc-link" href="#l-403">assign_time</a>(cs, t_i) <span class="Type">:</span> cs <span class="Type">in</span> css }]
<span id="L409" class="LineNr"> 409 </span>             <span class="Type">:</span> [ds, css] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-401">lf_inv</a>(b) };
<span id="L410" class="LineNr"> 410 </span>  };
<span id="L411" class="LineNr"> 411 </span>
<span id="L412" class="LineNr"> 412 </span>  <span class="Comment">/* Takes an event in b.cm() and returns the local decision state that the </span>
<span id="L413" class="LineNr"> 413 </span><span class="Comment">     brain state implements.  */</span>
<span id="L414" class="LineNr"><a href="#tda-349" data-file="test_decision_algorithm" title="test_lf_cm" class="checkmark">&#10004;</a> 414 </span>  <span class="Identifier">lf_cm</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, b_event) {
<span id="L415" class="LineNr"> 415 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-364">lf</a>(b)[<a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b_event)];
<span id="L416" class="LineNr"> 416 </span>  };
<span id="L417" class="LineNr"> 417 </span>
<span id="L418" class="LineNr"> 418 </span>  <span class="Comment">// Returns the decision state variables implemented by a local brain state.</span>
<span id="L419" class="LineNr"><a href="#tda-356" data-file="test_decision_algorithm" title="test_lf_cm_vs" class="checkmark">&#10004;</a> 419 </span>  <span class="Identifier">lf_cm_vs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, b_event) {
<span id="L420" class="LineNr"> 420 </span>    d_event <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-414">lf_cm</a>(b, b_event);
<span id="L421" class="LineNr"> 421 </span>    <span class="Statement">if</span> (d_event <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L422" class="LineNr"> 422 </span>      <span class="Statement">return</span> {};
<span id="L423" class="LineNr"> 423 </span>    } <span class="Statement">else</span> {
<span id="L424" class="LineNr"> 424 </span>      <span class="Statement">return</span> <span class="Identifier">domain</span>(d_event);
<span id="L425" class="LineNr"> 425 </span>    }
<span id="L426" class="LineNr"> 426 </span>  };
<span id="L427" class="LineNr"> 427 </span>
<span id="L428" class="LineNr"> 428 </span>  <span class="Comment">/* Similar to above but returns the formula in the domain(p) that gets </span>
<span id="L429" class="LineNr"> 429 </span><span class="Comment">     mapped to the p var.  */</span>
<span id="L430" class="LineNr"><a href="#tda-363" data-file="test_decision_algorithm" title="test_lf_cm_p_inv" class="checkmark">&#10004;</a> 430 </span>  <span class="Identifier">lf_cm_p_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, b_event) {
<span id="L431" class="LineNr"> 431 </span>    vs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-419">lf_cm_vs</a>(b, b_event);
<span id="L432" class="LineNr"> 432 </span>    <span class="Statement">if</span> (<span class="Type">#</span>vs <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L433" class="LineNr"> 433 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(<span class="Identifier">first</span>(vs));
<span id="L434" class="LineNr"> 434 </span>    } <span class="Statement">else</span> {
<span id="L435" class="LineNr"> 435 </span>      <span class="Statement">return</span> <span class="Constant">om</span>;
<span id="L436" class="LineNr"> 436 </span>    }
<span id="L437" class="LineNr"> 437 </span>  };
<span id="L438" class="LineNr"> 438 </span>
<span id="L439" class="LineNr"><a href="#tda-338" data-file="test_decision_algorithm" title="test_plf_to_pf" class="checkmark">&#10004;</a> 439 </span>  <span class="Identifier">plf_to_pf</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, plf) {
<span id="L440" class="LineNr"> 440 </span>    <span class="Comment">/* For each decision state var, construct the function from complete </span>
<span id="L441" class="LineNr"> 441 </span><span class="Comment">       causal states to the state of that variable. */</span>
<span id="L442" class="LineNr"> 442 </span>    pf_var <span class="Statement">:=</span> {
<span id="L443" class="LineNr"> 443 </span>      [var, <span class="Type">+/</span> { { [ccs, pds]
<span id="L444" class="LineNr"> 444 </span>                   <span class="Type">:</span> ccs <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-352">compatible_complete_states</a>(pcs, b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>())
<span id="L445" class="LineNr"> 445 </span>                 } <span class="Type">:</span> [pcs, pds] <span class="Type">in</span> plf <span class="Type">|</span> <span class="Identifier">first</span>(<span class="Identifier">first</span>(pds)) <span class="Type">==</span> var }
<span id="L446" class="LineNr"> 446 </span>      ] <span class="Type">:</span> var <span class="Type">in</span> i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> o
<span id="L447" class="LineNr"> 447 </span>    };
<span id="L448" class="LineNr"> 448 </span>    <span class="Statement">return</span> { [bs, <span class="Type">+/</span> { (pf_var[var])[bs] <span class="Type">:</span> var <span class="Type">in</span> i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> o }]
<span id="L449" class="LineNr"> 449 </span>             <span class="Type">:</span> bs <span class="Type">in</span> b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() };
<span id="L450" class="LineNr"> 450 </span>  };
<span id="L451" class="LineNr"> 451 </span>
<span id="L452" class="LineNr"> 452 </span>
<span id="L453" class="LineNr"> 453 </span>  <span class="Comment">// This is mostly just checking for syntactic validity or well-formedness.</span>
<span id="L454" class="LineNr"> 454 </span>  <span class="Comment">// See also all_lte.</span>
<span id="L455" class="LineNr"> 455 </span>  <span class="Identifier">is_valid</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L456" class="LineNr"> 456 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-463">m2s_are_valid</a>() <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#da-485">no_e_in_u</a>();
<span id="L457" class="LineNr"> 457 </span>  };
<span id="L458" class="LineNr"> 458 </span>
<span id="L459" class="LineNr"> 459 </span>  <span class="Comment">/* Ensures that m2s merely moderate between p + u and o.</span>
<span id="L460" class="LineNr"> 460 </span><span class="Comment">     I'm no longer sure if this is necessary since we measure and punish </span>
<span id="L461" class="LineNr"> 461 </span><span class="Comment">     attributing irrationality but it also doesn't seem too bad of a </span>
<span id="L462" class="LineNr"> 462 </span><span class="Comment">     simplifying assumption for now.  */</span>
<span id="L463" class="LineNr"><a href="#tda-406" data-file="test_decision_algorithm" title="test_m2s_are_valid" class="checkmark">&#10004;</a> 463 </span>  <span class="Identifier">m2s_are_valid</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L464" class="LineNr"> 464 </span>    <span class="Statement">return</span> <span class="Type">forall</span> (m2_i <span class="Type">in</span> m2 <span class="Type">|</span>
<span id="L465" class="LineNr"> 465 </span>      <span class="Type">forall</span> (v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-225">non_shared_ancestors</a>(m2_i, m2) <span class="Type">|</span> v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-182">p_u_vars</a>()) <span class="Type">&amp;&amp;</span>
<span id="L466" class="LineNr"> 466 </span>      <span class="Type">forall</span> (v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-240">non_shared_descendants</a>(m2_i, m2) <span class="Type">|</span> v <span class="Type">in</span> o)
<span id="L467" class="LineNr"> 467 </span>    ) <span class="Type">&amp;&amp;</span> <span class="Type">forall</span> (n_i <span class="Type">in</span> n <span class="Type">|</span>
<span id="L468" class="LineNr"> 468 </span>      <span class="Type">forall</span> (m2_j_n_i <span class="Type">in</span> n_i[<span class="Constant">'m2'</span>] <span class="Type">|</span>
<span id="L469" class="LineNr"> 469 </span>        <span class="Type">forall</span> (v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-225">non_shared_ancestors</a>(m2_j_n_i, n_i[<span class="Constant">'m2'</span>]) <span class="Type">|</span>
<span id="L470" class="LineNr"> 470 </span>                v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-178">p_vars</a>() <span class="Type">+</span> <span class="Identifier">range</span>(n_i[<span class="Constant">'e'</span>]) ) <span class="Type">&amp;&amp;</span>
<span id="L471" class="LineNr"> 471 </span>        <span class="Type">forall</span> (v <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-240">non_shared_descendants</a>(m2_j_n_i, n_i[<span class="Constant">'m2'</span>]) <span class="Type">|</span>
<span id="L472" class="LineNr"> 472 </span>                v <span class="Type">in</span> n_i[<span class="Constant">'o'</span>])
<span id="L473" class="LineNr"> 473 </span>      )
<span id="L474" class="LineNr"> 474 </span>    );
<span id="L475" class="LineNr"> 475 </span>  };
<span id="L476" class="LineNr"> 476 </span>
<span id="L477" class="LineNr"> 477 </span>  <span class="Comment">/* This helps ensure higher-order ambitiousness by preventing the smuggling</span>
<span id="L478" class="LineNr"> 478 </span><span class="Comment">     of evaluation functions within u. For each p expr of the form x []-&gt; y,</span>
<span id="L479" class="LineNr"> 479 </span><span class="Comment">     make sure it does not take the form that x-ing would bring about y which </span>
<span id="L480" class="LineNr"> 480 </span><span class="Comment">     the agent values (but x is not in the normal outputs o) and this </span>
<span id="L481" class="LineNr"> 481 </span><span class="Comment">     recognition causes x-ing. If it is of that form, we want a decision </span>
<span id="L482" class="LineNr"> 482 </span><span class="Comment">     algorithm that includes that explicitly within n.  </span>
<span id="L483" class="LineNr"> 483 </span><span class="Comment">     Todo: Generalize to no_e_in_e and cover more cases, e.g. indirect </span>
<span id="L484" class="LineNr"> 484 </span><span class="Comment">     reference or equivalent expressions or influencing as grandparents.  */</span>
<span id="L485" class="LineNr"> 485 </span>  <span class="Identifier">no_e_in_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L486" class="LineNr"> 486 </span>    <span class="Statement">return</span> <span class="Type">forall</span>(expr <span class="Type">in</span> <span class="Identifier">domain</span>(p) <span class="Type">|</span> <span class="Identifier">fct</span>(expr) <span class="Type">!=</span> <span class="Constant">"BoxArrow"</span> <span class="Type">||</span> <span class="Type">!</span><a class="Identifier code-proc-link" href="#da-489">e_in_u</a>(expr));
<span id="L487" class="LineNr"> 487 </span>  };
<span id="L488" class="LineNr"> 488 </span>
<span id="L489" class="LineNr"> 489 </span>    <span class="Identifier">e_in_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L490" class="LineNr"> 490 </span>      x <span class="Statement">:=</span> <span class="Identifier">args</span>(expr)[<span class="Constant">1</span>]; <span class="Comment">// like an n[i]['o']</span>
<span id="L491" class="LineNr"> 491 </span>      y <span class="Statement">:=</span> <span class="Identifier">args</span>(expr)[<span class="Constant">2</span>];
<span id="L492" class="LineNr"> 492 </span>      <span class="Statement">return</span> y <span class="Type">in</span> <span class="Identifier">domain</span>(u) <span class="Type">&amp;&amp;</span> <span class="Type">!</span>(x <span class="Type">in</span> o) <span class="Type">&amp;&amp;</span> p[expr] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-197">parents</a>(x);
<span id="L493" class="LineNr"> 493 </span>    };
<span id="L494" class="LineNr"> 494 </span>
<span id="L495" class="LineNr"> 495 </span><span class="Comment Heading">// Semantics of Mental Content </span>
<span id="L496" class="LineNr"> 496 </span><span class="Comment Heading">// ===========================</span>
<span id="L497" class="LineNr"> 497 </span>
<span id="L498" class="LineNr"> 498 </span>  <span class="Comment">/* Takes a set of pairs [w, b] and returns a function from possible worlds </span>
<span id="L499" class="LineNr"> 499 </span><span class="Comment">     to extensions / referents. </span>
<span id="L500" class="LineNr"> 500 </span><span class="Comment">       See: <a href="https://plato.stanford.edu/entries/two-dimensional-semantics/" target="_blank">https://plato.stanford.edu/entries/two-dimensional-semantics/</a> </span>
<span id="L501" class="LineNr"> 501 </span><span class="Comment">  */</span>
<span id="L502" class="LineNr"> 502 </span>  <span class="Identifier">intension</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(poss_wbs) {
<span id="L503" class="LineNr"> 503 </span>    <span class="Statement">return</span> { [wb[<span class="Constant">1</span>], <a class="Identifier code-proc-link" href="#da-538">ref</a>(wb[<span class="Constant">1</span>], wb[<span class="Constant">2</span>])] <span class="Type">:</span> wb <span class="Type">in</span> poss_wbs };
<span id="L504" class="LineNr"> 504 </span>  };
<span id="L505" class="LineNr"> 505 </span>
<span id="L506" class="LineNr"> 506 </span>  <span class="Comment Heading">/* Reference</span>
<span id="L507" class="LineNr"> 507 </span><span class="Comment Heading">     ---------</span>
<span id="L508" class="LineNr"> 508 </span><span class="Comment">     Reference function from causal markov model of world w and brain b </span>
<span id="L509" class="LineNr"> 509 </span><span class="Comment">     to a function which takes a brain and returns its set of truth-makers if </span>
<span id="L510" class="LineNr"> 510 </span><span class="Comment">     any, i.e. a set of poss events in the world or equivalently, functions</span>
<span id="L511" class="LineNr"> 511 </span><span class="Comment">     assigning values to vars in the world. </span>
<span id="L512" class="LineNr"> 512 </span>
<span id="L513" class="LineNr"> 513 </span><span class="Comment">     There are a few ways that reference is grounded.</span>
<span id="L514" class="LineNr"> 514 </span>
<span id="L515" class="LineNr"> 515 </span><span class="Comment">       1. Input variable states refer to the brain states implementing them.</span>
<span id="L516" class="LineNr"> 516 </span><span class="Comment">          You can think of their content as something like "this sense datum</span>
<span id="L517" class="LineNr"> 517 </span><span class="Comment">          is occurring" or perhaps even as just the pure demonstrative "this".</span>
<span id="L518" class="LineNr"> 518 </span><span class="Comment">          It seems intuitive that these states can represent themselves since</span>
<span id="L519" class="LineNr"> 519 </span><span class="Comment">          everything trivially carries information about itself. </span>
<span id="L520" class="LineNr"> 520 </span>
<span id="L521" class="LineNr"> 521 </span><span class="Comment">       2. The meanings of logical connectives (e.g. And, Or, Implies) and the </span>
<span id="L522" class="LineNr"> 522 </span><span class="Comment">          causal connective BoxArrow are grounded by the axioms that define </span>
<span id="L523" class="LineNr"> 523 </span><span class="Comment">          them. These meanings are enforced by punishing any attributions of </span>
<span id="L524" class="LineNr"> 524 </span><span class="Comment">          these connectives into credences that violate their axioms. See </span>
<span id="L525" class="LineNr"> 525 </span><span class="Comment">          incoherence. Cf inferential / conceptual role semantics:</span>
<span id="L526" class="LineNr"> 526 </span><span class="Comment">            <a href="https://plato.stanford.edu/entries/content-narrow/#rol" target="_blank">https://plato.stanford.edu/entries/content-narrow/#rol</a>  </span>
<span id="L527" class="LineNr"> 527 </span>
<span id="L528" class="LineNr"> 528 </span><span class="Comment">       3. The rest can be understood as a kind of ramsification. Other posited </span>
<span id="L529" class="LineNr"> 529 </span><span class="Comment">          objects/events, predicates and relations refer to those things</span>
<span id="L530" class="LineNr"> 530 </span><span class="Comment">          (if any) which play the roles posited for them. </span>
<span id="L531" class="LineNr"> 531 </span><span class="Comment">             <a href="https://en.wikipedia.org/wiki/Ramsey%E2%80%93Lewis_method" target="_blank">https://en.wikipedia.org/wiki/Ramsey%E2%80%93Lewis_method</a></span>
<span id="L532" class="LineNr"> 532 </span><span class="Comment">             <a href="http://www.jimpryor.net/teaching/courses/mind/notes/ramseylewis.html" target="_blank">http://www.jimpryor.net/teaching/courses/mind/notes/ramseylewis.html</a></span>
<span id="L533" class="LineNr"> 533 </span><span class="Comment">          We soften the requirement of strict truth by scoring by squared error.</span>
<span id="L534" class="LineNr"> 534 </span><span class="Comment">          This amounts to a principle of charity favoring interpretations</span>
<span id="L535" class="LineNr"> 535 </span><span class="Comment">          that make more beliefs turn out to be true (while also adhering to</span>
<span id="L536" class="LineNr"> 536 </span><span class="Comment">          the constraints above).  </span>
<span id="L537" class="LineNr"> 537 </span><span class="Comment">  */</span>
<span id="L538" class="LineNr"> 538 <a title="1.3.2" class="back_to_li" href="#t-1-3-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">ref</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b) {
<span id="L539" class="LineNr"> 539 </span>    <span class="Statement">if</span> (cached_ref <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L540" class="LineNr"> 540 </span>      cached_ref <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-545">compute_ref</a>(w, b);
<span id="L541" class="LineNr"> 541 </span>    }
<span id="L542" class="LineNr"> 542 </span>    <span class="Statement">return</span> cached_ref;
<span id="L543" class="LineNr"> 543 </span>  };
<span id="L544" class="LineNr"> 544 </span>
<span id="L545" class="LineNr"> 545 </span>  <span class="Identifier">compute_ref</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(w, b) {
<span id="L546" class="LineNr"> 546 </span>    <span class="Comment">/* Base expressions are strings or predicates. We'll build composite </span>
<span id="L547" class="LineNr"> 547 </span><span class="Comment">       expressions together with corresponding references out of combinations of</span>
<span id="L548" class="LineNr"> 548 </span><span class="Comment">       these and logical / causal connectives. */</span>
<span id="L549" class="LineNr"> 549 </span>    base_exprs <span class="Statement">:=</span> { [expr, e_arity] <span class="Type">:</span> [expr, e_arity] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-568">str_exprs</a>() <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-573">preds</a>()
<span id="L550" class="LineNr"> 550 </span>                                    <span class="Type">|</span> <span class="Type">!</span>(p[expr] <span class="Type">in</span> i) };
<span id="L551" class="LineNr"> 551 </span>    pbers <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-580">poss_base_expr_refs</a>(w, base_exprs);
<span id="L552" class="LineNr"> 552 </span>    poss_atom_refs <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#da-560">i_ref</a>(w, b) <span class="Type">+</span> base_ref
<span id="L553" class="LineNr"> 553 </span>                        <span class="Type">:</span> base_ref <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-587">poss_base_refs</a>(w, b, pbers) };
<span id="L554" class="LineNr"> 554 </span>    poss_refs <span class="Statement">:=</span> [ <a class="Identifier code-proc-link" href="#da-604">full_ref</a>(w, b, poss_atom_ref)
<span id="L555" class="LineNr"> 555 </span>                   <span class="Type">:</span> poss_atom_ref <span class="Type">in</span> poss_atom_refs ];
<span id="L556" class="LineNr"> 556 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(poss_refs, less_sq_err)[<span class="Constant">1</span>];
<span id="L557" class="LineNr"> 557 </span>  };
<span id="L558" class="LineNr"> 558 </span>
<span id="L559" class="LineNr"> 559 </span>    <span class="Comment">/* Input vars refer to their own brain-state implementors. */</span>
<span id="L560" class="LineNr"> 560 <a title="1.3.2.2.1" class="back_to_li" href="#t-1-3-2-2-1"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">i_ref</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b) {
<span id="L561" class="LineNr"> 561 </span>      <span class="Statement">return</span> {
<span id="L562" class="LineNr"> 562 </span>        [b_event, <span class="Identifier">compatible_complete_states</span>(b_event, w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>())]
<span id="L563" class="LineNr"> 563 </span>        <span class="Type">:</span> b_event <span class="Type">in</span> b.<a class="Identifier code-proc-link" href="#cmm-102">actual_sync_events</a>()
<span id="L564" class="LineNr"> 564 </span>        <span class="Type">|</span> <span class="Type">#</span><a class="Identifier code-proc-link" href="#da-414">lf_cm</a>(b, b_event) <span class="Type">==</span> <span class="Constant">1</span> <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#da-414">lf_cm</a>(b, b_event) <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-2009">poss_i_events</a>()
<span id="L565" class="LineNr"> 565 </span>      };
<span id="L566" class="LineNr"> 566 </span>    };
<span id="L567" class="LineNr"> 567 </span>
<span id="L568" class="LineNr"><a href="#tda-475" data-file="test_decision_algorithm" title="test_str_exprs" class="checkmark">&#10004;</a> 568 </span>    <span class="Identifier">str_exprs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L569" class="LineNr"> 569 </span>      <span class="Statement">return</span> { [expr, <span class="Constant">0</span>] <span class="Type">:</span> expr <span class="Type">in</span> <span class="Identifier">domain</span>(p)
<span id="L570" class="LineNr"> 570 </span>                         <span class="Type">|</span> <span class="Type">!</span>(p[expr] <span class="Type">in</span> i) <span class="Type">&amp;&amp;</span> <span class="Identifier">isString</span>(expr) };
<span id="L571" class="LineNr"> 571 </span>    };
<span id="L572" class="LineNr"> 572 </span>
<span id="L573" class="LineNr"><a href="#tda-487" data-file="test_decision_algorithm" title="test_preds" class="checkmark">&#10004;</a> 573 </span>    <span class="Identifier">preds</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L574" class="LineNr"> 574 </span>      <span class="Statement">return</span> { [<span class="Identifier">fct</span>(expr), <a class="Identifier code-proc-link" href="#l-245">arity</a>(expr)]
<span id="L575" class="LineNr"> 575 </span>               <span class="Type">:</span> expr <span class="Type">in</span> <span class="Identifier">domain</span>(p)
<span id="L576" class="LineNr"> 576 </span>               <span class="Type">|</span> <span class="Identifier">isTerm</span>(expr) <span class="Type">&amp;&amp;</span> <span class="Type">!</span>(<span class="Identifier">fct</span>(expr) <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-72">connectives</a>()) };
<span id="L577" class="LineNr"> 577 </span>    };
<span id="L578" class="LineNr"> 578 </span>
<span id="L579" class="LineNr"> 579 </span>    <span class="Comment">// Set of choices of poss assignments of world w states/sets/tuples to expr</span>
<span id="L580" class="LineNr"><a href="#tda-519" data-file="test_decision_algorithm" title="test_poss_base_expr_refs" class="checkmark">&#10004;</a> 580 <a title="1.3.2.2" class="back_to_li" href="#t-1-3-2-2"><i class="fas fa-list-ol"></i></a><a title="1.3.2.2.2" class="back_to_li" href="#t-1-3-2-2-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">poss_base_expr_refs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, base_exprs) {
<span id="L581" class="LineNr"> 581 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {expr} <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#l-55">range_for_arity</a>(e_arity, w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>())
<span id="L582" class="LineNr"> 582 </span>                       <span class="Type">:</span> [expr, e_arity] <span class="Type">in</span> base_exprs });
<span id="L583" class="LineNr"> 583 </span>    };
<span id="L584" class="LineNr"> 584 </span>
<span id="L585" class="LineNr"> 585 </span>    <span class="Comment">/* Use poss_base_expr_refs to construct poss reference functions assigning</span>
<span id="L586" class="LineNr"> 586 </span><span class="Comment">       reference to brain events rather than exprs.  */</span>
<span id="L587" class="LineNr"> 587 </span>    <span class="Identifier">poss_base_refs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, pbers) {
<span id="L588" class="LineNr"> 588 </span>      <span class="Statement">return</span> {
<span id="L589" class="LineNr"> 589 </span>        <span class="Type">+/</span> {
<span id="L590" class="LineNr"> 590 </span>          <span class="Comment">// For each brain event that represents the given expr</span>
<span id="L591" class="LineNr"> 591 </span>          <span class="Comment">// Assign to it the reference of that expr according to pber</span>
<span id="L592" class="LineNr"> 592 </span>          { [b_event, pber[expr]] <span class="Type">:</span> b_event <span class="Type">in</span> b.<a class="Identifier code-proc-link" href="#cmm-102">actual_sync_events</a>()
<span id="L593" class="LineNr"> 593 </span>                                  <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-430">lf_cm_p_inv</a>(b, b_event) <span class="Type">==</span> expr }
<span id="L594" class="LineNr"> 594 </span>          <span class="Comment">// Do that for each base expr and collect them into a single function</span>
<span id="L595" class="LineNr"> 595 </span>          <span class="Type">:</span> expr <span class="Type">in</span> <span class="Identifier">domain</span>(pber) }
<span id="L596" class="LineNr"> 596 </span>        <span class="Comment">// for each poss base expr reference func</span>
<span id="L597" class="LineNr"> 597 </span>        <span class="Type">:</span> pber <span class="Type">in</span> pbers
<span id="L598" class="LineNr"> 598 </span>      };
<span id="L599" class="LineNr"> 599 </span>    };
<span id="L600" class="LineNr"> 600 </span>
<span id="L601" class="LineNr"> 601 </span>    <span class="Comment">// Full Reference</span>
<span id="L602" class="LineNr"> 602 </span>    <span class="Comment">// Much of the below builds on fairly standard first-order structures or </span>
<span id="L603" class="LineNr"> 603 </span>    <span class="Comment">// models, e.g., <a href="https://en.wikipedia.org/wiki/First-order_logic#Semantics" target="_blank">https://en.wikipedia.org/wiki/First-order_logic#Semantics</a> </span>
<span id="L604" class="LineNr"> 604 <a title="1.3.2.3" class="back_to_li" href="#t-1-3-2-3"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">full_ref</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, atom_ref) {
<span id="L605" class="LineNr"> 605 </span>      <span class="Comment">/* Full ref maps each brain event which implements a credence to the </span>
<span id="L606" class="LineNr"> 606 </span><span class="Comment">         result of reducing the reference of the corresponding expression. */</span>
<span id="L607" class="LineNr"> 607 </span>      <span class="Statement">return</span> { [b_event, <a class="Identifier code-proc-link" href="#da-626">rr</a>(
<span id="L608" class="LineNr"> 608 </span>                            <span class="Identifier">lf_cm_p_inv</span>(b, b_event), <span class="Comment">// expr it is credence in </span>
<span id="L609" class="LineNr"> 609 </span>                            [ w, b, atom_ref,
<span id="L610" class="LineNr"> 610 </span>                              <span class="Comment">// vars are all the same time so just take 1st</span>
<span id="L611" class="LineNr"> 611 </span>                              <span class="Identifier">var_time</span>(<span class="Identifier">first</span>(<span class="Identifier">first</span>(b_event))),
<span id="L612" class="LineNr"> 612 </span>                              {} ] <span class="Comment">// empty context</span>
<span id="L613" class="LineNr"> 613 </span>                         ) ]
<span id="L614" class="LineNr"> 614 </span>               <span class="Type">:</span> b_event <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-750">actual_p_events</a>(b) };
<span id="L615" class="LineNr"> 615 </span>    }; <span class="Comment">// end full_ref</span>
<span id="L616" class="LineNr"> 616 </span>
<span id="L617" class="LineNr"> 617 </span>      <span class="Comment">/* Reduce reference, takes an expression and an array of further</span>
<span id="L618" class="LineNr"> 618 </span><span class="Comment">         parameters consisting of a world, brain, atomic reference function, </span>
<span id="L619" class="LineNr"> 619 </span><span class="Comment">         time and context and returns a set of truth-making w events or the set </span>
<span id="L620" class="LineNr"> 620 </span><span class="Comment">         of w events the expression is true in. The set of truthmakers is our </span>
<span id="L621" class="LineNr"> 621 </span><span class="Comment">         way of enforcing a canonical boolean algebraic form. The different </span>
<span id="L622" class="LineNr"> 622 </span><span class="Comment">         elements act as disjuncts of events and combining assignments of vals </span>
<span id="L623" class="LineNr"> 623 </span><span class="Comment">         to vars into a map acts as conjunction. It may seem counterintuitive </span>
<span id="L624" class="LineNr"> 624 </span><span class="Comment">         and take some getting used to but we use this canonical form even when</span>
<span id="L625" class="LineNr"> 625 </span><span class="Comment">         there there is only one disjunct. */</span>
<span id="L626" class="LineNr"><a href="#tda-553" data-file="test_decision_algorithm" title="test_rr" class="checkmark">&#10004;</a> 626 </span>      <span class="Identifier">rr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr, arr) {
<span id="L627" class="LineNr"> 627 </span>        w <span class="Statement">:=</span> arr[<span class="Constant">1</span>]; b <span class="Statement">:=</span> arr[<span class="Constant">2</span>]; atom_ref <span class="Statement">:=</span> arr[<span class="Constant">3</span>]; ti <span class="Statement">:=</span> arr[<span class="Constant">4</span>];
<span id="L628" class="LineNr"> 628 </span>        context <span class="Statement">:=</span> arr[<span class="Constant">5</span>];  <span class="Comment">// context is for binding of variables, see Exists</span>
<span id="L629" class="LineNr"> 629 </span>        <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr)) {
<span id="L630" class="LineNr"> 630 </span>          <span class="Statement">if</span> (<span class="Type">#</span><span class="Identifier">args</span>(expr) <span class="Type">&gt;=</span> <span class="Constant">1</span>) { a1 <span class="Statement">:=</span> <span class="Identifier">args</span>(expr)[<span class="Constant">1</span>]; }
<span id="L631" class="LineNr"> 631 </span>          <span class="Statement">if</span> (<span class="Type">#</span><span class="Identifier">args</span>(expr) <span class="Type">&gt;=</span> <span class="Constant">2</span>) { a2 <span class="Statement">:=</span> <span class="Identifier">args</span>(expr)[<span class="Constant">2</span>]; }
<span id="L632" class="LineNr"> 632 </span>        }
<span id="L633" class="LineNr"> 633 </span>        <span class="Statement">switch</span> {
<span id="L634" class="LineNr"> 634 </span>          <span class="Statement">case</span> expr <span class="Type">in</span> <span class="Identifier">domain</span>(context) <span class="Type">:</span>
<span id="L635" class="LineNr"> 635 </span>            <span class="Statement">return</span> context[expr];
<span id="L636" class="LineNr"> 636 </span>          <span class="Statement">case</span> p[expr] <span class="Type">in</span> i <span class="Type">:</span>
<span id="L637" class="LineNr"> 637 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-352">compatible_complete_states</a>(
<span id="L638" class="LineNr"> 638 </span>                     <span class="Identifier">first</span>({ b_event <span class="Type">:</span> b_event <span class="Type">in</span> <span class="Identifier">pow</span>(b.a[ti])
<span id="L639" class="LineNr"> 639 </span>                                     <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-430">lf_cm_p_inv</a>(b, b_event) <span class="Type">==</span> expr }),
<span id="L640" class="LineNr"> 640 </span>                     w.<span class="Identifier">cm</span>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>()
<span id="L641" class="LineNr"> 641 </span>                   );
<span id="L642" class="LineNr"> 642 </span>          <span class="Statement">case</span> <span class="Identifier">isString</span>(expr) <span class="Type">:</span>
<span id="L643" class="LineNr"> 643 </span>            <span class="Statement">return</span> atom_ref[expr];
<span id="L644" class="LineNr"> 644 </span>          <span class="Statement">case</span> <span class="Identifier">isSet</span>(expr) <span class="Type">:</span>
<span id="L645" class="LineNr"> 645 </span>            <span class="Comment">/* This shouldn't happen but just in case, return the set.</span>
<span id="L646" class="LineNr"> 646 </span><span class="Comment">               Maybe throw an error instead? Or it's probably just rr(rr(.. */</span>
<span id="L647" class="LineNr"> 647 </span>            <span class="Identifier">print</span>(<span class="Constant">'Warning: Expected an expr but received a set: '</span> <span class="Type">+</span> expr);
<span id="L648" class="LineNr"> 648 </span>            <span class="Statement">return</span> expr;
<span id="L649" class="LineNr"> 649 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'At_t'</span> <span class="Type">:</span>
<span id="L650" class="LineNr"> 650 </span>            <span class="Statement">if</span> (ti <span class="Type">+</span> a2 <span class="Type">&gt;=</span> <span class="Constant">0</span>) { <span class="Comment">// a2 should already be negative</span>
<span id="L651" class="LineNr"> 651 </span>              <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(a1, [w, b, atom_ref, ti <span class="Type">+</span> a2, context]);
<span id="L652" class="LineNr"> 652 </span>            } <span class="Statement">else</span> {
<span id="L653" class="LineNr"> 653 </span>              <span class="Statement">return</span> {};
<span id="L654" class="LineNr"> 654 </span>            }
<span id="L655" class="LineNr"> 655 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'And'</span> <span class="Type">:</span>
<span id="L656" class="LineNr"> 656 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(a1, arr) <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(a2, arr);
<span id="L657" class="LineNr"> 657 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'Or'</span> <span class="Type">:</span>
<span id="L658" class="LineNr"> 658 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(a1, arr) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(a2, arr);
<span id="L659" class="LineNr"> 659 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'Not'</span> <span class="Type">:</span>
<span id="L660" class="LineNr"> 660 </span>            <span class="Statement">return</span> w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() <span class="Type">-</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(a1, arr);
<span id="L661" class="LineNr"> 661 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'Implies'</span> <span class="Type">:</span>
<span id="L662" class="LineNr"> 662 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>( <span class="Identifier">Or</span>(<span class="Identifier">Not</span>(a1), a2), arr );
<span id="L663" class="LineNr"> 663 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'Forall'</span> <span class="Type">:</span>
<span id="L664" class="LineNr"> 664 </span>            <span class="Comment">// Vx Px = ~Ex ~Px</span>
<span id="L665" class="LineNr"> 665 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">Not</span>(<span class="Identifier">Exists</span>(a1, <span class="Identifier">Not</span>(a2))), arr);
<span id="L666" class="LineNr"> 666 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'Exists'</span> <span class="Type">:</span>
<span id="L667" class="LineNr"> 667 </span>            <span class="Comment">// Set of truth-makers for a2 when any {w_event} is subbed for a1</span>
<span id="L668" class="LineNr"> 668 </span>            <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-626">rr</a>(a2, [ w, b, atom_ref, ti,
<span id="L669" class="LineNr"> 669 </span>                                 context <span class="Type">+</span> { [a1, {w_event}] } ])
<span id="L670" class="LineNr"> 670 </span>                        <span class="Type">:</span> w_event <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-55">range_for_arity</a>(<span class="Constant">0</span>, w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>()) };
<span id="L671" class="LineNr"> 671 </span>          <span class="Statement">case</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'BoxArrow'</span> <span class="Type">:</span> <span class="Comment">// A []-&gt; B, subjunctive conditional</span>
<span id="L672" class="LineNr"> 672 </span>            <span class="Comment">// Antecedent</span>
<span id="L673" class="LineNr"> 673 </span>            <span class="Statement">if</span> (<span class="Identifier">isSet</span>(a1)) {
<span id="L674" class="LineNr"> 674 </span>              ant <span class="Statement">:=</span> a1;
<span id="L675" class="LineNr"> 675 </span>            } <span class="Statement">else</span> {
<span id="L676" class="LineNr"> 676 </span>              ant <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-362">states2events</a>(<a class="Identifier code-proc-link" href="#da-626">rr</a>(a1, arr));
<span id="L677" class="LineNr"> 677 </span>            }
<span id="L678" class="LineNr"> 678 </span>            <span class="Comment">// Consequent</span>
<span id="L679" class="LineNr"> 679 </span>            <span class="Statement">if</span> (<span class="Identifier">isSet</span>(a2)) {
<span id="L680" class="LineNr"> 680 </span>              cons <span class="Statement">:=</span> a2;
<span id="L681" class="LineNr"> 681 </span>            } <span class="Statement">else</span> {
<span id="L682" class="LineNr"> 682 </span>              cons <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-362">states2events</a>(<a class="Identifier code-proc-link" href="#da-626">rr</a>(a2, arr));
<span id="L683" class="LineNr"> 683 </span>            }
<span id="L684" class="LineNr"> 684 </span>            <span class="Statement">if</span> (<span class="Type">#</span>ant <span class="Type">&gt;</span> <span class="Constant">1</span>) { <span class="Comment">// Antecedent has disjuncts.</span>
<span id="L685" class="LineNr"> 685 </span>              <span class="Comment">// This or that causes the effect if this does or that does.</span>
<span id="L686" class="LineNr"> 686 </span>              <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">BoxArrow</span>(disjunct, cons), arr) <span class="Type">:</span> disjunct <span class="Type">in</span> ant };
<span id="L687" class="LineNr"> 687 </span>            } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Type">#</span>ant <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L688" class="LineNr"> 688 </span>              <span class="Statement">if</span> (<span class="Type">#</span>cons <span class="Type">&gt;</span> <span class="Constant">1</span>) {
<span id="L689" class="LineNr"> 689 </span>                <span class="Comment">// A thing causes this or that if it causes this or causes that.</span>
<span id="L690" class="LineNr"> 690 </span>                <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">BoxArrow</span>(ant, disjunct), arr) <span class="Type">:</span> disjunct <span class="Type">in</span> cons };
<span id="L691" class="LineNr"> 691 </span>              } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Type">#</span>cons <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L692" class="LineNr"> 692 </span>                <span class="Statement">if</span> ( w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#cmm-108">response</a>( <span class="Identifier">domain</span>(cons[<span class="Constant">1</span>]), ant[<span class="Constant">1</span>] ) <span class="Type">==</span> cons[<span class="Constant">1</span>] ) {
<span id="L693" class="LineNr"> 693 </span>                  <span class="Comment">/* If this aspect of the causal model is true, it's true in</span>
<span id="L694" class="LineNr"> 694 </span><span class="Comment">                     all states. Fire causes smoke can be true even in a     </span>
<span id="L695" class="LineNr"> 695 </span><span class="Comment">                     possible world where all fire is prevented. A more </span>
<span id="L696" class="LineNr"> 696 </span><span class="Comment">                     expressive language could substitute a more meaningful </span>
<span id="L697" class="LineNr"> 697 </span><span class="Comment">                     truthmaker here. */</span>
<span id="L698" class="LineNr"> 698 </span>                  <span class="Statement">return</span> w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>();
<span id="L699" class="LineNr"> 699 </span>                } <span class="Statement">else</span> {
<span id="L700" class="LineNr"> 700 </span>                  <span class="Statement">return</span> {};
<span id="L701" class="LineNr"> 701 </span>                }
<span id="L702" class="LineNr"> 702 </span>              } <span class="Statement">else</span> {
<span id="L703" class="LineNr"> 703 </span>                <span class="Comment">// Trivially true because everything causes the empty effect? </span>
<span id="L704" class="LineNr"> 704 </span>                <span class="Statement">return</span> w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>();
<span id="L705" class="LineNr"> 705 </span>              }
<span id="L706" class="LineNr"> 706 </span>            } <span class="Statement">else</span> {
<span id="L707" class="LineNr"> 707 </span>              <span class="Statement">return</span> {}; <span class="Comment">// Nothing is caused by nothingness?</span>
<span id="L708" class="LineNr"> 708 </span>            }
<span id="L709" class="LineNr"> 709 </span>            <span class="Statement">return</span> <span class="Constant">om</span>;
<span id="L710" class="LineNr"> 710 </span>          <span class="Statement">default</span> <span class="Type">:</span> <span class="Comment">// Predicate or Relation</span>
<span id="L711" class="LineNr"> 711 </span>            tuple <span class="Statement">:=</span> [<a class="Identifier code-proc-link" href="#da-626">rr</a>(arg, arr) <span class="Type">:</span> arg <span class="Type">in</span> <span class="Identifier">args</span>(expr)];
<span id="L712" class="LineNr"> 712 </span>            <span class="Statement">if</span> (tuple <span class="Type">in</span> atom_ref[<span class="Identifier">fct</span>(expr)]) {
<span id="L713" class="LineNr"> 713 </span>              <span class="Comment">// If a predication is true, it's true in all states.</span>
<span id="L714" class="LineNr"> 714 </span>              <span class="Statement">return</span> w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>();
<span id="L715" class="LineNr"> 715 </span>            } <span class="Statement">else</span> {
<span id="L716" class="LineNr"> 716 </span>              <span class="Statement">return</span> {};
<span id="L717" class="LineNr"> 717 </span>            }
<span id="L718" class="LineNr"> 718 </span>        } <span class="Comment">// end switch</span>
<span id="L719" class="LineNr"> 719 </span>      }; <span class="Comment">// end rr</span>
<span id="L720" class="LineNr"> 720 </span>
<span id="L721" class="LineNr"> 721 <a title="1.3.2.2.3.1" class="back_to_li" href="#t-1-3-2-2-3-1"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">less_sq_err</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, ref_1, ref_2) {
<span id="L722" class="LineNr"> 722 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-725">sq_err</a>(w, b, ref_1) <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#da-725">sq_err</a>(w, b, ref_2);
<span id="L723" class="LineNr"> 723 </span>    };
<span id="L724" class="LineNr"> 724 </span>
<span id="L725" class="LineNr"><a href="#tda-652" data-file="test_decision_algorithm" title="test_sq_err" class="checkmark">&#10004;</a> 725 </span>    <span class="Identifier">sq_err</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, ref_i) {
<span id="L726" class="LineNr"> 726 </span>      <span class="Statement">return</span> <span class="Type">+/</span> {
<span id="L727" class="LineNr"> 727 </span>        ( <span class="Identifier">true_p</span>(w, ref_i, b_event) <span class="Type">-</span> <span class="Identifier">first</span>(<span class="Identifier">range</span>(<a class="Identifier code-proc-link" href="#da-414">lf_cm</a>(b, b_event))) ) <span class="Type">**</span> <span class="Constant">2</span>
<span id="L728" class="LineNr"> 728 </span>        <span class="Type">:</span> b_event <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-750">actual_p_events</a>(b)
<span id="L729" class="LineNr"> 729 </span>      };
<span id="L730" class="LineNr"> 730 </span>    };
<span id="L731" class="LineNr"> 731 </span>
<span id="L732" class="LineNr"><a href="#tda-631" data-file="test_decision_algorithm" title="test_true_p" class="checkmark">&#10004;</a> 732 </span>    <span class="Identifier">true_p</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, ref_i, b_event) {
<span id="L733" class="LineNr"> 733 </span>      <span class="Statement">if</span> (w.<a class="Identifier code-proc-link" href="#cmm-96">actual_state</a>() <span class="Type">in</span> ref_i[b_event]) {
<span id="L734" class="LineNr"> 734 </span>        <span class="Statement">return</span> <span class="Constant">1</span>;
<span id="L735" class="LineNr"> 735 </span>      } <span class="Statement">else</span> {
<span id="L736" class="LineNr"> 736 </span>        <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L737" class="LineNr"> 737 </span>      }
<span id="L738" class="LineNr"> 738 </span>    };
<span id="L739" class="LineNr"> 739 </span>
<span id="L740" class="LineNr"> 740 </span>  <span class="Comment">// Takes an expression (in a world, brain and time) and returns its referent.</span>
<span id="L741" class="LineNr"><a href="#tda-681" data-file="test_decision_algorithm" title="test_ref_expr" class="checkmark">&#10004;</a> 741 </span>  <span class="Identifier">ref_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, expr) {
<span id="L742" class="LineNr"> 742 </span>    p_var <span class="Statement">:=</span> p[expr];
<span id="L743" class="LineNr"> 743 </span>    ds <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-262">f</a>(b)[<a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b.a[t_i])]; <span class="Comment">// decision state</span>
<span id="L744" class="LineNr"> 744 </span>    p_event <span class="Statement">:=</span> { [p_var, ds[p_var]] };
<span id="L745" class="LineNr"> 745 </span>    b_event <span class="Statement">:=</span> <span class="Identifier">first</span>( <a class="Identifier code-proc-link" href="#da-407">lf_inv_at</a>(b, t_i)[p_event] );
<span id="L746" class="LineNr"> 746 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-538">ref</a>(w, b)[b_event];
<span id="L747" class="LineNr"> 747 </span>  };
<span id="L748" class="LineNr"> 748 </span>
<span id="L749" class="LineNr"> 749 </span>  <span class="Comment">// Returns the brain events that implement a placement of probabibility.</span>
<span id="L750" class="LineNr"><a href="#tda-694" data-file="test_decision_algorithm" title="test_actual_p_events" class="checkmark">&#10004;</a> 750 </span>  <span class="Identifier">actual_p_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L751" class="LineNr"> 751 </span>    <span class="Statement">return</span> { b_event <span class="Type">:</span> b_event <span class="Type">in</span> b.<a class="Identifier code-proc-link" href="#cmm-102">actual_sync_events</a>()
<span id="L752" class="LineNr"> 752 </span>             <span class="Type">|</span>      <span class="Type">#</span><a class="Identifier code-proc-link" href="#da-419">lf_cm_vs</a>(b, b_event) <span class="Type">==</span> <span class="Constant">1</span> <span class="Type">&amp;&amp;</span>         <span class="Comment">// just one var</span>
<span id="L753" class="LineNr"> 753 </span>               <span class="Identifier">first</span>(<a class="Identifier code-proc-link" href="#da-419">lf_cm_vs</a>(b, b_event)) <span class="Type">in</span> <span class="Identifier">range</span>(p) }; <span class="Comment">// and it's a p_var</span>
<span id="L754" class="LineNr"> 754 </span>  };
<span id="L755" class="LineNr"> 755 </span>
<span id="L756" class="LineNr"> 756 </span>  <span class="Comment">/* Function from causal_markov_model b to a function from times to </span>
<span id="L757" class="LineNr"> 757 </span><span class="Comment">     probability states, i.e. assignments of values to range(p) + range(cp).</span>
<span id="L758" class="LineNr"> 758 </span><span class="Comment">     At each time, use f(b) to see what decision state it maps the </span>
<span id="L759" class="LineNr"> 759 </span><span class="Comment">     brain state to and collect the states for range(p) + range(cp). </span>
<span id="L760" class="LineNr"> 760 </span>
<span id="L761" class="LineNr"> 761 </span><span class="Comment">     Actual world b.a is a function from times to assignments of values to </span>
<span id="L762" class="LineNr"> 762 </span><span class="Comment">     variables at that time.</span>
<span id="L763" class="LineNr"> 763 </span><span class="Comment">        e.g. b.a := { [1, assign_time({ [y, true] : y in b.uv() }, 1)], ...} */</span>
<span id="L764" class="LineNr"><a href="#tda-704" data-file="test_decision_algorithm" title="test_prob_states" class="checkmark">&#10004;</a> 764 </span>  <span class="Identifier">prob_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L765" class="LineNr"> 765 </span>    <span class="Statement">return</span> { [ti, <a class="Identifier code-proc-link" href="#da-772">prob_states_t</a>(b, ti) ] <span class="Type">:</span> ti <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>b.n] };
<span id="L766" class="LineNr"> 766 </span>  };
<span id="L767" class="LineNr"> 767 </span>
<span id="L768" class="LineNr"> 768 </span>  <span class="Comment">/* Probability States at Time ti </span>
<span id="L769" class="LineNr"> 769 </span><span class="Comment">     Takes a brain b at a time ti and returns the decision state that is </span>
<span id="L770" class="LineNr"> 770 </span><span class="Comment">     implemented by that brain state but restricted to just the probability </span>
<span id="L771" class="LineNr"> 771 </span><span class="Comment">     variables.  */</span>
<span id="L772" class="LineNr"><a href="#tda-711" data-file="test_decision_algorithm" title="test_prob_states_t" class="checkmark">&#10004;</a> 772 </span>  <span class="Identifier">prob_states_t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, ti) {
<span id="L773" class="LineNr"> 773 </span>    bs <span class="Statement">:=</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b.a[ti]) <span class="Type">|</span> var <span class="Type">in</span> b.<a class="Identifier code-proc-link" href="#cmm-24">uv</a>() };
<span id="L774" class="LineNr"> 774 </span>    ds <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-262">f</a>(b)[bs];
<span id="L775" class="LineNr"> 775 </span>    <span class="Statement">return</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> ds <span class="Type">|</span> var <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-178">p_vars</a>() };
<span id="L776" class="LineNr"> 776 </span>  };
<span id="L777" class="LineNr"> 777 </span>
<span id="L778" class="LineNr"> 778 </span>
<span id="L779" class="LineNr"> 779 </span><span class="Comment Heading">// Utility / Evaluation Functions</span>
<span id="L780" class="LineNr"> 780 </span><span class="Comment Heading">// ==============================</span>
<span id="L781" class="LineNr"> 781 </span>
<span id="L782" class="LineNr"> 782 </span>  <span class="Comment">// Collect all utility/evaluation function vars with their output vars</span>
<span id="L783" class="LineNr"><a href="#tda-722" data-file="test_decision_algorithm" title="test_eo" class="checkmark">&#10004;</a> 783 </span>  <span class="Identifier">eo</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L784" class="LineNr"> 784 </span>    <span class="Statement">return</span> {[u, o]} <span class="Type">+</span> { [n_i[<span class="Constant">'e'</span>], n_i[<span class="Constant">'o'</span>]] <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L785" class="LineNr"> 785 </span>  };
<span id="L786" class="LineNr"> 786 </span>
<span id="L787" class="LineNr"> 787 </span>  <span class="Comment">/* Instrumental irrationality, including of evaluation as well as utility </span>
<span id="L788" class="LineNr"> 788 </span><span class="Comment">     functions. */</span>
<span id="L789" class="LineNr"><a href="#tda-731" data-file="test_decision_algorithm" title="test_instr_irrat" class="checkmark">&#10004;</a> 789 <a title="1.2.1.5" class="back_to_li" href="#t-1-2-1-5"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">instr_irrat</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b) {
<span id="L790" class="LineNr"> 790 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-796">e_dist</a>(w, b, ti) <span class="Type">:</span> ti <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>(b.n <span class="Type">-</span> <span class="Constant">1</span>)] } <span class="Type">/</span> (b.n <span class="Type">-</span> <span class="Constant">1</span>);
<span id="L791" class="LineNr"> 791 </span>  };
<span id="L792" class="LineNr"> 792 </span>
<span id="L793" class="LineNr"> 793 </span>    <span class="Comment">/* Takes a brain b and time ti and returns the distance between the actual </span>
<span id="L794" class="LineNr"> 794 </span><span class="Comment">       outputs and the optimal outputs according to the utility / evaluation </span>
<span id="L795" class="LineNr"> 795 </span><span class="Comment">       functions and []-&gt; beliefs.  */</span>
<span id="L796" class="LineNr"> 796 <a title="1.2.1.5.2" class="back_to_li" href="#t-1-2-1-5-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">e_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, ti) {
<span id="L797" class="LineNr"> 797 </span>      <span class="Comment">/* These are all weighted equally right now, but we may want to </span>
<span id="L798" class="LineNr"> 798 </span><span class="Comment">         consider different weights. Should first-order utility be treated </span>
<span id="L799" class="LineNr"> 799 </span><span class="Comment">         differently? What about highest order? Does complexity matter?  */</span>
<span id="L800" class="LineNr"> 800 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-804">e_i_dist</a>(w, b, ti, e_i, o_i) <span class="Type">:</span> [e_i, o_i] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-783">eo</a>() } <span class="Type">/</span> <span class="Type">#</span><a class="Identifier code-proc-link" href="#da-783">eo</a>();
<span id="L801" class="LineNr"> 801 </span>    }; <span class="Comment">// end e_dist</span>
<span id="L802" class="LineNr"> 802 </span>
<span id="L803" class="LineNr"> 803 </span>    <span class="Comment">// Similar to above but for a specific util/eval function and output vars</span>
<span id="L804" class="LineNr"> 804 <a title="1.2.1.5.3" class="back_to_li" href="#t-1-2-1-5-3"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">e_i_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, ti, e_i, o_i) {
<span id="L805" class="LineNr"> 805 </span>      poss_o_i_states <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(o_i, r);
<span id="L806" class="LineNr"> 806 </span>      actual_d_st0 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-262">f</a>(b)[ <a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b.a[ti]  ) ];
<span id="L807" class="LineNr"> 807 </span>      actual_d_st1 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-262">f</a>(b)[ <a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b.a[ti<span class="Type">+</span><span class="Constant">1</span>]) ];
<span id="L808" class="LineNr"> 808 </span>      actual_o_i_state <span class="Statement">:=</span> { [o_i_j, actual_d_st1[o_i_j]] <span class="Type">:</span> o_i_j <span class="Type">in</span> o_i };
<span id="L809" class="LineNr"> 809 </span>      sorted_o_i_states <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>( [x <span class="Type">:</span> x <span class="Type">in</span> poss_o_i_states],
<span id="L810" class="LineNr"> 810 </span>        <span class="Type">procedure</span>(x, y) {
<span id="L811" class="LineNr"> 811 </span>          <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-821">exp_u</a>(w, b, ti, actual_d_st0, e_i, x) <span class="Type">&gt;</span>
<span id="L812" class="LineNr"> 812 </span>                 <span class="Identifier">exp_u</span>(w, b, ti, actual_d_st0, e_i, y);
<span id="L813" class="LineNr"> 813 </span>        } );
<span id="L814" class="LineNr"> 814 </span>      ix <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-24">index_of</a>(actual_o_i_state, sorted_o_i_states);
<span id="L815" class="LineNr"> 815 </span>      <span class="Comment">/* Cardinal measures seem too easy to abuse so we convert them to an </span>
<span id="L816" class="LineNr"> 816 </span><span class="Comment">         ordinal measure. */</span>
<span id="L817" class="LineNr"> 817 </span>      <span class="Statement">return</span> ix <span class="Type">/</span> <span class="Type">#</span>sorted_o_i_states;
<span id="L818" class="LineNr"> 818 </span>    }; <span class="Comment">// end e_i_dist</span>
<span id="L819" class="LineNr"> 819 </span>
<span id="L820" class="LineNr"> 820 </span>    <span class="Comment">// Expected Utility</span>
<span id="L821" class="LineNr"> 821 <a title="1.2.1.5.4" class="back_to_li" href="#t-1-2-1-5-4"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">exp_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, ti, actual_d_st, e_i, o_i_state) {
<span id="L822" class="LineNr"> 822 </span>      <span class="Comment">/* Using our reference function, find an expression that refers to </span>
<span id="L823" class="LineNr"> 823 </span><span class="Comment">         the given output state. */</span>
<span id="L824" class="LineNr"> 824 </span>      o_expr_b_events <span class="Statement">:=</span> {
<span id="L825" class="LineNr"> 825 </span>        b_event <span class="Type">:</span> b_event <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-750">actual_p_events</a>(b)
<span id="L826" class="LineNr"> 826 </span>                <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-397">var_time</a>(<span class="Identifier">first</span>(b_event)) <span class="Type">==</span> ti <span class="Type">&amp;&amp;</span>
<span id="L827" class="LineNr"> 827 </span>                  <span class="Identifier">ref</span>(w, b)[b_event] <span class="Type">!=</span> <span class="Constant">om</span> <span class="Type">&amp;&amp;</span>
<span id="L828" class="LineNr"> 828 </span>                  <span class="Type">exists</span>(w_state <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-538">ref</a>(w, b)[b_event] <span class="Type">|</span>
<span id="L829" class="LineNr"> 829 </span>                    <span class="Type">exists</span>(b_ev <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-401">lf_inv</a>(b)[o_i_state] <span class="Type">|</span>
<span id="L830" class="LineNr"> 830 </span>                      <span class="Identifier">restricted_eq</span>(w_state, <a class="Identifier code-proc-link" href="#l-403">assign_time</a>(b_ev, ti<span class="Type">+</span><span class="Constant">1</span>))
<span id="L831" class="LineNr"> 831 </span>                    )
<span id="L832" class="LineNr"> 832 </span>                  )
<span id="L833" class="LineNr"> 833 </span>      };
<span id="L834" class="LineNr"> 834 </span>      <span class="Statement">assert</span>(o_expr_b_events <span class="Type">!=</span> {}, <span class="Constant">"No o_expr_b_events found"</span>);
<span id="L835" class="LineNr"> 835 </span>      o_expr <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-430">lf_cm_p_inv</a>(b, <span class="Identifier">first</span>(o_expr_b_events));
<span id="L836" class="LineNr"> 836 </span>      <span class="Comment">// Todo: Handle multiple exprs referring to o_i_state</span>
<span id="L837" class="LineNr"> 837 </span>      <span class="Comment">/* Is the above too indirect and complicated? There may be worries of </span>
<span id="L838" class="LineNr"> 838 </span><span class="Comment">         not capturing the correct mode of presentation? Could we "hardcode"</span>
<span id="L839" class="LineNr"> 839 </span><span class="Comment">         something into the language instead? Like with input vars or</span>
<span id="L840" class="LineNr"> 840 </span><span class="Comment">         memories using At_t. Or the simplest may be to allow it to overlap</span>
<span id="L841" class="LineNr"> 841 </span><span class="Comment">         with input vars. That is actually still allowed by the above. </span>
<span id="L842" class="LineNr"> 842 </span><span class="Comment">           Is this not so easy though since it needs to refer to a *future* o </span>
<span id="L843" class="LineNr"> 843 </span><span class="Comment">         state?</span>
<span id="L844" class="LineNr"> 844 </span>
<span id="L845" class="LineNr"> 845 </span><span class="Comment">         Add up the expectations of utility. Here we are interpreting our   </span>
<span id="L846" class="LineNr"> 846 </span><span class="Comment">         utility vars as additive values. U(x &amp; y) = U(x) + U(y). If, </span>
<span id="L847" class="LineNr"> 847 </span><span class="Comment">         however, there are exceptions, they can still be encoded by </span>
<span id="L848" class="LineNr"> 848 </span><span class="Comment">         having a util var associated with the conjunction. Then, if U(x)</span>
<span id="L849" class="LineNr"> 849 </span><span class="Comment">         and U(y) are still defined, you may need to be careful to encode </span>
<span id="L850" class="LineNr"> 850 </span><span class="Comment">         only the intended difference from additive in the conjunction </span>
<span id="L851" class="LineNr"> 851 </span><span class="Comment">         rather than doubly counting its full value. </span>
<span id="L852" class="LineNr"> 852 </span><span class="Comment">           Here, we are assuming the P(o []-&gt; u) beliefs reflect the agent's</span>
<span id="L853" class="LineNr"> 853 </span><span class="Comment">         judgment of overall utility. If the agent is poor at aggregating </span>
<span id="L854" class="LineNr"> 854 </span><span class="Comment">         utilities, their final judgment might come apart from these </span>
<span id="L855" class="LineNr"> 855 </span><span class="Comment">         credences. There may also be issues with the timing of these</span>
<span id="L856" class="LineNr"> 856 </span><span class="Comment">         and any aggregated judgments. While this may require much </span>
<span id="L857" class="LineNr"> 857 </span><span class="Comment">         technical work to thoroughly address, we hope it is at least </span>
<span id="L858" class="LineNr"> 858 </span><span class="Comment">         conceptually and philosophical clear what is to be done. */</span>
<span id="L859" class="LineNr"> 859 </span>      <span class="Statement">return</span> <span class="Type">+/</span> {  actual_d_st[ p[<span class="Identifier">BoxArrow</span>(o_expr, u_expr)] ] <span class="Comment">// P(o []-&gt; u)</span>
<span id="L860" class="LineNr"> 860 </span>                 <span class="Type">*</span> actual_d_st[e_i_j] <span class="Type">:</span> [u_expr, e_i_j] <span class="Type">in</span> e_i }; <span class="Comment">// * u</span>
<span id="L861" class="LineNr"> 861 </span>    }; <span class="Comment">// end exp_u</span>
<span id="L862" class="LineNr"> 862 </span>
<span id="L863" class="LineNr"> 863 </span><span class="Comment Heading">// Probabilistic Coherence </span>
<span id="L864" class="LineNr"> 864 </span><span class="Comment Heading">// =======================</span>
<span id="L865" class="LineNr"> 865 </span>
<span id="L866" class="LineNr"> 866 <a title="1.2.1.4" class="back_to_li" href="#t-1-2-1-4"><i class="fas fa-list-ol"></i></a><a title="1.2.1.6.2.2.2.3" class="back_to_li" href="#t-1-2-1-6-2-2-2-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">incoherence</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L867" class="LineNr"> 867 </span>    <span class="Comment">/* Synchronic irrationality</span>
<span id="L868" class="LineNr"> 868 </span><span class="Comment">       Avg of distances to the closest coherent probability distribution </span>
<span id="L869" class="LineNr"> 869 </span><span class="Comment">       at each time normalized by max distance. */</span>
<span id="L870" class="LineNr"> 870 </span>    sync_irrat <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>({ <a class="Identifier code-proc-link" href="#da-1116">p_dist</a>(b, ti) <span class="Type">/</span> <a class="Identifier code-proc-link" href="#da-883">max_p_dist</a>(b, ti) <span class="Type">:</span> ti <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>b.n] });
<span id="L871" class="LineNr"> 871 </span>    <span class="Comment">/* Diachronic irrationality</span>
<span id="L872" class="LineNr"> 872 </span><span class="Comment">       Probabilities either stay the same or get updated to be close to what</span>
<span id="L873" class="LineNr"> 873 </span><span class="Comment">       a (locally) ideally rational inference would result in.  */</span>
<span id="L874" class="LineNr"> 874 </span>    dia_irrat <span class="Statement">:=</span> <span class="Constant">1</span> <span class="Type">-</span> <a class="Identifier code-proc-link" href="#da-1923">p_conn_continuity</a>([ <a class="Identifier code-proc-link" href="#da-262">f</a>(b)[<a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b.a[ti])]
<span id="L875" class="LineNr"> 875 </span>                                         <span class="Type">:</span> ti <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>b.n] ]);
<span id="L876" class="LineNr"> 876 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>([sync_irrat, dia_irrat]);
<span id="L877" class="LineNr"> 877 </span>  };
<span id="L878" class="LineNr"> 878 </span>
<span id="L879" class="LineNr"> 879 </span>  <span class="Comment">/* Maximum Probability Distance </span>
<span id="L880" class="LineNr"> 880 </span><span class="Comment">     Find the probability distribution that is the farthest distance from the </span>
<span id="L881" class="LineNr"> 881 </span><span class="Comment">     given brain's probability distribution and return that distance.</span>
<span id="L882" class="LineNr"> 882 </span><span class="Comment">     This is used to normalize probability distance scores.  */</span>
<span id="L883" class="LineNr"><a href="#tda-819" data-file="test_decision_algorithm" title="test_max_p_dist" class="checkmark">&#10004;</a> 883 </span>  <span class="Identifier">max_p_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, ti) {
<span id="L884" class="LineNr"> 884 </span>    poss_p_states <span class="Statement">:=</span> [poss_p <span class="Type">:</span> poss_p <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(<a class="Identifier code-proc-link" href="#da-178">p_vars</a>(), r)];
<span id="L885" class="LineNr"> 885 </span>    p_states <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-772">prob_states_t</a>(b, ti);
<span id="L886" class="LineNr"> 886 </span>    farthest_pp <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(poss_p_states, <span class="Type">procedure</span>(pp1,pp2) {
<span id="L887" class="LineNr"> 887 </span>                               <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1275">prob_distance</a>(p, cp, p_states, pp1) <span class="Type">&gt;</span>
<span id="L888" class="LineNr"> 888 </span>                                      <span class="Identifier">prob_distance</span>(p, cp, p_states, pp2);
<span id="L889" class="LineNr"> 889 </span>                             })[<span class="Constant">1</span>];
<span id="L890" class="LineNr"> 890 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1275">prob_distance</a>(p, cp, p_states, farthest_pp);
<span id="L891" class="LineNr"> 891 </span>  };
<span id="L892" class="LineNr"> 892 </span>
<span id="L893" class="LineNr"> 893 </span>  <span class="Comment">/* Returns the set of possible causal models formed from the base variables</span>
<span id="L894" class="LineNr"> 894 </span><span class="Comment">     in the domain of p. */</span>
<span id="L895" class="LineNr"><a href="#tda-853" data-file="test_decision_algorithm" title="test_poss_cms" class="checkmark">&#10004;</a> 895 </span>  <span class="Identifier">poss_cms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L896" class="LineNr"> 896 </span>    base_vars <span class="Statement">:=</span> [ p[expr] <span class="Type">:</span> expr <span class="Type">in</span> <span class="Identifier">domain</span>(p) <span class="Type">|</span>
<span id="L897" class="LineNr"> 897 </span>                   <span class="Identifier">isString</span>(expr) <span class="Type">||</span> (<span class="Identifier">isTerm</span>(expr) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">'At_t'</span>) ];
<span id="L898" class="LineNr"> 898 </span>    vs <span class="Statement">:=</span> { v <span class="Type">:</span> v <span class="Type">in</span> base_vars };
<span id="L899" class="LineNr"> 899 </span>    orderings <span class="Statement">:=</span> <span class="Identifier">permutations</span>(base_vars);
<span id="L900" class="LineNr"> 900 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-903">poss_cms_from_l</a>(l, vs) <span class="Type">:</span> l <span class="Type">in</span> orderings };
<span id="L901" class="LineNr"> 901 </span>  };
<span id="L902" class="LineNr"> 902 </span>
<span id="L903" class="LineNr"><a href="#tda-875" data-file="test_decision_algorithm" title="test_poss_cms_from_l" class="checkmark">&#10004;</a> 903 </span>    <span class="Identifier">poss_cms_from_l</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l, vs) { <span class="Comment">// l is an ordering (list)</span>
<span id="L904" class="LineNr"> 904 </span>      <span class="Comment">// Each var's poss parents are sets containing the preceding vars in l.</span>
<span id="L905" class="LineNr"> 905 </span>      poss_v_parents <span class="Statement">:=</span> { [l[j], <span class="Identifier">pow</span>({ v <span class="Type">:</span> v <span class="Type">in</span> l[<span class="Constant">1</span><span class="Statement">..</span>j<span class="Type">-</span><span class="Constant">1</span>] })] <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">2</span><span class="Statement">..</span><span class="Type">#</span>l] };
<span id="L906" class="LineNr"> 906 </span>      poss_v_parents[l[<span class="Constant">1</span>]] <span class="Statement">:=</span> {{}};
<span id="L907" class="LineNr"> 907 </span>      poss_parents <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(vs, poss_v_parents);
<span id="L908" class="LineNr"> 908 </span>
<span id="L909" class="LineNr"> 909 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-916">poss_cms_from_p_pars</a>(vs, poss_parents, p_pars)
<span id="L910" class="LineNr"> 910 </span>                  <span class="Type">:</span> p_pars <span class="Type">in</span> poss_parents };
<span id="L911" class="LineNr"> 911 </span>    };
<span id="L912" class="LineNr"> 912 </span>
<span id="L913" class="LineNr"> 913 </span>    <span class="Comment">/* Given a set of parenthood relations, construct its set of possible </span>
<span id="L914" class="LineNr"> 914 </span><span class="Comment">       causal models. For each variable, construct the set of possible </span>
<span id="L915" class="LineNr"> 915 </span><span class="Comment">       functions from its parents. */</span>
<span id="L916" class="LineNr"><a href="#tda-876" data-file="test_decision_algorithm" title="test_poss_cms_from_p_pars" class="checkmark">&#10004;</a> 916 </span>    <span class="Identifier">poss_cms_from_p_pars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(vs, poss_parents, p_pars) {
<span id="L917" class="LineNr"> 917 </span>      cm_u <span class="Statement">:=</span> { v <span class="Type">:</span> v <span class="Type">in</span> vs <span class="Type">|</span> p_pars[v] <span class="Type">==</span> {} };
<span id="L918" class="LineNr"> 918 </span>      cm_v <span class="Statement">:=</span> vs <span class="Type">-</span> cm_u;
<span id="L919" class="LineNr"> 919 </span>      cm_r <span class="Statement">:=</span> { [v, {<span class="Constant">true</span>, <span class="Constant">false</span>}] <span class="Type">:</span> v <span class="Type">in</span> vs };
<span id="L920" class="LineNr"> 920 </span>      poss_v_cm_fs <span class="Statement">:=</span> {
<span id="L921" class="LineNr"> 921 </span>        [v, <span class="Identifier">function_space</span>(<a class="Identifier code-proc-link" href="#l-328">possible_states</a>(p_pars[v], cm_r), {<span class="Constant">true</span>, <span class="Constant">false</span>})]
<span id="L922" class="LineNr"> 922 </span>        <span class="Type">:</span> v <span class="Type">in</span> cm_v };
<span id="L923" class="LineNr"> 923 </span>      poss_cm_fs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(cm_v, poss_v_cm_fs);
<span id="L924" class="LineNr"> 924 </span>      <span class="Statement">return</span> { <span class="Identifier">causal_model</span>(cm_u, cm_v, cm_r, cm_f, <span class="Constant">om</span>) <span class="Type">:</span> cm_f <span class="Type">in</span> poss_cm_fs };
<span id="L925" class="LineNr"> 925 </span>    };
<span id="L926" class="LineNr"> 926 </span>
<span id="L927" class="LineNr"> 927 </span>  <span class="Comment">/* Takes a causal_model and returns a set of coherent probability </span>
<span id="L928" class="LineNr"> 928 </span><span class="Comment">     distributions compatible with the cm. Each distribution is given by</span>
<span id="L929" class="LineNr"> 929 </span><span class="Comment">     a pair of assignments of values to p and cp.  */</span>
<span id="L930" class="LineNr"><a href="#tda-972" data-file="test_decision_algorithm" title="test_coh_pcms" class="checkmark">&#10004;</a> 930 </span>  <span class="Identifier">coh_pcms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(cm) {
<span id="L931" class="LineNr"> 931 </span>    <span class="Comment">// Coherent probability distributions for exogenous variables u</span>
<span id="L932" class="LineNr"> 932 </span>    coh_u_probs <span class="Statement">:=</span> { p_u <span class="Type">:</span> p_u <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-938">poss_p_us</a>(cm.u)
<span id="L933" class="LineNr"> 933 </span>                         <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-951">p_u_is_coherent</a>(p_u, cm.u) };
<span id="L934" class="LineNr"> 934 </span>    <span class="Statement">return</span> { [<a class="Identifier code-proc-link" href="#da-983">probs</a>(cm, p_u) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-1014">subj_conds</a>(cm, p_u), <a class="Identifier code-proc-link" href="#da-997">cond_probs</a>(cm, p_u)]
<span id="L935" class="LineNr"> 935 </span>             <span class="Type">:</span> p_u <span class="Type">in</span> coh_u_probs };
<span id="L936" class="LineNr"> 936 </span>  };
<span id="L937" class="LineNr"> 937 </span>
<span id="L938" class="LineNr"> 938 </span>    <span class="Identifier">poss_p_us</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(us) {
<span id="L939" class="LineNr"> 939 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {state} <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#da-942">p_range</a>() <span class="Type">:</span> state <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-947">state_space</a>(us) });
<span id="L940" class="LineNr"> 940 </span>    };
<span id="L941" class="LineNr"> 941 </span>
<span id="L942" class="LineNr"> 942 </span>      <span class="Identifier">p_range</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L943" class="LineNr"> 943 </span>        <span class="Statement">return</span> r[<span class="Identifier">first</span>(<span class="Identifier">range</span>(p))]; <span class="Comment">// assume all probs share the same range</span>
<span id="L944" class="LineNr"> 944 </span>      };
<span id="L945" class="LineNr"> 945 </span>
<span id="L946" class="LineNr"> 946 </span>      <span class="Comment">/* For each prob variable, choose either it being true or false */</span>
<span id="L947" class="LineNr"> 947 </span>      <span class="Identifier">state_space</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(vs) {
<span id="L948" class="LineNr"> 948 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {[v, <span class="Constant">true</span>], [v, <span class="Constant">false</span>]} <span class="Type">:</span> v <span class="Type">in</span> vs });
<span id="L949" class="LineNr"> 949 </span>      };
<span id="L950" class="LineNr"> 950 </span>
<span id="L951" class="LineNr"> 951 </span>    <span class="Identifier">p_u_is_coherent</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_u, base_vars) {
<span id="L952" class="LineNr"> 952 </span>      poss_exprs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2342">add_up_to</a>(base_vars, <span class="Constant">2</span> <span class="Type">**</span> <span class="Type">#</span>base_vars);
<span id="L953" class="LineNr"> 953 </span>      poss_probs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(poss_exprs,
<span id="L954" class="LineNr"> 954 </span>                                    { [expr, <span class="Identifier">p_range</span>()] <span class="Type">:</span> expr <span class="Type">in</span> poss_exprs });
<span id="L955" class="LineNr"> 955 </span>      poss_ord_pairs <span class="Statement">:=</span> poss_exprs <span class="Type">&gt;&lt;</span> poss_exprs;
<span id="L956" class="LineNr"> 956 </span>      poss_cond_probs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(poss_ord_pairs,
<span id="L957" class="LineNr"> 957 </span>                                { [pair, <span class="Identifier">p_range</span>()] <span class="Type">:</span> pair <span class="Type">in</span> poss_ord_pairs });
<span id="L958" class="LineNr"> 958 </span>      poss_p_cps <span class="Statement">:=</span> poss_probs <span class="Type">&gt;&lt;</span> poss_cond_probs;
<span id="L959" class="LineNr"> 959 </span>      <span class="Statement">return</span> <span class="Type">exists</span>(p_cp <span class="Type">in</span> poss_p_cps
<span id="L960" class="LineNr"> 960 </span>                    <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-963">is_superset_of</a>(p_cp, p_u) <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#da-968">superset_is_coherent</a>(p_cp) );
<span id="L961" class="LineNr"> 961 </span>    };
<span id="L962" class="LineNr"> 962 </span>
<span id="L963" class="LineNr"> 963 </span>      <span class="Identifier">is_superset_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_cp, p_u) {
<span id="L964" class="LineNr"> 964 </span>        <span class="Statement">return</span> { [p_var, p_val] <span class="Type">:</span> [p_var, p_val] <span class="Type">in</span> p_u <span class="Type">|</span> p_val <span class="Type">!=</span> <span class="Constant">om</span> }
<span id="L965" class="LineNr"> 965 </span>               <span class="Type">&lt;</span> <span class="Identifier">first</span>(p_cp);
<span id="L966" class="LineNr"> 966 </span>      };
<span id="L967" class="LineNr"> 967 </span>
<span id="L968" class="LineNr"> 968 </span>      <span class="Identifier">superset_is_coherent</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_cp) {
<span id="L969" class="LineNr"> 969 </span>        d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L970" class="LineNr"> 970 </span>        d.p <span class="Statement">:=</span> { [expr, <span class="Constant">'P('</span> <span class="Type">+</span> <span class="Identifier">str</span>(expr) <span class="Type">+</span> <span class="Constant">')'</span>]
<span id="L971" class="LineNr"> 971 </span>                 <span class="Type">:</span> [expr, p_val] <span class="Type">in</span> <span class="Identifier">first</span>(p_cp) };
<span id="L972" class="LineNr"> 972 </span>        d.cp <span class="Statement">:=</span> { [l, <span class="Constant">'P('</span> <span class="Type">+</span> <span class="Identifier">str</span>(l[<span class="Constant">1</span>]) <span class="Type">+</span> <span class="Constant">'|'</span> <span class="Type">+</span> <span class="Identifier">str</span>(l[<span class="Constant">2</span>]) <span class="Type">+</span> <span class="Constant">')'</span>]
<span id="L973" class="LineNr"> 973 </span>                  <span class="Type">:</span> [l, p_val] <span class="Type">in</span> <span class="Identifier">last</span>(p_cp) };
<span id="L974" class="LineNr"> 974 </span>        pp <span class="Statement">:=</span> { [<span class="Constant">'P('</span> <span class="Type">+</span> <span class="Identifier">str</span>(expr) <span class="Type">+</span> <span class="Constant">')'</span>,                   p_val]
<span id="L975" class="LineNr"> 975 </span>                <span class="Type">:</span> [expr, p_val] <span class="Type">in</span> <span class="Identifier">first</span>(p_cp) } <span class="Type">+</span>
<span id="L976" class="LineNr"> 976 </span>              { [<span class="Constant">'P('</span> <span class="Type">+</span> <span class="Identifier">str</span>(l[<span class="Constant">1</span>]) <span class="Type">+</span> <span class="Constant">'|'</span> <span class="Type">+</span> <span class="Identifier">str</span>(l[<span class="Constant">2</span>]) <span class="Type">+</span> <span class="Constant">')'</span>, p_val]
<span id="L977" class="LineNr"> 977 </span>                <span class="Type">:</span> [l, p_val] <span class="Type">in</span> <span class="Identifier">last</span>(p_cp) };
<span id="L978" class="LineNr"> 978 </span>        <span class="Statement">return</span> d.<a class="Identifier code-proc-link" href="#da-1214">is_coherent</a>(pp);
<span id="L979" class="LineNr"> 979 </span>      };
<span id="L980" class="LineNr"> 980 </span>
<span id="L981" class="LineNr"> 981 </span>    <span class="Comment">/* Given p_u, a prob distr over states of the exogenous variables u, use </span>
<span id="L982" class="LineNr"> 982 </span><span class="Comment">       the causal_model to calculate the probabilities of endogenous vars vs. */</span>
<span id="L983" class="LineNr"> 983 </span>    <span class="Identifier">probs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(cm, p_u) {
<span id="L984" class="LineNr"> 984 </span>      <span class="Comment">// For each state of exogenous vars u, use the causal model to fill in </span>
<span id="L985" class="LineNr"> 985 </span>      <span class="Comment">// what the state of endogenous vars v would be. </span>
<span id="L986" class="LineNr"> 986 </span>      p_uv <span class="Statement">:=</span> { [u_state <span class="Type">+</span> cm.<a class="Identifier code-proc-link" href="#cmm-108">response</a>(cm.v, u_state), p_val]
<span id="L987" class="LineNr"> 987 </span>                <span class="Type">:</span> [u_state, p_val] <span class="Type">in</span> p_u };
<span id="L988" class="LineNr"> 988 </span>      <span class="Comment">// For each poss event of the causal model, turn the event into an expr</span>
<span id="L989" class="LineNr"> 989 </span>      <span class="Comment">// and assign it probability equal to the sum of the probabilities of </span>
<span id="L990" class="LineNr"> 990 </span>      <span class="Comment">// uv states in which the event is realized.</span>
<span id="L991" class="LineNr"> 991 </span>      <span class="Statement">return</span> { [ <a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>(g_vs),
<span id="L992" class="LineNr"> 992 </span>                 <span class="Type">+/</span> { p_val <span class="Type">:</span> [uv_state, p_val] <span class="Type">in</span> p_uv <span class="Type">|</span> g_vs <span class="Type">&lt;</span> uv_state }]
<span id="L993" class="LineNr"> 993 </span>               <span class="Type">:</span> g_vs <span class="Type">in</span> cm.<a class="Identifier code-proc-link" href="#cmm-88">poss_events</a>() };
<span id="L994" class="LineNr"> 994 </span>    };
<span id="L995" class="LineNr"> 995 </span>
<span id="L996" class="LineNr"> 996 </span>    <span class="Comment">/* Next we calculate the conditional probabilities for a given p_u */</span>
<span id="L997" class="LineNr"> 997 </span>    <span class="Identifier">cond_probs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(cm, p_u) {
<span id="L998" class="LineNr"> 998 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-1001">calc_cond_prob</a>(g, h) <span class="Type">:</span> [g,h] <span class="Type">in</span> cm.<a class="Identifier code-proc-link" href="#cmm-88">poss_events</a>() <span class="Type">**</span> <span class="Constant">2</span> };
<span id="L999" class="LineNr"> 999 </span>    };
<span id="L1000" class="LineNr">1000 </span>
<span id="L1001" class="LineNr">1001 </span>      <span class="Identifier">calc_cond_prob</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(cm, p_u, g, h) {
<span id="L1002" class="LineNr">1002 </span>        <span class="Statement">if</span> (<a class="Identifier code-proc-link" href="#l-342">compatible_values</a>(g, h)) {
<span id="L1003" class="LineNr">1003 </span>          a <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>(g);
<span id="L1004" class="LineNr">1004 </span>          b <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>(h);
<span id="L1005" class="LineNr">1005 </span>          c <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>(g <span class="Type">+</span> h);
<span id="L1006" class="LineNr">1006 </span>          <span class="Comment">/* Using P(A|B) == P(And(A,B)) / P(B)  (Kolmogorov definition) */</span>
<span id="L1007" class="LineNr">1007 </span>          <span class="Statement">return</span> { [ cp[[a,b]], <a class="Identifier code-proc-link" href="#da-983">probs</a>(cm, p_u)[c] <span class="Type">/</span> <a class="Identifier code-proc-link" href="#da-983">probs</a>(cm, p_u)[b] ] };
<span id="L1008" class="LineNr">1008 </span>        } <span class="Statement">else</span> {
<span id="L1009" class="LineNr">1009 </span>          <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L1010" class="LineNr">1010 </span>        }
<span id="L1011" class="LineNr">1011 </span>      };
<span id="L1012" class="LineNr">1012 </span>
<span id="L1013" class="LineNr">1013 </span>    <span class="Comment">// Just set to 100% if the subjunctive conditional is true in cm</span>
<span id="L1014" class="LineNr">1014 </span>    <span class="Identifier">subj_conds</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(cm, p_u) {
<span id="L1015" class="LineNr">1015 </span>      <span class="Statement">return</span> { [p[<span class="Identifier">BoxArrow</span>(<a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>(g), <a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>(h))], <span class="Constant">1.0</span>]
<span id="L1016" class="LineNr">1016 </span>                <span class="Type">:</span> [g,h] <span class="Type">in</span> cm.<a class="Identifier code-proc-link" href="#cmm-88">poss_events</a>() <span class="Type">**</span> <span class="Constant">2</span>
<span id="L1017" class="LineNr">1017 </span>                <span class="Type">|</span> cm.<a class="Identifier code-proc-link" href="#cmm-108">response</a>(<span class="Identifier">domain</span>(h), g) <span class="Type">==</span> h };
<span id="L1018" class="LineNr">1018 </span>    };
<span id="L1019" class="LineNr">1019 </span>
<span id="L1020" class="LineNr">1020 </span>  <span class="Comment">// Note that the function it returns assigns true/false to prob vars and not</span>
<span id="L1021" class="LineNr">1021 </span>  <span class="Comment">// atomic expressions. You may want expr_to_events instead.</span>
<span id="L1022" class="LineNr"><a href="#tda-1001" data-file="test_decision_algorithm" title="test_expr_to_p_funcs" class="checkmark">&#10004;</a>1022 </span>  <span class="Identifier">expr_to_p_funcs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr, dom) {
<span id="L1023" class="LineNr">1023 </span>    <span class="Statement">return</span> { { [p[term], bool] <span class="Type">:</span> [term, bool] <span class="Type">in</span> event }
<span id="L1024" class="LineNr">1024 </span>             <span class="Type">:</span> event <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(expr, dom) };
<span id="L1025" class="LineNr">1025 </span>  };
<span id="L1026" class="LineNr">1026 </span>
<span id="L1027" class="LineNr">1027 </span>  <span class="Comment">/* Coherent Causal Model Probabilities</span>
<span id="L1028" class="LineNr">1028 </span><span class="Comment">     Coherent probability distributions over p and cp, including the </span>
<span id="L1029" class="LineNr">1029 </span><span class="Comment">     subjunctive conditionals, which can be seen as pieces of causal models. </span>
<span id="L1030" class="LineNr">1030 </span><span class="Comment">     We start with probability distributions over all causal models (from</span>
<span id="L1031" class="LineNr">1031 </span><span class="Comment">     the set of base variables in p). Collecting the coherent distributions </span>
<span id="L1032" class="LineNr">1032 </span><span class="Comment">     over p and cp within each model, we then distribute the probability of</span>
<span id="L1033" class="LineNr">1033 </span><span class="Comment">     the causal model to those distributions and sum them all up again. */</span>
<span id="L1034" class="LineNr">1034 </span>  <span class="Identifier">coh_cm_ps</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1035" class="LineNr">1035 </span>    <span class="Comment">// Possible probabilities of causal models</span>
<span id="L1036" class="LineNr">1036 </span>    poss_p_cms <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {poss_cm} <span class="Type">&gt;&lt;</span> p_range <span class="Type">:</span> poss_cm <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-895">poss_cms</a>() });
<span id="L1037" class="LineNr">1037 </span>    <span class="Comment">/* The probabilities within any distribution must sum to 1. </span>
<span id="L1038" class="LineNr">1038 </span><span class="Comment">       (Each causal model considered is global and includes all base vars so </span>
<span id="L1039" class="LineNr">1039 </span><span class="Comment">       there is no worries of overlapping by one cm being a "superset" of </span>
<span id="L1040" class="LineNr">1040 </span><span class="Comment">       another.) */</span>
<span id="L1041" class="LineNr">1041 </span>    coh_p_cms <span class="Statement">:=</span> { p_cms <span class="Type">:</span> p_cms <span class="Type">in</span> poss_p_cms <span class="Type">|</span> <span class="Type">+/</span> <span class="Identifier">range</span>(p_cms) <span class="Type">==</span> <span class="Constant">1.0</span> };
<span id="L1042" class="LineNr">1042 </span>
<span id="L1043" class="LineNr">1043 </span>    <span class="Comment">// Collect from each coherent probability distribution over causal models</span>
<span id="L1044" class="LineNr">1044 </span>    <span class="Comment">// the coherent probability distributions over p and cp that are allowed.</span>
<span id="L1045" class="LineNr">1045 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-1053">sum_p_cms</a>(p_cms) <span class="Type">:</span> p_cms <span class="Type">in</span> coh_p_cms };
<span id="L1046" class="LineNr">1046 </span>
<span id="L1047" class="LineNr">1047 </span>    <span class="Comment">/* Todo: Double-check whether it's necessary to expand the probability </span>
<span id="L1048" class="LineNr">1048 </span><span class="Comment">       distributions to non-canonical expressions in p? Now that prob_distance</span>
<span id="L1049" class="LineNr">1049 </span><span class="Comment">       handles logical equivalences, it seems unnecessary.  */</span>
<span id="L1050" class="LineNr">1050 </span>  };
<span id="L1051" class="LineNr">1051 </span>
<span id="L1052" class="LineNr">1052 </span>    <span class="Comment">/* Given a coherent probability distribution over causal models... */</span>
<span id="L1053" class="LineNr">1053 </span>    <span class="Identifier">sum_p_cms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_cms) {
<span id="L1054" class="LineNr">1054 </span>      <span class="Comment">/* For each causal model and its probability, collect the possible</span>
<span id="L1055" class="LineNr">1055 </span><span class="Comment">         choices of a coherent probability distribution from each, where</span>
<span id="L1056" class="LineNr">1056 </span><span class="Comment">         those probability distributions have had the probability of the </span>
<span id="L1057" class="LineNr">1057 </span><span class="Comment">         causal model distributed over them.  */</span>
<span id="L1058" class="LineNr">1058 </span>      sets_of_p_cps <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({
<span id="L1059" class="LineNr">1059 </span>        { <span class="Identifier">distr_p_cm</span>(p_cp, p_cm) <span class="Type">:</span> p_cp <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-930">coh_pcms</a>(cm) }
<span id="L1060" class="LineNr">1060 </span>        <span class="Type">:</span> [cm, p_cm] <span class="Type">in</span> p_cms
<span id="L1061" class="LineNr">1061 </span>      });
<span id="L1062" class="LineNr">1062 </span>
<span id="L1063" class="LineNr">1063 </span>      <span class="Comment">/* ... For each choice of p_cps from each causal model, sum them up. */</span>
<span id="L1064" class="LineNr">1064 </span>      <span class="Statement">return</span> { <a class="Identifier code-proc-link" href="#l-210">foldr</a>(add_p_distr, {}, [p_cp <span class="Type">:</span> p_cp <span class="Type">in</span> p_cps])
<span id="L1065" class="LineNr">1065 </span>               <span class="Type">:</span> p_cps <span class="Type">in</span> sets_of_p_cps };
<span id="L1066" class="LineNr">1066 </span>    };
<span id="L1067" class="LineNr">1067 </span>
<span id="L1068" class="LineNr">1068 </span>      <span class="Comment">/* Distribute probability of causal model.</span>
<span id="L1069" class="LineNr">1069 </span><span class="Comment">         Takes p_cp, a set of pairs of coherent probability distributions over p</span>
<span id="L1070" class="LineNr">1070 </span><span class="Comment">         and cp, and a probability of the causal model p_cm and then </span>
<span id="L1071" class="LineNr">1071 </span><span class="Comment">         distributes the probability of the causal model so that the probability</span>
<span id="L1072" class="LineNr">1072 </span><span class="Comment">         of each expression is reduced by multiplying the p_cm. */</span>
<span id="L1073" class="LineNr">1073 </span>      <span class="Identifier">distr_p_cm</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_cp, p_cm) {
<span id="L1074" class="LineNr">1074 </span>        <span class="Comment">// p_cp == [cm_p, cm_cp]</span>
<span id="L1075" class="LineNr">1075 </span>        cm_p <span class="Statement">:=</span> p_cp[<span class="Constant">1</span>];
<span id="L1076" class="LineNr">1076 </span>        cm_cp <span class="Statement">:=</span> p_cp[<span class="Constant">2</span>];
<span id="L1077" class="LineNr">1077 </span>        <span class="Statement">return</span> [{ [p_var, p_val <span class="Type">*</span> p_cm] <span class="Type">:</span> [p_var, p_val] <span class="Type">in</span> cm_p },
<span id="L1078" class="LineNr">1078 </span>                { [cp_l, cp_val <span class="Type">*</span> p_cm] <span class="Type">:</span> [cp_l, cp_val] <span class="Type">in</span> cm_cp }];
<span id="L1079" class="LineNr">1079 </span>      };
<span id="L1080" class="LineNr">1080 </span>
<span id="L1081" class="LineNr">1081 </span>      <span class="Comment">/* Given two pairs of probability distributions over p_vars</span>
<span id="L1082" class="LineNr">1082 </span><span class="Comment">         add up the probabilities of expressions. */</span>
<span id="L1083" class="LineNr"><a href="#tda-1030" data-file="test_decision_algorithm" title="test_add_p_distr" class="checkmark">&#10004;</a>1083 </span>      <span class="Identifier">add_p_distr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_cp1, p_cp2) {
<span id="L1084" class="LineNr">1084 </span>        p1  <span class="Statement">:=</span> p_cp1[<span class="Constant">1</span>];
<span id="L1085" class="LineNr">1085 </span>        cp1 <span class="Statement">:=</span> p_cp1[<span class="Constant">2</span>];
<span id="L1086" class="LineNr">1086 </span>        p2  <span class="Statement">:=</span> p_cp2[<span class="Constant">1</span>];
<span id="L1087" class="LineNr">1087 </span>        cp2 <span class="Statement">:=</span> p_cp2[<span class="Constant">2</span>];
<span id="L1088" class="LineNr">1088 </span>        <span class="Statement">return</span> [<a class="Identifier code-proc-link" href="#da-1091">sum_p</a>(p1, p2), <a class="Identifier code-proc-link" href="#da-1091">sum_p</a>(cp1, cp2)];
<span id="L1089" class="LineNr">1089 </span>      };
<span id="L1090" class="LineNr">1090 </span>
<span id="L1091" class="LineNr"><a href="#tda-1019" data-file="test_decision_algorithm" title="test_sum_p" class="checkmark">&#10004;</a>1091 </span>        <span class="Identifier">sum_p</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p1, p2) {
<span id="L1092" class="LineNr">1092 </span>          <span class="Comment">/* If one has a variable where the other does not have any variable</span>
<span id="L1093" class="LineNr">1093 </span><span class="Comment">             with an equivalent expression, just go with the probability </span>
<span id="L1094" class="LineNr">1094 </span><span class="Comment">             defined by the one. */</span>
<span id="L1095" class="LineNr">1095 </span>          <span class="Statement">return</span> { [v1, p1[v1]] <span class="Type">:</span> v1 <span class="Type">in</span> <span class="Identifier">domain</span>(p1)
<span id="L1096" class="LineNr">1096 </span>                   <span class="Type">|</span> <span class="Type">!</span><span class="Type">exists</span>(v2 <span class="Type">in</span> <span class="Identifier">domain</span>(p2) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1108">equiv_p_expr</a>(p, cp, v1, v2)) } <span class="Type">+</span>
<span id="L1097" class="LineNr">1097 </span>                 { [v2, p2[v2]] <span class="Type">:</span> v2 <span class="Type">in</span> <span class="Identifier">domain</span>(p2)
<span id="L1098" class="LineNr">1098 </span>                   <span class="Type">|</span> <span class="Type">!</span><span class="Type">exists</span>(v1 <span class="Type">in</span> <span class="Identifier">domain</span>(p1) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1108">equiv_p_expr</a>(p, cp, v1, v2)) } <span class="Type">+</span>
<span id="L1099" class="LineNr">1099 </span>          <span class="Comment">/* Otherwise, for any variables that have equivalent expressions,</span>
<span id="L1100" class="LineNr">1100 </span><span class="Comment">             add up the probabilities for those variables. (Since they've </span>
<span id="L1101" class="LineNr">1101 </span><span class="Comment">             already been reduced in distr_p_cm, we don't need to average </span>
<span id="L1102" class="LineNr">1102 </span><span class="Comment">             the sum.)  */</span>
<span id="L1103" class="LineNr">1103 </span>                 <span class="Type">+/</span> { { [v1, p1[v1] <span class="Type">+</span> p2[v2]],[v2, p1[v1] <span class="Type">+</span> p2[v2]]  }
<span id="L1104" class="LineNr">1104 </span>                      <span class="Type">:</span> [v1, v2] <span class="Type">in</span> <span class="Identifier">domain</span>(p1) <span class="Type">&gt;&lt;</span> <span class="Identifier">domain</span>(p2)
<span id="L1105" class="LineNr">1105 </span>                      <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1108">equiv_p_expr</a>(p, cp, v1, v2) };
<span id="L1106" class="LineNr">1106 </span>        };
<span id="L1107" class="LineNr">1107 </span>
<span id="L1108" class="LineNr">1108 </span>          <span class="Identifier">equiv_p_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p, cp, v1, v2) {
<span id="L1109" class="LineNr">1109 </span>            e1 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1146">p_cp_inv</a>(p, cp, v1);
<span id="L1110" class="LineNr">1110 </span>            e2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1146">p_cp_inv</a>(p, cp, v2);
<span id="L1111" class="LineNr">1111 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-36">equiv_expr</a>(e1, e2, <a class="Identifier code-proc-link" href="#l-116">all_atomic_formulas</a>(<span class="Identifier">domain</span>(p)));
<span id="L1112" class="LineNr">1112 </span>          };
<span id="L1113" class="LineNr">1113 </span>
<span id="L1114" class="LineNr">1114 </span>  <span class="Comment">/* Takes a brain and time and finds the closest perfectly coherent </span>
<span id="L1115" class="LineNr">1115 </span><span class="Comment">     probability distribution and returns the distance to it. */</span>
<span id="L1116" class="LineNr">1116 </span>  <span class="Identifier">p_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, ti) {
<span id="L1117" class="LineNr">1117 </span>    p_states <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-772">prob_states_t</a>(b, ti);
<span id="L1118" class="LineNr">1118 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1275">prob_distance</a>(p, cp, <a class="Identifier code-proc-link" href="#da-1124">sorted_rat</a>(p_states)[<span class="Constant">1</span>], p_states);
<span id="L1119" class="LineNr">1119 </span>  };
<span id="L1120" class="LineNr">1120 </span>
<span id="L1121" class="LineNr">1121 </span>  <span class="Comment">/* Takes a prob state and returns a list of coherent probability </span>
<span id="L1122" class="LineNr">1122 </span><span class="Comment">     distributions sorted by how close they are to p_states, closer ones first.</span>
<span id="L1123" class="LineNr">1123 </span><span class="Comment">  */</span>
<span id="L1124" class="LineNr">1124 </span>  <span class="Identifier">sorted_rat</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_states) {
<span id="L1125" class="LineNr">1125 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>( [ coh_p <span class="Type">+</span> coh_cp <span class="Type">:</span> [coh_p, coh_cp] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1034">coh_cm_ps</a>() ],
<span id="L1126" class="LineNr">1126 </span>      <span class="Comment">/* A procedure measuring which of two probability states is closer to </span>
<span id="L1127" class="LineNr">1127 </span><span class="Comment">         the original one given.  */</span>
<span id="L1128" class="LineNr">1128 </span>      <span class="Type">procedure</span>(pp1, pp2) {
<span id="L1129" class="LineNr">1129 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1275">prob_distance</a>(p, cp, pp1, p_states) <span class="Type">&lt;</span>
<span id="L1130" class="LineNr">1130 </span>               <span class="Identifier">prob_distance</span>(p, cp, pp2, p_states);
<span id="L1131" class="LineNr">1131 </span>      }
<span id="L1132" class="LineNr">1132 </span>    );
<span id="L1133" class="LineNr">1133 </span>  };
<span id="L1134" class="LineNr">1134 </span>
<span id="L1135" class="LineNr">1135 </span>  <span class="Comment">/* Takes a p or cp var in range(p) + range(cp) and returns its preimage </span>
<span id="L1136" class="LineNr">1136 </span><span class="Comment">     formula(s) */</span>
<span id="L1137" class="LineNr"><a href="#tda-370" data-file="test_decision_algorithm" title="test_p_inv" class="checkmark">&#10004;</a>1137 </span>  <span class="Identifier">p_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(v) {
<span id="L1138" class="LineNr">1138 </span>    <span class="Statement">if</span> (v <span class="Type">in</span> <span class="Identifier">range</span>(p)) {
<span id="L1139" class="LineNr">1139 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-239">inv</a>(p)[v];
<span id="L1140" class="LineNr">1140 </span>    } <span class="Statement">else</span> {
<span id="L1141" class="LineNr">1141 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-239">inv</a>(cp)[v];
<span id="L1142" class="LineNr">1142 </span>    }
<span id="L1143" class="LineNr">1143 </span>  };
<span id="L1144" class="LineNr">1144 </span>
<span id="L1145" class="LineNr">1145 </span>  <span class="Comment">// Same as p_inv but with p and cp explicitly passed in due to setlx bug</span>
<span id="L1146" class="LineNr">1146 </span>  <span class="Identifier">p_cp_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p, cp, v) {
<span id="L1147" class="LineNr">1147 </span>    <span class="Statement">if</span> (v <span class="Type">in</span> <span class="Identifier">range</span>(p)) {
<span id="L1148" class="LineNr">1148 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-239">inv</a>(p)[v];
<span id="L1149" class="LineNr">1149 </span>    } <span class="Statement">else</span> {
<span id="L1150" class="LineNr">1150 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-239">inv</a>(cp)[v];
<span id="L1151" class="LineNr">1151 </span>    }
<span id="L1152" class="LineNr">1152 </span>  };
<span id="L1153" class="LineNr">1153 </span>
<span id="L1154" class="LineNr">1154 </span>  <span class="Comment">// Same as p_inv but if in cp, it returns the first expr instead of the pair</span>
<span id="L1155" class="LineNr">1155 </span>  <span class="Identifier">p_var_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(v) {
<span id="L1156" class="LineNr">1156 </span>    <span class="Statement">if</span> (v <span class="Type">in</span> <span class="Identifier">range</span>(p)) {
<span id="L1157" class="LineNr">1157 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-239">inv</a>(p)[v];
<span id="L1158" class="LineNr">1158 </span>    } <span class="Statement">else</span> {
<span id="L1159" class="LineNr">1159 </span>      <span class="Statement">return</span> <span class="Identifier">first</span>(<a class="Identifier code-proc-link" href="#l-239">inv</a>(cp)[v]);
<span id="L1160" class="LineNr">1160 </span>    }
<span id="L1161" class="LineNr">1161 </span>  };
<span id="L1162" class="LineNr">1162 </span>
<span id="L1163" class="LineNr">1163 </span>
<span id="L1164" class="LineNr">1164 </span>  <span class="Comment">/* Obeys the axioms of probability.</span>
<span id="L1165" class="LineNr">1165 </span><span class="Comment">       See especially p 45 (or 64 in pdf) of E.T. Jaynes, Probability Theory: </span>
<span id="L1166" class="LineNr">1166 </span><span class="Comment">       The Logic of Science. <a href="https://bayes.wustl.edu/etj/prob/book.pdf" target="_blank">https://bayes.wustl.edu/etj/prob/book.pdf</a>  */</span>
<span id="L1167" class="LineNr">1167 </span>  <span class="Identifier">old_is_coherent</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(pp) {
<span id="L1168" class="LineNr">1168 </span>    <span class="Comment">/* For easier handling, turn domain(p) into a datatype like domain(cp) </span>
<span id="L1169" class="LineNr">1169 </span><span class="Comment">       so that e.g. P(A) looks more like P(A|om) */</span>
<span id="L1170" class="LineNr"><a href="#tda-1123" data-file="test_decision_algorithm" title="test_force_list" class="checkmark">&#10004;</a>1170 </span>    <span class="Identifier">force_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(v) {
<span id="L1171" class="LineNr">1171 </span>      <span class="Statement">if</span> (<span class="Identifier">isList</span>(<a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(v))) {
<span id="L1172" class="LineNr">1172 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(v);
<span id="L1173" class="LineNr">1173 </span>      } <span class="Statement">else</span> {
<span id="L1174" class="LineNr">1174 </span>        <span class="Statement">return</span> [<a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(v), <span class="Constant">om</span>];
<span id="L1175" class="LineNr">1175 </span>      }
<span id="L1176" class="LineNr">1176 </span>    };
<span id="L1177" class="LineNr">1177 </span>    pp <span class="Statement">:=</span> { [<a class="Identifier code-proc-link" href="#da-1170">force_list</a>(v), num] <span class="Type">:</span> [v,num] <span class="Type">in</span> pp };
<span id="L1178" class="LineNr">1178 </span>    <span class="Identifier">obeys_axiom_3</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l) {
<span id="L1179" class="LineNr">1179 </span>      <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(l[<span class="Constant">1</span>]) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(l[<span class="Constant">1</span>]) <span class="Type">==</span> <span class="Constant">"And"</span>) { <span class="Comment">// [And(a,b), c]</span>
<span id="L1180" class="LineNr">1180 </span>        [a,b] <span class="Statement">:=</span> <span class="Identifier">args</span>(l[<span class="Constant">1</span>]);
<span id="L1181" class="LineNr">1181 </span>        c <span class="Statement">:=</span> l[<span class="Constant">2</span>];
<span id="L1182" class="LineNr">1182 </span>        <span class="Comment">// P(a,b|c) = P(a|b,c) * P(b|c)</span>
<span id="L1183" class="LineNr">1183 </span>        <span class="Statement">return</span> pp[l] <span class="Type">==</span> pp[ [a, <span class="Identifier">And</span>(b,c)] ] <span class="Type">*</span> pp[ [b,c] ];
<span id="L1184" class="LineNr">1184 </span>      } <span class="Statement">else</span> {
<span id="L1185" class="LineNr">1185 </span>        <span class="Statement">return</span> <span class="Constant">true</span>;
<span id="L1186" class="LineNr">1186 </span>      }
<span id="L1187" class="LineNr">1187 </span>    };
<span id="L1188" class="LineNr">1188 </span>    <span class="Statement">return</span> <span class="Type">forall</span>(l <span class="Type">in</span> <span class="Identifier">domain</span>(pp) <span class="Type">|</span> pp[l] <span class="Type">&gt;=</span> <span class="Constant">0</span>) <span class="Type">&amp;&amp;</span>
<span id="L1189" class="LineNr">1189 </span>           <span class="Comment">// P(A|x) + P(~A|x) = 1</span>
<span id="L1190" class="LineNr">1190 </span>           <span class="Comment">// Todo: Simplify double negation to avoid infinite NOT() regression?</span>
<span id="L1191" class="LineNr">1191 </span>           <span class="Type">forall</span>(l <span class="Type">in</span> <span class="Identifier">domain</span>(pp) <span class="Type">|</span> pp[l] <span class="Type">==</span> <span class="Constant">1</span> <span class="Type">-</span> pp[ [<span class="Identifier">Not</span>(l[<span class="Constant">1</span>]), l[<span class="Constant">2</span>]] ]) <span class="Type">&amp;&amp;</span>
<span id="L1192" class="LineNr">1192 </span>           <span class="Type">forall</span>(l <span class="Type">in</span> <span class="Identifier">domain</span>(pp) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1178">obeys_axiom_3</a>(l));
<span id="L1193" class="LineNr">1193 </span>  }; <span class="Comment">// end old_is_coherent</span>
<span id="L1194" class="LineNr">1194 </span>
<span id="L1195" class="LineNr">1195 </span>  <span class="Comment">/* From Lasky, Kathryn. "Axiomatic First-Order Probability" </span>
<span id="L1196" class="LineNr">1196 </span><span class="Comment">     <a href="http://ceur-ws.org/Vol-527/paper5.pdf" target="_blank">http://ceur-ws.org/Vol-527/paper5.pdf</a> </span>
<span id="L1197" class="LineNr">1197 </span>
<span id="L1198" class="LineNr">1198 </span><span class="Comment">      Laskey axioms</span>
<span id="L1199" class="LineNr">1199 </span><span class="Comment">        P1. probabilities are between 0 and 1</span>
<span id="L1200" class="LineNr">1200 </span><span class="Comment">        P2. probabilities in tautologies are 1</span>
<span id="L1201" class="LineNr">1201 </span><span class="Comment">              or just logical truths</span>
<span id="L1202" class="LineNr">1202 </span><span class="Comment">        P3. if probability in two statements both being true are 0, then </span>
<span id="L1203" class="LineNr">1203 </span><span class="Comment">              probability of one or the other is equal to adding probability </span>
<span id="L1204" class="LineNr">1204 </span><span class="Comment">              in each</span>
<span id="L1205" class="LineNr">1205 </span><span class="Comment">        P4. Bayesian conditioning</span>
<span id="L1206" class="LineNr">1206 </span><span class="Comment">        P5. interchangeability of logically equivalent statements</span>
<span id="L1207" class="LineNr">1207 </span>
<span id="L1208" class="LineNr">1208 </span><span class="Comment">     Todo: Double-check if it's necessary to handle undefined/om probability </span>
<span id="L1209" class="LineNr">1209 </span><span class="Comment">           values. It seems p_u_is_coherent checks its coherence by seeing if</span>
<span id="L1210" class="LineNr">1210 </span><span class="Comment">           a superset is perfectly coherent so I think that strategy should </span>
<span id="L1211" class="LineNr">1211 </span><span class="Comment">           work. But there may be some slight technical issues making sure </span>
<span id="L1212" class="LineNr">1212 </span><span class="Comment">           we're allowing or disallowing om in the right places there.</span>
<span id="L1213" class="LineNr">1213 </span><span class="Comment">  */</span>
<span id="L1214" class="LineNr">1214 </span>  <span class="Identifier">is_coherent</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(pp) {
<span id="L1215" class="LineNr">1215 </span>    pp <span class="Statement">:=</span> { [<a class="Identifier code-proc-link" href="#da-1170">force_list</a>(v), num] <span class="Type">:</span> [v,num] <span class="Type">in</span> pp };
<span id="L1216" class="LineNr">1216 </span>    <span class="Statement">return</span> <span class="Type">forall</span>(l <span class="Type">in</span> <span class="Identifier">domain</span>(pp) <span class="Type">|</span>
<span id="L1217" class="LineNr">1217 </span>      <span class="Comment">// P1: Probabilities are between 0 and 1.</span>
<span id="L1218" class="LineNr">1218 </span>      <span class="Constant">0</span> <span class="Type">&lt;=</span> pp[l] <span class="Type">&amp;&amp;</span> pp[l] <span class="Type">&lt;=</span> <span class="Constant">1</span> <span class="Type">&amp;&amp;</span>
<span id="L1219" class="LineNr">1219 </span>      <span class="Comment">// P2: Logical truths have probability 1.</span>
<span id="L1220" class="LineNr">1220 </span>      (<span class="Type">!</span><a class="Identifier code-proc-link" href="#l-416">is_logical_truth</a>(l[<span class="Constant">1</span>]) <span class="Type">||</span> pp[l] <span class="Type">==</span> <span class="Constant">1</span>) <span class="Type">&amp;&amp;</span>
<span id="L1221" class="LineNr">1221 </span>      <span class="Type">forall</span>(l2 <span class="Type">in</span> <span class="Identifier">domain</span>(pp) <span class="Type">|</span>
<span id="L1222" class="LineNr">1222 </span>        ( l[<span class="Constant">2</span>] <span class="Type">!=</span> l2[<span class="Constant">2</span>] <span class="Type">||</span> (
<span id="L1223" class="LineNr">1223 </span>          <span class="Comment">// z is shared in P(_|z) &amp;&amp; P(_|z)</span>
<span id="L1224" class="LineNr">1224 </span>
<span id="L1225" class="LineNr">1225 </span>          <span class="Comment">// P3: If P(x^y|z) = 0, then P(x v y|z) = P(x|z) + P(y|z)</span>
<span id="L1226" class="LineNr">1226 </span>          ( pp[[<span class="Identifier">And</span>(l[<span class="Constant">1</span>], l2[<span class="Constant">1</span>]), l[<span class="Constant">2</span>]]] <span class="Type">!=</span> <span class="Constant">0</span> <span class="Type">||</span>
<span id="L1227" class="LineNr">1227 </span>            pp[[ <span class="Identifier">Or</span>(l[<span class="Constant">1</span>], l2[<span class="Constant">1</span>]), l[<span class="Constant">2</span>]]] <span class="Type">==</span> pp[l] <span class="Type">+</span> pp[l2] ) <span class="Type">&amp;&amp;</span>
<span id="L1228" class="LineNr">1228 </span>
<span id="L1229" class="LineNr">1229 </span>          <span class="Comment">// P4: Bayesian conditioning. P(x^y|z) = P(y|z) * P(x|y,z)  </span>
<span id="L1230" class="LineNr">1230 </span>          ( <span class="Identifier">fct</span>(l[<span class="Constant">1</span>]) <span class="Type">!=</span> <span class="Constant">"And"</span> <span class="Type">||</span> <span class="Type">!</span>(l2[<span class="Constant">1</span>] <span class="Type">in</span> <span class="Identifier">args</span>(l[<span class="Constant">1</span>])) <span class="Type">||</span>
<span id="L1231" class="LineNr">1231 </span>            <span class="Type">forall</span>(l3 <span class="Type">in</span> <span class="Identifier">domain</span>(p) <span class="Type">|</span>
<span id="L1232" class="LineNr">1232 </span>              <span class="Type">!</span>(l3[<span class="Constant">1</span>] <span class="Type">in</span> <span class="Identifier">args</span>(l[<span class="Constant">1</span>])) <span class="Type">||</span> l3[<span class="Constant">1</span>] <span class="Type">==</span> l2[<span class="Constant">1</span>] <span class="Type">||</span>
<span id="L1233" class="LineNr">1233 </span>              l3[<span class="Constant">2</span>] <span class="Type">!=</span> <span class="Identifier">And</span>(l2[<span class="Constant">1</span>], l[<span class="Constant">2</span>]) <span class="Type">||</span> pp[l] <span class="Type">==</span> pp[l2] <span class="Type">*</span> pp[l3]
<span id="L1234" class="LineNr">1234 </span>            ) ) <span class="Type">&amp;&amp;</span>
<span id="L1235" class="LineNr">1235 </span>
<span id="L1236" class="LineNr">1236 </span>          <span class="Comment">// P5: Interchangeability of equivalent expressions. Part 1</span>
<span id="L1237" class="LineNr">1237 </span>          <span class="Comment">//     If x&lt;-&gt;y, then Vz P(x|z) = P(y|z) </span>
<span id="L1238" class="LineNr">1238 </span>          ( <span class="Type">!</span><a class="Identifier code-proc-link" href="#l-36">equiv_expr</a>(l[<span class="Constant">1</span>], l2[<span class="Constant">1</span>], <a class="Identifier code-proc-link" href="#l-120">atomic_formulas</a>(<span class="Identifier">domain</span>(p))) <span class="Type">||</span>
<span id="L1239" class="LineNr">1239 </span>            pp[l] <span class="Type">==</span> pp[l2] )
<span id="L1240" class="LineNr">1240 </span>        ) ) <span class="Comment">/* end || */</span> <span class="Type">&amp;&amp;</span> (
<span id="L1241" class="LineNr">1241 </span>          <span class="Comment">// P5 Part 2: If x &lt;-&gt; y, then Vz P(z|x) = P(z|y) </span>
<span id="L1242" class="LineNr">1242 </span>          <span class="Type">!</span><a class="Identifier code-proc-link" href="#l-36">equiv_expr</a>(l[<span class="Constant">2</span>], l2[<span class="Constant">2</span>], <a class="Identifier code-proc-link" href="#l-120">atomic_formulas</a>(<span class="Identifier">domain</span>(p))) <span class="Type">||</span>
<span id="L1243" class="LineNr">1243 </span>          l[<span class="Constant">1</span>] <span class="Type">!=</span> l2[<span class="Constant">1</span>] <span class="Type">||</span> pp[l] <span class="Type">==</span> pp[l2]
<span id="L1244" class="LineNr">1244 </span>        )
<span id="L1245" class="LineNr">1245 </span>      ) <span class="Comment">// end forall l2</span>
<span id="L1246" class="LineNr">1246 </span>    ); <span class="Comment">// end forall l</span>
<span id="L1247" class="LineNr">1247 </span>  }; <span class="Comment">// end is_coherent</span>
<span id="L1248" class="LineNr">1248 </span>
<span id="L1249" class="LineNr">1249 </span>    <span class="Comment">/* For easier handling, turn domain(p) into a datatype like domain(cp) </span>
<span id="L1250" class="LineNr">1250 </span><span class="Comment">       so that e.g. P(A) looks more like P(A|om) */</span>
<span id="L1251" class="LineNr"><a href="#tda-1123" data-file="test_decision_algorithm" title="test_force_list" class="checkmark">&#10004;</a>1251 </span>    <span class="Identifier">force_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(v) {
<span id="L1252" class="LineNr">1252 </span>      <span class="Statement">if</span> (<span class="Identifier">isList</span>(<a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(v))) {
<span id="L1253" class="LineNr">1253 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(v);
<span id="L1254" class="LineNr">1254 </span>      } <span class="Statement">else</span> {
<span id="L1255" class="LineNr">1255 </span>        <span class="Statement">return</span> [<a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(v), <span class="Constant">om</span>];
<span id="L1256" class="LineNr">1256 </span>      }
<span id="L1257" class="LineNr">1257 </span>    };
<span id="L1258" class="LineNr">1258 </span>
<span id="L1259" class="LineNr">1259 </span>  <span class="Comment">/* Takes two functions mapping p &amp; cp vars to probabilities and computes</span>
<span id="L1260" class="LineNr">1260 </span><span class="Comment">     the difference. See Staffel, Julia. Measuring the Overall Incoherence of </span>
<span id="L1261" class="LineNr">1261 </span><span class="Comment">     Credence Functions. Synthese, 2015. DOI 10.1007/s11229-014-0640-x </span>
<span id="L1262" class="LineNr">1262 </span>
<span id="L1263" class="LineNr">1263 </span><span class="Comment">     Technical Note: Takes p and cp (which should just be the usual this.p and </span>
<span id="L1264" class="LineNr">1264 </span><span class="Comment">     this.cp) but needs to be passed explicitly because of a setlx bug: The </span>
<span id="L1265" class="LineNr">1265 </span><span class="Comment">     second and subsequent calls to an instance procedure within a nested </span>
<span id="L1266" class="LineNr">1266 </span><span class="Comment">     procedure is not able to access instance variables / procedures. </span>
<span id="L1267" class="LineNr">1267 </span>
<span id="L1268" class="LineNr">1268 </span><span class="Comment">     See ambitiousness for a more general workaround. There and elsewhere we</span>
<span id="L1269" class="LineNr">1269 </span><span class="Comment">     assign *this* (the decision algorithm instance) to *self* and then pass</span>
<span id="L1270" class="LineNr">1270 </span><span class="Comment">     in self as the first parameter. The receiving instance procedure then</span>
<span id="L1271" class="LineNr">1271 </span><span class="Comment">     makes sure to call any instance variables and procedures on self rather </span>
<span id="L1272" class="LineNr">1272 </span><span class="Comment">     than their implicit and buggy this. The result may be likened to Python's</span>
<span id="L1273" class="LineNr">1273 </span><span class="Comment">     way of handling instance methods.</span>
<span id="L1274" class="LineNr">1274 </span><span class="Comment">  */</span>
<span id="L1275" class="LineNr"><a href="#tda-1044" data-file="test_decision_algorithm" title="test_prob_distance" class="checkmark">&#10004;</a>1275 <a title="1.2.1.4.2" class="back_to_li" href="#t-1-2-1-4-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">prob_distance</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p, cp, pp1, pp2) {
<span id="L1276" class="LineNr">1276 </span>    <span class="Comment">/* First pass: (but doesn't handle undefineds and logical equivalents)</span>
<span id="L1277" class="LineNr">1277 </span><span class="Comment">    return +/ { abs(pp1[v] - pp2[v]) : v in domain(pp1) | v in domain(pp2) };</span>
<span id="L1278" class="LineNr">1278 </span><span class="Comment">    // Second pass: (but doesn't handle double-counting)</span>
<span id="L1279" class="LineNr">1279 </span><span class="Comment">    return +/ { abs(pp1[v] - pp2[v2]) : [v, v2] in domain(pp1) &gt;&lt; domain(pp2)</span>
<span id="L1280" class="LineNr">1280 </span><span class="Comment">                                      | v == v2 || equiv_p_expr(v, v2) };     </span>
<span id="L1281" class="LineNr">1281 </span><span class="Comment">       Consider three people where the "true" probability is 90%</span>
<span id="L1282" class="LineNr">1282 </span><span class="Comment">         Person 1: A &amp; B 80%, B &amp; A 70%</span>
<span id="L1283" class="LineNr">1283 </span><span class="Comment">         Person 2: A &amp; B 80%</span>
<span id="L1284" class="LineNr">1284 </span><span class="Comment">         Person 3: A &amp; B 80%, B &amp; A 80%</span>
<span id="L1285" class="LineNr">1285 </span><span class="Comment">       Averaging probabilities in logical equivalents favors person 2 and 3 </span>
<span id="L1286" class="LineNr">1286 </span><span class="Comment">       over 1 but not 2 over 3.</span>
<span id="L1287" class="LineNr">1287 </span><span class="Comment">    */</span>
<span id="L1288" class="LineNr">1288 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Identifier">abs</span>( <a class="Identifier code-proc-link" href="#da-1305">pp_equiv</a>(p, cp, pp1)[p_class] <span class="Type">-</span>
<span id="L1289" class="LineNr">1289 </span>                     <span class="Identifier">pp_equiv</span>(p, cp, pp2)[p_class] )
<span id="L1290" class="LineNr">1290 </span>                <span class="Type">:</span> p_class <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1296">p_equiv_classes</a>(p, cp)
<span id="L1291" class="LineNr">1291 </span>                <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1305">pp_equiv</a>(p, cp, pp1)[p_class] <span class="Type">!=</span> <span class="Constant">om</span> <span class="Type">&amp;&amp;</span>
<span id="L1292" class="LineNr">1292 </span>                  <span class="Identifier">pp_equiv</span>(p, cp, pp2)[p_class] <span class="Type">!=</span> <span class="Constant">om</span> };
<span id="L1293" class="LineNr">1293 </span>  };
<span id="L1294" class="LineNr">1294 </span>
<span id="L1295" class="LineNr">1295 </span>    <span class="Comment">// Equivalence classes of probability variables based on logical equivalence</span>
<span id="L1296" class="LineNr">1296 </span>    <span class="Identifier">p_equiv_classes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p, cp) {
<span id="L1297" class="LineNr">1297 </span>      <span class="Statement">return</span> { { x <span class="Type">:</span> x <span class="Type">in</span> <span class="Identifier">range</span>(p) <span class="Type">+</span> <span class="Identifier">range</span>(cp)
<span id="L1298" class="LineNr">1298 </span>                   <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1108">equiv_p_expr</a>(p, cp, p_var, x) }
<span id="L1299" class="LineNr">1299 </span>               <span class="Type">:</span> p_var <span class="Type">in</span> <span class="Identifier">range</span>(p) <span class="Type">+</span> <span class="Identifier">range</span>(cp) };
<span id="L1300" class="LineNr">1300 </span>    };
<span id="L1301" class="LineNr">1301 </span>
<span id="L1302" class="LineNr">1302 </span>    <span class="Comment">// Converts a possibility probability distribution pp to one that ranges</span>
<span id="L1303" class="LineNr">1303 </span>    <span class="Comment">// over equivalence classes of logically equivalent p vars instead of </span>
<span id="L1304" class="LineNr">1304 </span>    <span class="Comment">// directly over the p vars.</span>
<span id="L1305" class="LineNr">1305 </span>    <span class="Identifier">pp_equiv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p, cp, pp) {
<span id="L1306" class="LineNr">1306 </span>      <span class="Statement">return</span> { [p_class, <a class="Identifier code-proc-link" href="#da-1312">avg_p_class</a>(pp, p_class)]
<span id="L1307" class="LineNr">1307 </span>               <span class="Type">:</span> p_class <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1296">p_equiv_classes</a>(p, cp)
<span id="L1308" class="LineNr">1308 </span>               <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1312">avg_p_class</a>(pp, p_class) <span class="Type">!=</span> <span class="Constant">om</span> };
<span id="L1309" class="LineNr">1309 </span>    };
<span id="L1310" class="LineNr">1310 </span>
<span id="L1311" class="LineNr">1311 </span>      <span class="Comment">// Return the average of the values pp assigns to the p vars in p_subset</span>
<span id="L1312" class="LineNr">1312 </span>      <span class="Identifier">avg_p_class</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(pp, p_subset) {
<span id="L1313" class="LineNr">1313 </span>        p_vals <span class="Statement">:=</span> [ pp[p_var] <span class="Type">:</span> p_var <span class="Type">in</span> <span class="Identifier">domain</span>(pp) <span class="Type">|</span> p_var <span class="Type">in</span> p_subset ];
<span id="L1314" class="LineNr">1314 </span>        <span class="Statement">if</span> (<span class="Type">#</span>p_vals <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L1315" class="LineNr">1315 </span>          <span class="Statement">return</span> <span class="Constant">om</span>;
<span id="L1316" class="LineNr">1316 </span>        } <span class="Statement">else</span> {
<span id="L1317" class="LineNr">1317 </span>          <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>(p_vals);
<span id="L1318" class="LineNr">1318 </span>        }
<span id="L1319" class="LineNr">1319 </span>      };
<span id="L1320" class="LineNr">1320 </span>
<span id="L1321" class="LineNr">1321 </span><span class="Comment Heading">// Helpers </span>
<span id="L1322" class="LineNr">1322 </span><span class="Comment Heading">// -------</span>
<span id="L1323" class="LineNr">1323 </span>
<span id="L1324" class="LineNr"><a href="#tda-1056" data-file="test_decision_algorithm" title="test_poss_io_states" class="checkmark">&#10004;</a>1324 </span>  <span class="Identifier">poss_io_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1325" class="LineNr">1325 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(i <span class="Type">+</span> o, r);
<span id="L1326" class="LineNr">1326 </span>  };
<span id="L1327" class="LineNr">1327 </span>
<span id="L1328" class="LineNr"><a href="#tda-163" data-file="test_decision_algorithm" title="test_poss_s_states" class="checkmark">&#10004;</a>1328 </span>  <span class="Identifier">poss_s_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1329" class="LineNr">1329 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(<a class="Identifier code-proc-link" href="#da-123">s</a>(), r);
<span id="L1330" class="LineNr">1330 </span>  };
<span id="L1331" class="LineNr">1331 </span>
<span id="L1332" class="LineNr"><a href="#tda-1072" data-file="test_decision_algorithm" title="test_poss_m_states" class="checkmark">&#10004;</a>1332 </span>  <span class="Identifier">poss_m_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1333" class="LineNr">1333 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(m, r);
<span id="L1334" class="LineNr">1334 </span>  };
<span id="L1335" class="LineNr">1335 </span>
<span id="L1336" class="LineNr">1336 </span>  <span class="Identifier">poss_m2_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1337" class="LineNr">1337 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(m2, r);
<span id="L1338" class="LineNr">1338 </span>  };
<span id="L1339" class="LineNr">1339 </span>
<span id="L1340" class="LineNr">1340 </span>  <span class="Identifier">poss_ms_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1341" class="LineNr">1341 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(m <span class="Type">+</span> m2, r);
<span id="L1342" class="LineNr">1342 </span>  };
<span id="L1343" class="LineNr">1343 </span>
<span id="L1344" class="LineNr"><a href="#tda-162" data-file="test_decision_algorithm" title="test_poss_i_states" class="checkmark">&#10004;</a>1344 </span>  <span class="Identifier">poss_i_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1345" class="LineNr">1345 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(i, r);
<span id="L1346" class="LineNr">1346 </span>  };
<span id="L1347" class="LineNr">1347 </span>
<span id="L1348" class="LineNr"><a href="#tda-161" data-file="test_decision_algorithm" title="test_poss_is_states" class="checkmark">&#10004;</a>1348 </span>  <span class="Identifier">poss_is_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1349" class="LineNr">1349 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>(), r);
<span id="L1350" class="LineNr">1350 </span>  };
<span id="L1351" class="LineNr">1351 </span>
<span id="L1352" class="LineNr"><a href="#tda-1087" data-file="test_decision_algorithm" title="test_poss_o_states" class="checkmark">&#10004;</a>1352 </span>  <span class="Identifier">poss_o_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1353" class="LineNr">1353 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(o, r);
<span id="L1354" class="LineNr">1354 </span>  };
<span id="L1355" class="LineNr">1355 </span>
<span id="L1356" class="LineNr"><a href="#tda-164" data-file="test_decision_algorithm" title="test_poss_u_states" class="checkmark">&#10004;</a>1356 </span>  <span class="Identifier">poss_u_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1357" class="LineNr">1357 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(<span class="Identifier">range</span>(u), r);
<span id="L1358" class="LineNr">1358 </span>  };
<span id="L1359" class="LineNr">1359 </span>
<span id="L1360" class="LineNr">1360 </span>
<span id="L1361" class="LineNr">1361 </span><span class="Comment Heading">// Best Compression</span>
<span id="L1362" class="LineNr">1362 </span><span class="Comment Heading">// ================</span>
<span id="L1363" class="LineNr">1363 </span>
<span id="L1364" class="LineNr">1364 </span>  <span class="Comment Heading">/* Complexity of Intentional Explanation</span>
<span id="L1365" class="LineNr">1365 </span><span class="Comment Heading">     -------------------------------------</span>
<span id="L1366" class="LineNr">1366 </span><span class="Comment">     This can be seen as a more realist and more formal version of Dennett's</span>
<span id="L1367" class="LineNr">1367 </span><span class="Comment">     Intentional Stance. </span>
<span id="L1368" class="LineNr">1368 </span><span class="Comment">       See e.g. <a href="https://sites.google.com/site/minddict/intentional-stance-the" target="_blank">https://sites.google.com/site/minddict/intentional-stance-the</a></span>
<span id="L1369" class="LineNr">1369 </span>
<span id="L1370" class="LineNr">1370 </span><span class="Comment">     On a first pass, the best intentional explanation can be taken to be the</span>
<span id="L1371" class="LineNr">1371 </span><span class="Comment">     one which best compresses the brain's behavior.</span>
<span id="L1372" class="LineNr">1372 </span><span class="Comment">       See better_explanation for further considerations.</span>
<span id="L1373" class="LineNr">1373 </span>
<span id="L1374" class="LineNr">1374 </span><span class="Comment">     Also see <a href="https://en.wikipedia.org/wiki/Minimum_description_length:" target="_blank">https://en.wikipedia.org/wiki/Minimum_description_length</a>:</span>
<span id="L1375" class="LineNr">1375 </span><span class="Comment">       "The minimum description length (MDL) principle is a formalization of </span>
<span id="L1376" class="LineNr">1376 </span><span class="Comment">        Occam's razor in which the best hypothesis (a model and its parameters) </span>
<span id="L1377" class="LineNr">1377 </span><span class="Comment">        for a given set of data is the one that leads to the best compression </span>
<span id="L1378" class="LineNr">1378 </span><span class="Comment">        of the data." </span>
<span id="L1379" class="LineNr">1379 </span>
<span id="L1380" class="LineNr">1380 </span><span class="Comment">     Since b and d already contain information on their transitions from any </span>
<span id="L1381" class="LineNr">1381 </span><span class="Comment">     possible state, we don't need to run this for each time step.</span>
<span id="L1382" class="LineNr">1382 </span><span class="Comment">  */</span>
<span id="L1383" class="LineNr">1383 <a title="1.2.1.3" class="back_to_li" href="#t-1-2-1-3"><i class="fas fa-list-ol"></i></a><a title="1.2.1.3.2.2" class="back_to_li" href="#t-1-2-1-3-2-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">complexity</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b) {
<span id="L1384" class="LineNr">1384 </span>    <span class="Comment">// Complexity of b given d and f + Complexity of d and f</span>
<span id="L1385" class="LineNr">1385 </span>    raw_score <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-790">k_given</a>(b.<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>(), <a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b)) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b));
<span id="L1386" class="LineNr">1386 </span>    <span class="Comment">/* Now normalize. Worst case is it doesn't help encode b any better and </span>
<span id="L1387" class="LineNr">1387 </span><span class="Comment">       it's just as complex as b. Best case is if it could take 0 bits.  */</span>
<span id="L1388" class="LineNr">1388 </span>    worst_score <span class="Statement">:=</span> <span class="Constant">2</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(b.<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>());
<span id="L1389" class="LineNr">1389 </span>    <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">-</span> raw_score <span class="Type">/</span> worst_score;
<span id="L1390" class="LineNr">1390 </span>  };
<span id="L1391" class="LineNr">1391 </span>
<span id="L1392" class="LineNr">1392 </span>  <span class="Identifier">to_s</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L1393" class="LineNr">1393 </span>    <span class="Statement">return</span> <span class="Identifier">str</span>([i, p, cp, u, m, m2, n, o, r, <a class="Identifier code-proc-link" href="#da-152">t</a>()]);
<span id="L1394" class="LineNr">1394 </span>  };
<span id="L1395" class="LineNr">1395 </span>
<span id="L1396" class="LineNr">1396 </span>  <span class="Identifier">f_to_s</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1397" class="LineNr">1397 </span>    <span class="Statement">return</span> <span class="Identifier">str</span>(<a class="Identifier code-proc-link" href="#da-262">f</a>(b));
<span id="L1398" class="LineNr">1398 </span>  };
<span id="L1399" class="LineNr">1399 </span>
<span id="L1400" class="LineNr">1400 </span>  <span class="Identifier">df_to_str</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1401" class="LineNr">1401 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1392">to_s</a>() <span class="Type">+</span> <span class="Constant">"@"</span> <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-1396">f_to_s</a>(b);
<span id="L1402" class="LineNr">1402 </span>    <span class="Comment">// '@' is just a separator, an otherwise unused character</span>
<span id="L1403" class="LineNr">1403 </span>  };
<span id="L1404" class="LineNr">1404 </span>
<span id="L1405" class="LineNr">1405 </span>  <span class="Comment Heading">/* Ambitiousness</span>
<span id="L1406" class="LineNr">1406 </span><span class="Comment Heading">     -------------</span>
<span id="L1407" class="LineNr">1407 </span><span class="Comment">     If we only optimized for the best compression of the brain, we face the </span>
<span id="L1408" class="LineNr">1408 </span><span class="Comment">     following problem. Suppose the syntax we use is somewhat inefficient. </span>
<span id="L1409" class="LineNr">1409 </span><span class="Comment">     Then, the smallest K(b|df) + K(df) might be produced by an empty d with </span>
<span id="L1410" class="LineNr">1410 </span><span class="Comment">     all the work being done by a turing machine which generates b using </span>
<span id="L1411" class="LineNr">1411 </span><span class="Comment">     essentially the same decision algorithm we would have wanted to use as d </span>
<span id="L1412" class="LineNr">1412 </span><span class="Comment">     but with a more efficient syntax. Or it may only put some into the </span>
<span id="L1413" class="LineNr">1413 </span><span class="Comment">     official d and sneak in the rest in the turing machine. It seems what</span>
<span id="L1414" class="LineNr">1414 </span><span class="Comment">     we'd need is something like a not-a-decision-algorithmic-explanation</span>
<span id="L1415" class="LineNr">1415 </span><span class="Comment">     predicate to apply to the turing machine. Or we want d to be ambitious, </span>
<span id="L1416" class="LineNr">1416 </span><span class="Comment">     ideally packing as much of a decision-algorithmic explanation as possible</span>
<span id="L1417" class="LineNr">1417 </span><span class="Comment">     or at least positively weighing its ambitiousness against potential </span>
<span id="L1418" class="LineNr">1418 </span><span class="Comment">     increases in complexity.</span>
<span id="L1419" class="LineNr">1419 </span><span class="Comment">     </span>
<span id="L1420" class="LineNr">1420 </span><span class="Comment">     For a given d, we consider the auxiliary hypothesis h, which together w/</span>
<span id="L1421" class="LineNr">1421 </span><span class="Comment">     d best explains b. We then look for a decomposition of h into [h_i, h_j] </span>
<span id="L1422" class="LineNr">1422 </span><span class="Comment">     where [h_i, h_j] is similar to h, and [h_i, h_j] makes d least ambitious, </span>
<span id="L1423" class="LineNr">1423 </span><span class="Comment">     meaning that the d* which is a superset of d and maximizes coherence and </span>
<span id="L1424" class="LineNr">1424 </span><span class="Comment">     similarity to d + h_i, improves coherence the least with the greatest </span>
<span id="L1425" class="LineNr">1425 </span><span class="Comment">     complexity cost. d's ambitiousness in the worst case decomposition is d's </span>
<span id="L1426" class="LineNr">1426 </span><span class="Comment">     ambitiousness. In other words, the more there is a d* which is highly </span>
<span id="L1427" class="LineNr">1427 </span><span class="Comment">     similar to d + some h_i and very coherent, the less ambitious d is. It </span>
<span id="L1428" class="LineNr">1428 </span><span class="Comment">     would leave out too much that could and should be explained using a </span>
<span id="L1429" class="LineNr">1429 </span><span class="Comment">     decision algorithmic explanation. If d is very ambitious, there's more </span>
<span id="L1430" class="LineNr">1430 </span><span class="Comment">     like just noise left for the auxiliary hypothesis or you'd have to stray </span>
<span id="L1431" class="LineNr">1431 </span><span class="Comment">     farther from the auxiliary hypothesis h to subsume it under a decision </span>
<span id="L1432" class="LineNr">1432 </span><span class="Comment">     algorithmic explanation.</span>
<span id="L1433" class="LineNr">1433 </span><span class="Comment">  */</span>
<span id="L1434" class="LineNr">1434 <a title="1.2.1.6" class="back_to_li" href="#t-1-2-1-6"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">ambitiousness</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1435" class="LineNr">1435 </span>    poss_hs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-740">all_strs_lte</a>(<span class="Type">#</span>b.<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>()) <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#l-740">all_strs_lte</a>(<span class="Type">#</span>b.<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>());
<span id="L1436" class="LineNr">1436 </span>    self <span class="Statement">:=</span> this; <span class="Comment">// workaround for setlx bug described in prob_distance</span>
<span id="L1437" class="LineNr">1437 </span>    poss_hs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(poss_hs,
<span id="L1438" class="LineNr">1438 </span>      <span class="Comment">/* Procedure for worse decomposition. Calling it worse rather than</span>
<span id="L1439" class="LineNr">1439 </span><span class="Comment">         better because we want the [h1, h2] which represents the worst case</span>
<span id="L1440" class="LineNr">1440 </span><span class="Comment">         scenario as far as ambitiousness goes.  </span>
<span id="L1441" class="LineNr">1441 </span><span class="Comment">      */</span>
<span id="L1442" class="LineNr">1442 </span>      <span class="Type">procedure</span>(hs_i, hs_j) {
<span id="L1443" class="LineNr">1443 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1449">hs_score</a>(self, b, hs_i) <span class="Type">&gt;</span> <a class="Identifier code-proc-link" href="#da-1449">hs_score</a>(self, b, hs_j);
<span id="L1444" class="LineNr">1444 </span>      });
<span id="L1445" class="LineNr">1445 </span>    hs <span class="Statement">:=</span> poss_hs[<span class="Constant">1</span>];
<span id="L1446" class="LineNr">1446 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1472">ambitiousness_with_hs</a>(b, hs);
<span id="L1447" class="LineNr">1447 </span>  };
<span id="L1448" class="LineNr">1448 </span>
<span id="L1449" class="LineNr">1449 <a title="1.2.1.6.2.2" class="back_to_li" href="#t-1-2-1-6-2-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">hs_score</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(self, b, hs_k) {
<span id="L1450" class="LineNr">1450 </span>      <span class="Statement">return</span> self.<a class="Identifier code-proc-link" href="#da-1453">hs_similarity</a>(b, hs_k) <span class="Type">-</span> self.<a class="Identifier code-proc-link" href="#da-1472">ambitiousness_with_hs</a>(b, hs_k);
<span id="L1451" class="LineNr">1451 </span>    };
<span id="L1452" class="LineNr">1452 </span>
<span id="L1453" class="LineNr">1453 <a title="1.2.1.6.2.2.1" class="back_to_li" href="#t-1-2-1-6-2-2-1"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">hs_similarity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, hs_k) { <span class="Comment">// hs_k == [h1, h2]</span>
<span id="L1454" class="LineNr">1454 </span>      <span class="Statement">return</span> ( <a class="Identifier code-proc-link" href="#l-790">k_given</a>(<a class="Identifier code-proc-link" href="#da-1459">h</a>(b), <span class="Identifier">str</span>(hs_k)) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-790">k_given</a>(<span class="Identifier">str</span>(hs_k), <a class="Identifier code-proc-link" href="#da-1459">h</a>(b)) ) <span class="Type">*</span> <span class="Type">-</span><span class="Constant">1</span>;
<span id="L1455" class="LineNr">1455 </span>      <span class="Comment">// or ** -1 ?</span>
<span id="L1456" class="LineNr">1456 </span>    };
<span id="L1457" class="LineNr">1457 </span>
<span id="L1458" class="LineNr">1458 </span>  <span class="Comment">// Stringified auxiliary hypothesis which together with d explains b.t_to_str</span>
<span id="L1459" class="LineNr">1459 <a title="1.2.1.6.2.1" class="back_to_li" href="#t-1-2-1-6-2-1"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">h</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1460" class="LineNr">1460 </span>    poss_hs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-740">all_strs_lte</a>(<span class="Type">#</span>b.<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>());
<span id="L1461" class="LineNr">1461 </span>    self <span class="Statement">:=</span> this; <span class="Comment">// workaround for setlx bug described in prob_distance</span>
<span id="L1462" class="LineNr">1462 </span>    poss_hs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(poss_hs, <span class="Type">procedure</span>(h_i, h_j) { <span class="Comment">// better h explanation</span>
<span id="L1463" class="LineNr">1463 </span>                 <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1468">h_complexity</a>(self, b, h_i) <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#da-1468">h_complexity</a>(self, b, h_j);
<span id="L1464" class="LineNr">1464 </span>               });
<span id="L1465" class="LineNr">1465 </span>    <span class="Statement">return</span> poss_hs[<span class="Constant">1</span>];
<span id="L1466" class="LineNr">1466 </span>  };
<span id="L1467" class="LineNr">1467 </span>
<span id="L1468" class="LineNr">1468 </span>    <span class="Identifier">h_complexity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(self, b, h_k) {
<span id="L1469" class="LineNr">1469 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-790">k_given</a>(b.<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>(), self.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b) <span class="Type">+</span> <span class="Constant">"|"</span> <span class="Type">+</span> h_k);
<span id="L1470" class="LineNr">1470 </span>    };
<span id="L1471" class="LineNr">1471 </span>
<span id="L1472" class="LineNr">1472 <a title="1.2.1.6.2.2.2" class="back_to_li" href="#t-1-2-1-6-2-2-2"><i class="fas fa-list-ol"></i></a><a title="1.2.1.6.2.2.3" class="back_to_li" href="#t-1-2-1-6-2-2-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">ambitiousness_with_hs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, hs_k) {
<span id="L1473" class="LineNr">1473 </span>    poss_d_stars <span class="Statement">:=</span> { poss_d_star <span class="Type">:</span> poss_d_star <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1511">supersets_lte</a>(b)
<span id="L1474" class="LineNr">1474 </span>                      <span class="Type">|</span> poss_d_star.<a class="Identifier code-proc-link" href="#da-455">is_valid</a>() <span class="Type">&amp;&amp;</span>
<span id="L1475" class="LineNr">1475 </span>                        poss_d_star.<span class="Identifier">is_implemented_by</span>(b) };
<span id="L1476" class="LineNr">1476 </span>    self <span class="Statement">:=</span> this; <span class="Comment">// workaround for setlx bug described in prob_distance</span>
<span id="L1477" class="LineNr">1477 </span>    poss_d_stars <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(poss_d_stars,
<span id="L1478" class="LineNr">1478 </span>      <span class="Type">procedure</span>(d_star_i, d_star_j) { <span class="Comment">// better_d_star</span>
<span id="L1479" class="LineNr">1479 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1495">d_star_sim</a>(self, b, hs_k, d_star_i) <span class="Type">-</span> d_star_i.<a class="Identifier code-proc-link" href="#da-866">incoherence</a>(b) <span class="Type">&gt;</span>
<span id="L1480" class="LineNr">1480 </span>               <span class="Identifier">d_star_sim</span>(self, b, hs_k, d_star_j) <span class="Type">-</span> d_star_j.<a class="Identifier code-proc-link" href="#da-866">incoherence</a>(b);
<span id="L1481" class="LineNr">1481 </span>      });
<span id="L1482" class="LineNr">1482 </span>    d_star <span class="Statement">:=</span> poss_d_stars[<span class="Constant">1</span>];
<span id="L1483" class="LineNr">1483 </span>
<span id="L1484" class="LineNr">1484 </span>    delta_incoh <span class="Statement">:=</span> ( d_star.<a class="Identifier code-proc-link" href="#da-866">incoherence</a>(b) <span class="Type">-</span> <a class="Identifier code-proc-link" href="#da-866">incoherence</a>(b) ) <span class="Type">/</span> <a class="Identifier code-proc-link" href="#da-866">incoherence</a>(b);
<span id="L1485" class="LineNr">1485 </span>    delta_irrat <span class="Statement">:=</span> ( d_star.<a class="Identifier code-proc-link" href="#da-789">instr_irrat</a>(b) <span class="Type">-</span> <a class="Identifier code-proc-link" href="#da-789">instr_irrat</a>(b) ) <span class="Type">/</span> <a class="Identifier code-proc-link" href="#da-789">instr_irrat</a>(b);
<span id="L1486" class="LineNr">1486 </span>    delta_compl <span class="Statement">:=</span> (<a class="Identifier code-proc-link" href="#l-769">k</a>(d_star.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b)) <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b))) <span class="Type">/</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b));
<span id="L1487" class="LineNr">1487 </span>    <span class="Comment">/* More incoherent and irrational -&gt; more ambitious</span>
<span id="L1488" class="LineNr">1488 </span><span class="Comment">         because it's like less of real Decision Algorithmic stuff left in h1</span>
<span id="L1489" class="LineNr">1489 </span><span class="Comment">       Larger complexity -&gt; less ambitious </span>
<span id="L1490" class="LineNr">1490 </span><span class="Comment">         because there's more Decision Algorithmic stuff left in hs_1 &amp; not in d</span>
<span id="L1491" class="LineNr">1491 </span><span class="Comment">         but maybe replace complexity with more like raw size? #states?  */</span>
<span id="L1492" class="LineNr">1492 </span>    <span class="Statement">return</span> delta_incoh <span class="Type">+</span> delta_irrat <span class="Type">-</span> delta_compl;
<span id="L1493" class="LineNr">1493 </span>  };
<span id="L1494" class="LineNr">1494 </span>
<span id="L1495" class="LineNr">1495 <a title="1.2.1.6.2.2.2.2" class="back_to_li" href="#t-1-2-1-6-2-2-2-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">d_star_sim</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(self, b, hs_k, d_star_k) {
<span id="L1496" class="LineNr">1496 </span>      raw_sim <span class="Statement">:=</span> (  <span class="Comment">// roughly, K(d*|d,h1) + K(d,h1|d*_s)</span>
<span id="L1497" class="LineNr">1497 </span>        <span class="Identifier">k_given</span>( d_star_k.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b), self.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b) <span class="Type">+</span> <span class="Constant">"|"</span> <span class="Type">+</span> hs_k[<span class="Constant">1</span>]) <span class="Type">+</span>
<span id="L1498" class="LineNr">1498 </span>        <span class="Identifier">k_given</span>( self.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b) <span class="Type">+</span> <span class="Constant">"|"</span> <span class="Type">+</span> hs_k[<span class="Constant">1</span>],
<span id="L1499" class="LineNr">1499 </span>                 d_star_k.<span class="Identifier">simplest_version</span>(b).<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b) )
<span id="L1500" class="LineNr">1500 </span>      );
<span id="L1501" class="LineNr">1501 </span>      <span class="Comment">/* Normalize. Best similarity is if 0 extra bits are required. </span>
<span id="L1502" class="LineNr">1502 </span><span class="Comment">         Worst is K(d*) + K(d); the given bits didn't help at all. */</span>
<span id="L1503" class="LineNr">1503 </span>      worst_sim <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(d_star_k.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b)) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(self.<a class="Identifier code-proc-link" href="#da-1400">df_to_str</a>(b));
<span id="L1504" class="LineNr">1504 </span>      <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">-</span> raw_sim <span class="Type">/</span> worst_sim;
<span id="L1505" class="LineNr">1505 </span>    };
<span id="L1506" class="LineNr">1506 </span>
<span id="L1507" class="LineNr">1507 </span>  <span class="Comment">/* Returns decision algorithms with # of possible states &lt;= #b.poss_states</span>
<span id="L1508" class="LineNr">1508 </span><span class="Comment">     which are "supersets" of self. It has additional variables and therefore</span>
<span id="L1509" class="LineNr">1509 </span><span class="Comment">     states, but when considering just the variables shared with self, it is </span>
<span id="L1510" class="LineNr">1510 </span><span class="Comment">     isomorphic to self.  */</span>
<span id="L1511" class="LineNr">1511 </span>  <span class="Identifier">supersets_lte</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1512" class="LineNr">1512 </span>    <span class="Statement">return</span> { d <span class="Type">:</span> d <span class="Type">in</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2299">all_lte</a>(<span class="Type">#</span>b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>())
<span id="L1513" class="LineNr">1513 </span>               <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1517">is_subset_of</a>(d) };
<span id="L1514" class="LineNr">1514 </span>  };
<span id="L1515" class="LineNr">1515 </span>
<span id="L1516" class="LineNr">1516 </span>  <span class="Comment">// Returns whether this decision algorithm is a "subset" of the given d</span>
<span id="L1517" class="LineNr">1517 <a title="1.2.1.6.2.2.2.1" class="back_to_li" href="#t-1-2-1-6-2-2-2-1"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">is_subset_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(d) {
<span id="L1518" class="LineNr">1518 </span>    <span class="Comment">// i, o, p, cp, u, m, m2, n, r, t_s, t_o</span>
<span id="L1519" class="LineNr">1519 </span>    var_pairs <span class="Statement">:=</span> { [i, d.i], [o, d.o], [p, d.p], [cp, d.cp],
<span id="L1520" class="LineNr">1520 </span>                   [u, d.u], [m, d.m], [m2, d.m2] };
<span id="L1521" class="LineNr">1521 </span>    vars_are_subsets <span class="Statement">:=</span> <span class="Type">forall</span>([vs, d_vs] <span class="Type">in</span> var_pairs <span class="Type">|</span> vs <span class="Type">&lt;</span> d_vs);
<span id="L1522" class="LineNr">1522 </span>    <span class="Statement">if</span> (<span class="Type">!</span>vars_are_subsets <span class="Type">||</span> <span class="Type">#</span>n <span class="Type">&gt;</span> <span class="Type">#</span>d.n) { <span class="Statement">return</span> <span class="Constant">false</span>; }
<span id="L1523" class="LineNr">1523 </span>
<span id="L1524" class="LineNr">1524 </span>    n_are_subsets <span class="Statement">:=</span> <span class="Type">forall</span>(j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>n] <span class="Type">|</span>
<span id="L1525" class="LineNr">1525 </span>                       <span class="Type">forall</span>(ltr <span class="Type">in</span> {<span class="Constant">'e'</span>,<span class="Constant">'m2'</span>,<span class="Constant">'o'</span>} <span class="Type">|</span>
<span id="L1526" class="LineNr">1526 </span>                         n[j][ltr] <span class="Type">&lt;</span> d.n[j][ltr] ));
<span id="L1527" class="LineNr">1527 </span>    <span class="Statement">if</span> (<span class="Type">!</span>n_are_subsets) { <span class="Statement">return</span> <span class="Constant">false</span>; }
<span id="L1528" class="LineNr">1528 </span>
<span id="L1529" class="LineNr">1529 </span>    <span class="Comment">/* For all transitions from a i+s state to a s+o state in self, it is the</span>
<span id="L1530" class="LineNr">1530 </span><span class="Comment">       case that any transition in d starting from a superset of i+s ends in</span>
<span id="L1531" class="LineNr">1531 </span><span class="Comment">       a d state that is a superset of the s+o state.  */</span>
<span id="L1532" class="LineNr">1532 </span>    <span class="Statement">return</span> <span class="Type">forall</span>([is, so] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-152">t</a>() <span class="Type">|</span>
<span id="L1533" class="LineNr">1533 </span>             <span class="Type">forall</span>(ccs <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-352">compatible_complete_states</a>(is, d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>()) <span class="Type">|</span>
<span id="L1534" class="LineNr">1534 </span>               <span class="Identifier">compat</span>(so, d.<a class="Identifier code-proc-link" href="#da-152">t</a>()[ccs])
<span id="L1535" class="LineNr">1535 </span>             )
<span id="L1536" class="LineNr">1536 </span>           );
<span id="L1537" class="LineNr">1537 </span>  };
<span id="L1538" class="LineNr">1538 </span>
<span id="L1539" class="LineNr">1539 </span>  <span class="Identifier">is_simplest_version</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1540" class="LineNr">1540 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1555">is_equal_to</a>(<a class="Identifier code-proc-link" href="#da-1548">simplest_version</a>(b));
<span id="L1541" class="LineNr">1541 </span>  };
<span id="L1542" class="LineNr">1542 </span>
<span id="L1543" class="LineNr">1543 </span>  <span class="Comment">/* Using simplest_version handles worries with using m as arbitrary data</span>
<span id="L1544" class="LineNr">1544 </span><span class="Comment">     to smuggle in unlabelled decision algorithmic information. Only the </span>
<span id="L1545" class="LineNr">1545 </span><span class="Comment">     decision algorithmic aspects of a decision algorithm should do the </span>
<span id="L1546" class="LineNr">1546 </span><span class="Comment">     explaining. This should also handle worries of higher-order utility</span>
<span id="L1547" class="LineNr">1547 </span><span class="Comment">     information being smuggled in within the memory variables.  */</span>
<span id="L1548" class="LineNr">1548 </span>  <span class="Identifier">simplest_version</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b) {
<span id="L1549" class="LineNr">1549 </span>    alt_ds <span class="Statement">:=</span> [ d <span class="Type">:</span> d <span class="Type">in</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2293">all</a>(b)
<span id="L1550" class="LineNr">1550 </span>                  <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1561">is_isomorphic_to</a>(d) <span class="Type">&amp;&amp;</span> d.<a class="Identifier code-proc-link" href="#da-293">is_implemented_by</a>(b) ];
<span id="L1551" class="LineNr">1551 </span>    alt_ds <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(alt_ds, decision_algorithm.simpler);
<span id="L1552" class="LineNr">1552 </span>    <span class="Statement">return</span> alt_ds[<span class="Constant">1</span>];
<span id="L1553" class="LineNr">1553 </span>  };
<span id="L1554" class="LineNr">1554 </span>
<span id="L1555" class="LineNr"><a href="#tda-165" data-file="test_decision_algorithm" title="test_is_equal_to" class="checkmark">&#10004;</a>1555 </span>  <span class="Identifier">is_equal_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(d) {
<span id="L1556" class="LineNr">1556 </span>    l1 <span class="Statement">:=</span> [  i,   o,   p,   cp,   u,   m,   m2,   n,   r,   t_s,   t_o];
<span id="L1557" class="LineNr">1557 </span>    l2 <span class="Statement">:=</span> [d.i, d.o, d.p, d.cp, d.u, d.m, d.m2, d.n, d.r, d.t_s, d.t_o];
<span id="L1558" class="LineNr">1558 </span>    <span class="Statement">return</span> l1 <span class="Type">==</span> l2;
<span id="L1559" class="LineNr">1559 </span>  };
<span id="L1560" class="LineNr">1560 </span>
<span id="L1561" class="LineNr">1561 </span>  <span class="Identifier">is_isomorphic_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(d) {
<span id="L1562" class="LineNr">1562 </span>    <span class="Comment">/* Everything but the memory variables is the same </span>
<span id="L1563" class="LineNr">1563 </span><span class="Comment">       And there is an isomorphism between m+m2 states and d.m+d.m2 states</span>
<span id="L1564" class="LineNr">1564 </span><span class="Comment">       Todo: Also add n minus m2s in n to simple equality comparison.</span>
<span id="L1565" class="LineNr">1565 </span><span class="Comment">    */</span>
<span id="L1566" class="LineNr">1566 </span>    l1 <span class="Statement">:=</span> [  i,   o,   x,   p,   cp,   u,   r,   t_s,   t_o];
<span id="L1567" class="LineNr">1567 </span>    l2 <span class="Statement">:=</span> [d.i, d.o, d.x, d.p, d.cp, d.u, d.r, d.t_s, d.t_o];
<span id="L1568" class="LineNr">1568 </span>    <span class="Statement">return</span> l1 <span class="Type">==</span> l2 <span class="Type">&amp;&amp;</span> <span class="Type">exists</span>(fm <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1572">possible_fms</a>(d) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-1597">fm_commutes</a>(fm, d));
<span id="L1569" class="LineNr">1569 </span>  };
<span id="L1570" class="LineNr">1570 </span>
<span id="L1571" class="LineNr">1571 </span>    <span class="Comment">// Todo: Also do higher-order m2s</span>
<span id="L1572" class="LineNr"><a href="#tda-1102" data-file="test_decision_algorithm" title="test_possible_fms" class="checkmark">&#10004;</a>1572 </span>    <span class="Identifier">possible_fms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(d) {
<span id="L1573" class="LineNr">1573 </span>      <span class="Comment">/* Construct the space of functions from states of m+m2 to d.m+d.m2,</span>
<span id="L1574" class="LineNr">1574 </span><span class="Comment">         respecting the m / m2 boundary */</span>
<span id="L1575" class="LineNr">1575 </span>      fm_ms  <span class="Statement">:=</span> {
<span id="L1576" class="LineNr">1576 </span>        { [ m_st <span class="Type">+</span> m2_st,  fm_m[m_st] <span class="Type">+</span> fm_m2[m2_st] ]
<span id="L1577" class="LineNr">1577 </span>          <span class="Type">:</span> [m_st, m2_st] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1332">poss_m_states</a>() <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#da-1336">poss_m2_states</a>() }
<span id="L1578" class="LineNr">1578 </span>        <span class="Type">:</span> [fm_m, fm_m2] <span class="Type">in</span>
<span id="L1579" class="LineNr">1579 </span>          <span class="Identifier">function_space</span>(<a class="Identifier code-proc-link" href="#l-328">possible_states</a>(m,  r), <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(d.m,  d.r)) <span class="Type">&gt;&lt;</span>
<span id="L1580" class="LineNr">1580 </span>          <span class="Identifier">function_space</span>(<a class="Identifier code-proc-link" href="#l-328">possible_states</a>(m2, r), <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(d.m2, d.r))
<span id="L1581" class="LineNr">1581 </span>      };
<span id="L1582" class="LineNr">1582 </span>
<span id="L1583" class="LineNr">1583 </span>      <span class="Comment">// For convenience map everything else onto its counterpart in d</span>
<span id="L1584" class="LineNr">1584 </span>      fms <span class="Statement">:=</span> {
<span id="L1585" class="LineNr">1585 </span>        { [iso, <span class="Identifier">apply_fm_m</span>(fm_m, iso) ] <span class="Type">:</span> iso <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(i<span class="Type">+</span><a class="Identifier code-proc-link" href="#da-123">s</a>()<span class="Type">+</span>o, r) }
<span id="L1586" class="LineNr">1586 </span>        <span class="Type">:</span> fm_m <span class="Type">in</span> fm_ms
<span id="L1587" class="LineNr">1587 </span>      };
<span id="L1588" class="LineNr">1588 </span>      <span class="Statement">return</span> fms;
<span id="L1589" class="LineNr">1589 </span>    };
<span id="L1590" class="LineNr">1590 </span>
<span id="L1591" class="LineNr">1591 </span>      <span class="Comment">// Todo: Also do higher-order m2s.</span>
<span id="L1592" class="LineNr"><a href="#tda-1120" data-file="test_decision_algorithm" title="test_apply_fm_m" class="checkmark">&#10004;</a>1592 </span>      <span class="Identifier">apply_fm_m</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(fm_m, iso) {
<span id="L1593" class="LineNr">1593 </span>        iso_m <span class="Statement">:=</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> iso <span class="Type">|</span> var <span class="Type">in</span> m <span class="Type">||</span> var <span class="Type">in</span> m2 };
<span id="L1594" class="LineNr">1594 </span>        <span class="Statement">return</span> { [v, iso[v]] <span class="Type">:</span> v <span class="Type">in</span> i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> o <span class="Type">-</span> m <span class="Type">-</span> m2 } <span class="Type">+</span> fm_m[iso_m];
<span id="L1595" class="LineNr">1595 </span>      };
<span id="L1596" class="LineNr">1596 </span>
<span id="L1597" class="LineNr"><a href="#tda-1121" data-file="test_decision_algorithm" title="test_fm_commutes" class="checkmark">&#10004;</a>1597 </span>    <span class="Identifier">fm_commutes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(fm, d) {
<span id="L1598" class="LineNr">1598 </span>      <span class="Comment">// Restrict fm to just i + s() variables</span>
<span id="L1599" class="LineNr">1599 </span>      fm_is <span class="Statement">:=</span> { [{ [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> iso1 <span class="Type">|</span> var <span class="Type">in</span> i <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() },
<span id="L1600" class="LineNr">1600 </span>                  { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> iso2 <span class="Type">|</span> var <span class="Type">in</span> d.i <span class="Type">+</span> d.<a class="Identifier code-proc-link" href="#da-123">s</a>() }]
<span id="L1601" class="LineNr">1601 </span>                    <span class="Type">:</span> [iso1, iso2] <span class="Type">in</span> fm };
<span id="L1602" class="LineNr">1602 </span>      <span class="Comment">// Restrict fm to just s() + o variables</span>
<span id="L1603" class="LineNr">1603 </span>      fm_so <span class="Statement">:=</span> { [{ [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> iso1 <span class="Type">|</span> var <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> o },
<span id="L1604" class="LineNr">1604 </span>                  { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> iso2 <span class="Type">|</span> var <span class="Type">in</span> d.<a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">+</span> d.o }]
<span id="L1605" class="LineNr">1605 </span>                    <span class="Type">:</span> [iso1, iso2] <span class="Type">in</span> fm };
<span id="L1606" class="LineNr">1606 </span>      <span class="Statement">return</span> { fm_so[ <a class="Identifier code-proc-link" href="#da-152">t</a>()[g_is] ] <span class="Type">==</span> <a class="Identifier code-proc-link" href="#da-152">t</a>()[ fm_is[g_is] ] <span class="Type">:</span> [g_is, h_so] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-152">t</a>()
<span id="L1607" class="LineNr">1607 </span>             } <span class="Type">==</span> { <span class="Constant">true</span> };
<span id="L1608" class="LineNr">1608 </span>    };
<span id="L1609" class="LineNr">1609 </span>
<span id="L1610" class="LineNr">1610 </span><span class="Comment Heading">// Rationality</span>
<span id="L1611" class="LineNr">1611 </span><span class="Comment Heading">// ===========</span>
<span id="L1612" class="LineNr">1612 </span>
<span id="L1613" class="LineNr">1613 </span>  <span class="Comment Heading">/* Rational Utility Function</span>
<span id="L1614" class="LineNr">1614 </span><span class="Comment Heading">     -------------------------</span>
<span id="L1615" class="LineNr">1615 </span><span class="Comment">     Takes the world w and brain b and collects all possible continuations of</span>
<span id="L1616" class="LineNr">1616 </span><span class="Comment">     brain/decision states using bs_msr_paths. Then it weights them by </span>
<span id="L1617" class="LineNr">1617 </span><span class="Comment">     agential_identity, optimal_rxs, and subjective likelihood and finds the </span>
<span id="L1618" class="LineNr">1618 </span><span class="Comment">     center-of-mass / social-choice of the resulting first order utility </span>
<span id="L1619" class="LineNr">1619 </span><span class="Comment">     functions. </span>
<span id="L1620" class="LineNr">1620 </span>
<span id="L1621" class="LineNr">1621 </span><span class="Comment">     This comes out of the metaethical view developed by Howard Nye and June</span>
<span id="L1622" class="LineNr">1622 </span><span class="Comment">     Ku and written up at <a href="http://www.metaethical.ai/norm_descriptivism.pdf" target="_blank">http://www.metaethical.ai/norm_descriptivism.pdf</a>. </span>
<span id="L1623" class="LineNr">1623 </span><span class="Comment">     There we focused on the simple case in which the norms we accept or our</span>
<span id="L1624" class="LineNr">1624 </span><span class="Comment">     higher-order preferences formed a hierarchy with a single fundamental norm </span>
<span id="L1625" class="LineNr">1625 </span><span class="Comment">     or highest-order utility function governing our lower-order norms /</span>
<span id="L1626" class="LineNr">1626 </span><span class="Comment">     functions. (Also see the comments above n := n towards the top.) In that </span>
<span id="L1627" class="LineNr">1627 </span><span class="Comment">     case, what we have most reason to do would be what that highest order </span>
<span id="L1628" class="LineNr">1628 </span><span class="Comment">     utility function would prescribe, perhaps through the prescription of </span>
<span id="L1629" class="LineNr">1629 </span><span class="Comment">     certain lower-level utilty functions.</span>
<span id="L1630" class="LineNr">1630 </span>
<span id="L1631" class="LineNr">1631 </span><span class="Comment">     Elsewhere, we have acknowledged that things might be more complicated. We </span>
<span id="L1632" class="LineNr">1632 </span><span class="Comment">     might have a network of accepted norms / higher-order preferences in which </span>
<span id="L1633" class="LineNr">1633 </span><span class="Comment">     they all influence one another rather than a strict top-down hierarchy.</span>
<span id="L1634" class="LineNr">1634 </span><span class="Comment">     We have suggested that in that case, the weights of each accepted norm and</span>
<span id="L1635" class="LineNr">1635 </span><span class="Comment">     the parameters governing the network behavior could be treated as the </span>
<span id="L1636" class="LineNr">1636 </span><span class="Comment">     fundamental norm. Developing this further, we might model it as a markov </span>
<span id="L1637" class="LineNr">1637 </span><span class="Comment">     model with states of norm acceptances influencing other acceptances and </span>
<span id="L1638" class="LineNr">1638 </span><span class="Comment">     look for a stationary distribution, i.e. an equilibrium state in which the </span>
<span id="L1639" class="LineNr">1639 </span><span class="Comment">     state it transitions to is the same state it started with. </span>
<span id="L1640" class="LineNr">1640 </span>
<span id="L1641" class="LineNr">1641 </span><span class="Comment">     However, even that makes a simplifying assumption that the network </span>
<span id="L1642" class="LineNr">1642 </span><span class="Comment">     topology of which norms influence which others remains constant. But if </span>
<span id="L1643" class="LineNr">1643 </span><span class="Comment">     we imagine a brain's behavior in response to varying inputs, it seems</span>
<span id="L1644" class="LineNr">1644 </span><span class="Comment">     likely that sometimes, which higher-order preferences influence which </span>
<span id="L1645" class="LineNr">1645 </span><span class="Comment">     others would also vary. To handle this, we implement a parliamentary model</span>
<span id="L1646" class="LineNr">1646 </span><span class="Comment">     to aggregate the various influences across different possible </span>
<span id="L1647" class="LineNr">1647 </span><span class="Comment">     continuations of the agent. </span>
<span id="L1648" class="LineNr">1648 </span><span class="Comment">       This is inspired by Nick Bostrom and Toby Ord on Parliamentary Models </span>
<span id="L1649" class="LineNr">1649 </span><span class="Comment">     for Moral Uncertainty. Although it's applied in a different context, it's</span>
<span id="L1650" class="LineNr">1650 </span><span class="Comment">     similar in that both are aggregating many utility functions into one.</span>
<span id="L1651" class="LineNr">1651 </span><span class="Comment">     <a href="http://www.overcomingbias.com/2009/01/moral-uncertainty-towards-a-solution.html" target="_blank">http://www.overcomingbias.com/2009/01/moral-uncertainty-towards-a-solution.html</a></span>
<span id="L1652" class="LineNr">1652 </span>
<span id="L1653" class="LineNr">1653 </span><span class="Comment">     In the end, this does bring us closer to the ideal response / advisor</span>
<span id="L1654" class="LineNr">1654 </span><span class="Comment">     family of metaethical theories but I think our focus on the influence of</span>
<span id="L1655" class="LineNr">1655 </span><span class="Comment">     optimal normative judgments remains distinctive and arguably avoids some</span>
<span id="L1656" class="LineNr">1656 </span><span class="Comment">     worries. We are reading off the first-order utility function from ideal</span>
<span id="L1657" class="LineNr">1657 </span><span class="Comment">     selves rather than the actions so we have less distortion from the </span>
<span id="L1658" class="LineNr">1658 </span><span class="Comment">     idealization process to worry about since there's less to change. We</span>
<span id="L1659" class="LineNr">1659 </span><span class="Comment">     address remaining worries about distortion with agential identity to </span>
<span id="L1660" class="LineNr">1660 </span><span class="Comment">     measure how much one remains the same agent. </span>
<span id="L1661" class="LineNr">1661 </span>
<span id="L1662" class="LineNr">1662 </span><span class="Comment">     The idealization is mostly done by weighting more heavily selves who are</span>
<span id="L1663" class="LineNr">1663 </span><span class="Comment">     the result of normative judgments that best satisfy the decision criteria</span>
<span id="L1664" class="LineNr">1664 </span><span class="Comment">     governing them. We also incorporate subjective likelihood of the inputs</span>
<span id="L1665" class="LineNr">1665 </span><span class="Comment">     determining possible continuations to factor in normal operating </span>
<span id="L1666" class="LineNr">1666 </span><span class="Comment">     conditions without letting in external factors and violating supervenience</span>
<span id="L1667" class="LineNr">1667 </span><span class="Comment">     on just the brain.</span>
<span id="L1668" class="LineNr">1668 </span><span class="Comment">  */</span>
<span id="L1669" class="LineNr">1669 <a title="1.2" class="back_to_li" href="#t-1-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">ruf</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b) {
<span id="L1670" class="LineNr">1670 </span>    t_z <span class="Statement">:=</span> <span class="Constant">10</span> <span class="Type">**</span> <span class="Constant">9</span>; <span class="Comment">// Number of time steps of continuations to consider</span>
<span id="L1671" class="LineNr">1671 </span>    <span class="Comment">/* Todo: Find a more principled way</span>
<span id="L1672" class="LineNr">1672 </span><span class="Comment">         * "Ask" each branch how much longer to continue?</span>
<span id="L1673" class="LineNr">1673 </span><span class="Comment">         * Compute infinitely but in a way that asymptotes? </span>
<span id="L1674" class="LineNr">1674 </span><span class="Comment">         * Keep computing until it converges, with minimum time? </span>
<span id="L1675" class="LineNr">1675 </span><span class="Comment">             If it never converges? */</span>
<span id="L1676" class="LineNr">1676 </span>
<span id="L1677" class="LineNr">1677 </span>    <span class="Comment">// Poss social choice utility functions</span>
<span id="L1678" class="LineNr">1678 </span>    psc_u_dom <span class="Statement">:=</span> <span class="Identifier">domain</span>(p) <span class="Type">+</span> <span class="Identifier">domain</span>(u);
<span id="L1679" class="LineNr">1679 </span>    psc_u_rng <span class="Statement">:=</span> r[<span class="Identifier">first</span>(<span class="Identifier">range</span>(u))] <span class="Type">+</span> { <span class="Constant">om</span> };
<span id="L1680" class="LineNr">1680 </span>    psc_us <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ { [expr, r_i] <span class="Type">:</span> r_i <span class="Type">in</span> psc_u_rng }
<span id="L1681" class="LineNr">1681 </span>                        <span class="Type">:</span> expr <span class="Type">in</span> psc_u_dom });
<span id="L1682" class="LineNr">1682 </span>    psc_us <span class="Statement">:=</span> { { [expr, r_i] <span class="Type">:</span> [expr, r_i] <span class="Type">in</span> psc_u <span class="Type">|</span> r_i <span class="Type">!=</span> <span class="Constant">om</span> }
<span id="L1683" class="LineNr">1683 </span>                <span class="Type">:</span> psc_u <span class="Type">in</span> psc_us }; <span class="Comment">// filter out om</span>
<span id="L1684" class="LineNr">1684 </span>    state_space <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-647">exprs_to_state_space</a>(psc_u_dom);
<span id="L1685" class="LineNr">1685 </span>
<span id="L1686" class="LineNr">1686 </span>    voter_wts <span class="Statement">:=</span> {};
<span id="L1687" class="LineNr">1687 </span>    t_i <span class="Statement">:=</span> <span class="Constant">1</span>;
<span id="L1688" class="LineNr">1688 </span>    bs1 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-409">drop_time</a>(b.a[b.n]);
<span id="L1689" class="LineNr">1689 </span>    <span class="Statement">while</span> (t_i <span class="Type">&lt;=</span> t_z) {
<span id="L1690" class="LineNr">1690 </span>      bmps <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2208">bs_msr_paths</a>(w, b, bs1, t_i);
<span id="L1691" class="LineNr">1691 </span>      voter_wts <span class="Statement">:=</span> voter_wts <span class="Type">+</span> {
<span id="L1692" class="LineNr">1692 </span>        [ <span class="Comment">// voter util func</span>
<span id="L1693" class="LineNr">1693 </span>          <span class="Identifier">additive_to_ordinal</span>( <a class="Identifier code-proc-link" href="#da-262">f</a>(b)[<span class="Identifier">first</span>(<span class="Identifier">last</span>(bmp))], <span class="Constant">0</span>, state_space),
<span id="L1694" class="LineNr">1694 </span>          <span class="Identifier">time_wt</span>(t_i) <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-1708">voter_weight</a>(w, b, bmp) ] <span class="Comment">// voter weight</span>
<span id="L1695" class="LineNr">1695 </span>        <span class="Type">:</span> bmp <span class="Type">in</span> <span class="Identifier">last</span>(bmps)
<span id="L1696" class="LineNr">1696 </span>      };
<span id="L1697" class="LineNr">1697 </span>      t_i <span class="Statement">:=</span> t_i <span class="Type">+</span> <span class="Constant">1</span>;
<span id="L1698" class="LineNr">1698 </span>    }
<span id="L1699" class="LineNr">1699 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(psc_us,
<span id="L1700" class="LineNr">1700 </span>                    <span class="Type">procedure</span>(psc_u1, psc_u2) {
<span id="L1701" class="LineNr">1701 </span>                      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1723">rat_psc_dist</a>(voter_wts, psc_u1, state_space) <span class="Type">&lt;</span>
<span id="L1702" class="LineNr">1702 </span>                             <span class="Identifier">rat_psc_dist</span>(voter_wts, psc_u2, state_space);
<span id="L1703" class="LineNr">1703 </span>                    })[<span class="Constant">1</span>];
<span id="L1704" class="LineNr">1704 </span>  };
<span id="L1705" class="LineNr">1705 </span>
<span id="L1706" class="LineNr">1706 </span>    <span class="Identifier">time_wt</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(t_i) { <span class="Statement">return</span> <span class="Constant">1</span>; }; <span class="Comment">// Placeholder constant function</span>
<span id="L1707" class="LineNr">1707 </span>
<span id="L1708" class="LineNr">1708 <a title="1.2.3.5.2.1" class="back_to_li" href="#t-1-2-3-5-2-1"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">voter_weight</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, bmp) {
<span id="L1709" class="LineNr">1709 </span>      msr <span class="Statement">:=</span> <span class="Identifier">last</span>(<span class="Identifier">last</span>(bmp));
<span id="L1710" class="LineNr">1710 </span>      bss <span class="Statement">:=</span> [ bs <span class="Type">:</span> [bs, msr] <span class="Type">in</span> bmp ]; <span class="Comment">// Brain StateS</span>
<span id="L1711" class="LineNr">1711 </span>
<span id="L1712" class="LineNr">1712 </span>      cached_ref <span class="Statement">:=</span> <span class="Constant">om</span>;
<span id="L1713" class="LineNr">1713 </span>      wb <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1730">new_wb</a>(w, b, bss);
<span id="L1714" class="LineNr">1714 </span>      w2 <span class="Statement">:=</span> <span class="Identifier">first</span>(wb);
<span id="L1715" class="LineNr">1715 </span>      b2 <span class="Statement">:=</span> <span class="Identifier">last</span>(wb);
<span id="L1716" class="LineNr">1716 </span>
<span id="L1717" class="LineNr">1717 </span>      dss <span class="Statement">:=</span> [ <a class="Identifier code-proc-link" href="#da-262">f</a>(b2)[bs] <span class="Type">:</span> bs <span class="Type">in</span> bss ];
<span id="L1718" class="LineNr">1718 </span>      agential_id <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1906">agential_identity</a>(dss, w2, b2);
<span id="L1719" class="LineNr">1719 </span>      <span class="Statement">return</span> msr <span class="Type">*</span> agential_id <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-1750">optimal_rxs</a>(w2, b2, dss);
<span id="L1720" class="LineNr">1720 </span>    };
<span id="L1721" class="LineNr">1721 </span>
<span id="L1722" class="LineNr">1722 </span>    <span class="Comment">// Possible Social Choice for Rationality (as opposed to in optimal_rxs)</span>
<span id="L1723" class="LineNr">1723 </span>    <span class="Identifier">rat_psc_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(voter_wts, psc_u, state_space) {
<span id="L1724" class="LineNr">1724 </span>      card_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-635">add_u_to_card_u</a>(psc_u, state_space);
<span id="L1725" class="LineNr">1725 </span>      ord_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>( card_u, <span class="Identifier">domain</span>(card_u), r[<span class="Identifier">first</span>(p)] );
<span id="L1726" class="LineNr">1726 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { voter_wts[voter] <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-674">ord_u_dist</a>(voter, ord_u) <span class="Type">**</span> <span class="Constant">2</span>
<span id="L1727" class="LineNr">1727 </span>                  <span class="Type">:</span> voter <span class="Type">in</span> <span class="Identifier">domain</span>(voter_wts) };
<span id="L1728" class="LineNr">1728 </span>    };
<span id="L1729" class="LineNr">1729 </span>
<span id="L1730" class="LineNr">1730 </span>  <span class="Identifier">new_wb</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, bss) {
<span id="L1731" class="LineNr">1731 </span>    b2   <span class="Statement">:=</span> b;
<span id="L1732" class="LineNr">1732 </span>    b2.a <span class="Statement">:=</span> b2.a <span class="Type">+</span> [<a class="Identifier code-proc-link" href="#l-403">assign_time</a>(bss[t_j], b.n <span class="Type">+</span> t_j) <span class="Type">:</span> t_j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>bss]];
<span id="L1733" class="LineNr">1733 </span>    b2.n <span class="Statement">:=</span> <span class="Type">#</span>(b2.a);
<span id="L1734" class="LineNr">1734 </span>
<span id="L1735" class="LineNr">1735 </span>    w2   <span class="Statement">:=</span> w;
<span id="L1736" class="LineNr">1736 </span>    w2.a <span class="Statement">:=</span> w2.a <span class="Type">+</span> [<a class="Identifier code-proc-link" href="#l-403">assign_time</a>(bss[t_j], b.n <span class="Type">+</span> t_j) <span class="Type">:</span> t_j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>bss]];
<span id="L1737" class="LineNr">1737 </span>    w2.n <span class="Statement">:=</span> <span class="Type">#</span>(w2.a);
<span id="L1738" class="LineNr">1738 </span>
<span id="L1739" class="LineNr">1739 </span>    <span class="Statement">return</span> [w, b];
<span id="L1740" class="LineNr">1740 </span>  };
<span id="L1741" class="LineNr">1741 </span>
<span id="L1742" class="LineNr">1742 </span>  <span class="Comment Heading">/* Optimal Normative Judgments / Prescriptions</span>
<span id="L1743" class="LineNr">1743 </span><span class="Comment Heading">     -------------------------------------------</span>
<span id="L1744" class="LineNr">1744 </span><span class="Comment">     Returns a score for how much the list of decision states has had outputs</span>
<span id="L1745" class="LineNr">1745 </span><span class="Comment">     of higher-order utility functions (i.e. normative judgments / </span>
<span id="L1746" class="LineNr">1746 </span><span class="Comment">     prescriptions) that maximized higher-order utility. If the state space</span>
<span id="L1747" class="LineNr">1747 </span><span class="Comment">     of prescriptions (n[j]['o']) overlap, we favor those states voted for by </span>
<span id="L1748" class="LineNr">1748 </span><span class="Comment">     more accepted norms through a synchronic social choice function.</span>
<span id="L1749" class="LineNr">1749 </span><span class="Comment">  */</span>
<span id="L1750" class="LineNr">1750 <a title="1.2.3.4" class="back_to_li" href="#t-1-2-3-4"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">optimal_rxs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, dss) {
<span id="L1751" class="LineNr">1751 </span>    opts <span class="Statement">:=</span> [ <a class="Identifier code-proc-link" href="#da-1762">optimality</a>(w, b, dss[j], dss[j<span class="Type">+</span><span class="Constant">1</span>], b.n <span class="Type">-</span> (<span class="Type">#</span>dss <span class="Type">-</span> j) )
<span id="L1752" class="LineNr">1752 </span>              <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>(<span class="Type">#</span>dss <span class="Type">-</span> <span class="Constant">1</span>)] ];
<span id="L1753" class="LineNr">1753 </span>    <span class="Statement">return</span> <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-10">min</a>(opts) <span class="Type">+</span> <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>(opts);
<span id="L1754" class="LineNr">1754 </span>  };
<span id="L1755" class="LineNr">1755 </span>
<span id="L1756" class="LineNr">1756 </span>    <span class="Identifier">ue_state_space</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1757" class="LineNr">1757 </span>      base_exprs <span class="Statement">:=</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-2160">ue_base_exprs</a>(j) <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>n] };
<span id="L1758" class="LineNr">1758 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ { [subform, <span class="Constant">true</span>], [subform, <span class="Constant">false</span>] }
<span id="L1759" class="LineNr">1759 </span>                       <span class="Type">:</span> subform <span class="Type">in</span> base_exprs });
<span id="L1760" class="LineNr">1760 </span>    };
<span id="L1761" class="LineNr">1761 </span>
<span id="L1762" class="LineNr">1762 </span>    <span class="Identifier">optimality</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, ds, ds2, t_i) {
<span id="L1763" class="LineNr">1763 </span>      <span class="Comment">/* Social choice to balance multiple synchronic utility functions if</span>
<span id="L1764" class="LineNr">1764 </span><span class="Comment">         they conflict.  */</span>
<span id="L1765" class="LineNr">1765 </span>      ord_us <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#da-2168">additive_to_ordinal</a>(ds, j, <a class="Identifier code-proc-link" href="#da-1756">ue_state_space</a>()) <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>n] };
<span id="L1766" class="LineNr">1766 </span>      sync_psc_us <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ { [state, r_i] <span class="Type">:</span> r_i <span class="Type">in</span> r[<span class="Identifier">first</span>(<span class="Identifier">range</span>(u))] }
<span id="L1767" class="LineNr">1767 </span>                               <span class="Type">:</span> state <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1756">ue_state_space</a>() });
<span id="L1768" class="LineNr">1768 </span>      sc_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(psc_us,
<span id="L1769" class="LineNr">1769 </span>                       <span class="Type">procedure</span>(psc_u1, psc_u2) {
<span id="L1770" class="LineNr">1770 </span>                         <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-1795">sync_psc_dist</a>(ord_us, psc_u1) <span class="Type">&lt;</span>
<span id="L1771" class="LineNr">1771 </span>                                <span class="Identifier">sync_psc_dist</span>(ord_us, psc_u2);
<span id="L1772" class="LineNr">1772 </span>                       })[<span class="Constant">1</span>];
<span id="L1773" class="LineNr">1773 </span>
<span id="L1774" class="LineNr">1774 </span>      n_o_vars <span class="Statement">:=</span> <span class="Type">+/</span> { n_i[<span class="Constant">'o'</span>] <span class="Type">:</span> n_i <span class="Type">in</span> n }; <span class="Comment">// Prescription vars</span>
<span id="L1775" class="LineNr">1775 </span>      <span class="Comment">// Observed state of those vars in ds2</span>
<span id="L1776" class="LineNr">1776 </span>      obs_rxs <span class="Statement">:=</span> { [n_o_var, ds2[n_o_var]] <span class="Type">:</span> n_o_var <span class="Type">in</span> n_o_vars };
<span id="L1777" class="LineNr">1777 </span>
<span id="L1778" class="LineNr">1778 </span>      <span class="Comment">// Collect all possible prescriptions along with their (higher) utilities.</span>
<span id="L1779" class="LineNr">1779 </span>      util_rxs <span class="Statement">:=</span> {
<span id="L1780" class="LineNr">1780 </span>        [rxs, <span class="Identifier">util_of_rxs</span>(w, b, t_i, ds, ds2, psc_base_exprs, sc_u, rxs)]
<span id="L1781" class="LineNr">1781 </span>        <span class="Type">:</span> rxs <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-2031">poss_rx_states</a>()
<span id="L1782" class="LineNr">1782 </span>      };
<span id="L1783" class="LineNr">1783 </span>      <span class="Comment">// Sort them by optimality.</span>
<span id="L1784" class="LineNr">1784 </span>      util_rxs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-716">sort_set</a>(util_rxs, <span class="Type">procedure</span>(rxs_u1, rxs_u2) {
<span id="L1785" class="LineNr">1785 </span>                                       <span class="Statement">return</span> <span class="Identifier">last</span>(rxs_u1) <span class="Type">&gt;</span> <span class="Identifier">last</span>(rxs_u2);
<span id="L1786" class="LineNr">1786 </span>                                     });
<span id="L1787" class="LineNr">1787 </span>      <span class="Comment">// Return a normalized score for the obs_rxs by their percentile rank.</span>
<span id="L1788" class="LineNr">1788 </span>      <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-24">index_of</a>(
<span id="L1789" class="LineNr">1789 </span>        [ obs_rxs,
<span id="L1790" class="LineNr">1790 </span>          <span class="Identifier">util_of_rxs</span>(w, b, t_i, ds, ds2, psc_base_exprs, sc_u, obs_rxs) ],
<span id="L1791" class="LineNr">1791 </span>        util_rxs
<span id="L1792" class="LineNr">1792 </span>      ) <span class="Type">/</span> <span class="Type">#</span>util_rxs;
<span id="L1793" class="LineNr">1793 </span>    }; <span class="Comment">// end optimality</span>
<span id="L1794" class="LineNr">1794 </span>
<span id="L1795" class="LineNr">1795 </span>      <span class="Identifier">sync_psc_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ord_us, sync_psc_u) {
<span id="L1796" class="LineNr">1796 </span>        ord_psc_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>(sync_psc_u, <span class="Identifier">domain</span>(sync_psc_u),
<span id="L1797" class="LineNr">1797 </span>                                                 r[<span class="Identifier">first</span>(p)] );
<span id="L1798" class="LineNr">1798 </span>        <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-674">ord_u_dist</a>(ord_u, ord_psc_u) <span class="Type">**</span> <span class="Constant">2</span> <span class="Type">:</span> ord_u <span class="Type">in</span> ord_us };
<span id="L1799" class="LineNr">1799 </span>      };
<span id="L1800" class="LineNr">1800 </span>
<span id="L1801" class="LineNr">1801 </span>      <span class="Identifier">util_of_rxs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds, ds2, psc_base_exprs, sc_u, rxs) {
<span id="L1802" class="LineNr">1802 </span>        <span class="Comment">/* For the sake of simplicity, we assume that higher-order utilities </span>
<span id="L1803" class="LineNr">1803 </span><span class="Comment">           depend on only intrinsic properties of brains / decision algorithms.</span>
<span id="L1804" class="LineNr">1804 </span><span class="Comment">           This means that being given the future brain states bss is </span>
<span id="L1805" class="LineNr">1805 </span><span class="Comment">           sufficient to tell us the utility of various prescriptions under </span>
<span id="L1806" class="LineNr">1806 </span><span class="Comment">           this assumed future. This assumption can be quite plausible for </span>
<span id="L1807" class="LineNr">1807 </span><span class="Comment">           higher-order utilities that enforce consistency, coherence or some</span>
<span id="L1808" class="LineNr">1808 </span><span class="Comment">           form of reflective equilibrium. If we abandon this assumption, we</span>
<span id="L1809" class="LineNr">1809 </span><span class="Comment">           may need to model a set of possible worlds and a probability </span>
<span id="L1810" class="LineNr">1810 </span><span class="Comment">           distribution or measure over them.</span>
<span id="L1811" class="LineNr">1811 </span>
<span id="L1812" class="LineNr">1812 </span><span class="Comment">           We might typically expect higher-order utilities to be placed in </span>
<span id="L1813" class="LineNr">1813 </span><span class="Comment">           some change in lower-order utility and then a recognition that some</span>
<span id="L1814" class="LineNr">1814 </span><span class="Comment">           prescription would more-or-less immediately cause that change would </span>
<span id="L1815" class="LineNr">1815 </span><span class="Comment">           cause the prescription and in turn, the intended change. But since</span>
<span id="L1816" class="LineNr">1816 </span><span class="Comment">           we can neither assume that the higher-order utility is placed in </span>
<span id="L1817" class="LineNr">1817 </span><span class="Comment">           a specific, concrete lower-order utility change in the near future as</span>
<span id="L1818" class="LineNr">1818 </span><span class="Comment">           opposed to more open-ended properties nor assume the immediacy of the</span>
<span id="L1819" class="LineNr">1819 </span><span class="Comment">           prescription's causation of a lower-order utility change, we just </span>
<span id="L1820" class="LineNr">1820 </span><span class="Comment">           look very far into the future and sum up the utility of any events </span>
<span id="L1821" class="LineNr">1821 </span><span class="Comment">           in that 4-dimensional space-time block that would be included in the</span>
<span id="L1822" class="LineNr">1822 </span><span class="Comment">           reference of higher-order utility expressions. Since the network</span>
<span id="L1823" class="LineNr">1823 </span><span class="Comment">           topology of the higher-order utility functions may be path dependent,</span>
<span id="L1824" class="LineNr">1824 </span><span class="Comment">           we also use the bs_msr_paths to aggregate over the different futures</span>
<span id="L1825" class="LineNr">1825 </span><span class="Comment">           made possible by various input states weighted by their subjective</span>
<span id="L1826" class="LineNr">1826 </span><span class="Comment">           likelihood.</span>
<span id="L1827" class="LineNr">1827 </span><span class="Comment">        */</span>
<span id="L1828" class="LineNr">1828 </span>        new_ds2 <span class="Statement">:=</span> rxs <span class="Type">+</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> ds2
<span id="L1829" class="LineNr">1829 </span>                                      <span class="Type">|</span> <span class="Type">!</span>(var <span class="Type">in</span> <span class="Identifier">domain</span>(rxs)) };
<span id="L1830" class="LineNr">1830 </span>        bs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-239">inv</a>(<a class="Identifier code-proc-link" href="#da-262">f</a>(b))[new_ds2];
<span id="L1831" class="LineNr">1831 </span>        bmps <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2208">bs_msr_paths</a>(w, b, bs, <span class="Constant">10</span> <span class="Type">**</span> <span class="Constant">9</span>);
<span id="L1832" class="LineNr">1832 </span>        future_wts <span class="Statement">:=</span> {                      <span class="Comment">// collect a ... </span>
<span id="L1833" class="LineNr">1833 </span>          [ [<span class="Identifier">first</span>(bs_msr) <span class="Type">:</span> bs_msr <span class="Type">in</span> bmp], <span class="Comment">// list of brain states, bss,</span>
<span id="L1834" class="LineNr">1834 </span>            <span class="Identifier">last</span>(<span class="Identifier">last</span>(bmp)) ]                <span class="Comment">// &amp; measure from the final state</span>
<span id="L1835" class="LineNr">1835 </span>          <span class="Type">:</span> bmp <span class="Type">in</span> <span class="Identifier">last</span>(bmps)                <span class="Comment">// for each bs_msr_path</span>
<span id="L1836" class="LineNr">1836 </span>        }; <span class="Comment">// to get { [bss, msr], ... }</span>
<span id="L1837" class="LineNr">1837 </span>
<span id="L1838" class="LineNr">1838 </span>        <span class="Statement">return</span> <span class="Type">+/</span> {
<span id="L1839" class="LineNr">1839 </span>          msr <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-1844">util_of_future</a>(w, b, t_i, ds, psc_base_exprs, sc_u, bss)
<span id="L1840" class="LineNr">1840 </span>          <span class="Type">:</span> [bss, msr] <span class="Type">in</span> future_wts
<span id="L1841" class="LineNr">1841 </span>        };
<span id="L1842" class="LineNr">1842 </span>      }; <span class="Comment">// end util_of_rxs</span>
<span id="L1843" class="LineNr">1843 </span>
<span id="L1844" class="LineNr">1844 </span>        <span class="Identifier">util_of_future</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds, psc_base_exprs, sc_u, bss) {
<span id="L1845" class="LineNr">1845 </span>          wb <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1730">new_wb</a>(w, b, bss);
<span id="L1846" class="LineNr">1846 </span>          w2 <span class="Statement">:=</span> <span class="Identifier">first</span>(wb);
<span id="L1847" class="LineNr">1847 </span>          b2 <span class="Statement">:=</span> <span class="Identifier">last</span>(wb);
<span id="L1848" class="LineNr">1848 </span>
<span id="L1849" class="LineNr">1849 </span>          future_state <span class="Statement">:=</span> { [expr, <a class="Identifier code-proc-link" href="#da-1855">eval_expr</a>(w2, b2, t_i, ds, bss, expr)]
<span id="L1850" class="LineNr">1850 </span>                            <span class="Type">:</span> expr <span class="Type">in</span> psc_base_exprs };
<span id="L1851" class="LineNr">1851 </span>          <span class="Statement">return</span> sc_u[future_state];
<span id="L1852" class="LineNr">1852 </span>        };
<span id="L1853" class="LineNr">1853 </span>
<span id="L1854" class="LineNr">1854 </span>        <span class="Comment">// Returns a boolean for whether the expr is true in that future</span>
<span id="L1855" class="LineNr">1855 </span>        <span class="Identifier">eval_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds, bss, expr) {
<span id="L1856" class="LineNr">1856 </span>          p_var <span class="Statement">:=</span> p[expr];
<span id="L1857" class="LineNr">1857 </span>          p_event <span class="Statement">:=</span> { [p_var, ds[p_var]] };
<span id="L1858" class="LineNr">1858 </span>          b_event <span class="Statement">:=</span> <span class="Identifier">first</span>( <a class="Identifier code-proc-link" href="#da-407">lf_inv_at</a>(b,t_i)[p_event] );
<span id="L1859" class="LineNr">1859 </span>          ref_b_event <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-538">ref</a>(w,b)[b_event];
<span id="L1860" class="LineNr">1860 </span>          disjuncts <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>(w.<a class="Identifier code-proc-link" href="#cmm-96">actual_state</a>(), disjunct)
<span id="L1861" class="LineNr">1861 </span>                         <span class="Type">:</span> disjunct <span class="Type">in</span> ref_b_event };
<span id="L1862" class="LineNr">1862 </span>          <span class="Statement">return</span> <span class="Type">#</span>{ disj <span class="Type">:</span> disj <span class="Type">in</span> disjuncts <span class="Type">|</span> disj <span class="Type">==</span> <span class="Constant">true</span> } <span class="Type">&gt;</span> <span class="Constant">0</span>;
<span id="L1863" class="LineNr">1863 </span>        };
<span id="L1864" class="LineNr">1864 </span>
<span id="L1865" class="LineNr">1865 </span>  <span class="Comment">/* Extensional rational utility */</span>
<span id="L1866" class="LineNr">1866 <a title="1.3" class="back_to_li" href="#t-1-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">ext_ruf</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b) {
<span id="L1867" class="LineNr">1867 </span>    uf <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1669">ruf</a>(w,b);
<span id="L1868" class="LineNr">1868 </span>    <span class="Comment">// Map expressions to their referents.</span>
<span id="L1869" class="LineNr">1869 </span>    expr_ref <span class="Statement">:=</span> { [expr, <a class="Identifier code-proc-link" href="#da-741">ref_expr</a>(w, b, b.n, expr)] <span class="Type">:</span> [expr, r_i] <span class="Type">in</span> uf };
<span id="L1870" class="LineNr">1870 </span>    <span class="Comment">// Map every possible world state to its utility.</span>
<span id="L1871" class="LineNr">1871 </span>    <span class="Statement">return</span> { [w_state, <a class="Identifier code-proc-link" href="#da-1875">w_util</a>(uf, expr_ref, w_state)]
<span id="L1872" class="LineNr">1872 </span>             <span class="Type">:</span> w_state <span class="Type">in</span> w.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() };
<span id="L1873" class="LineNr">1873 </span>  };
<span id="L1874" class="LineNr">1874 </span>
<span id="L1875" class="LineNr">1875 </span>    <span class="Identifier">w_util</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(uf, expr_ref, w_state) {
<span id="L1876" class="LineNr">1876 </span>      <span class="Comment">/* Truths, or utility relevant truths, I suppose. Collect the expressions </span>
<span id="L1877" class="LineNr">1877 </span><span class="Comment">         in the rational utility function that had this w_state among its set of</span>
<span id="L1878" class="LineNr">1878 </span><span class="Comment">         truthmakers / referents.  */</span>
<span id="L1879" class="LineNr">1879 </span>      truths <span class="Statement">:=</span> { expr <span class="Type">:</span> expr <span class="Type">in</span> <span class="Identifier">domain</span>(expr_ref) <span class="Type">|</span> w_state <span class="Type">in</span> expr_ref[expr] };
<span id="L1880" class="LineNr">1880 </span>      <span class="Comment">// Sum the utilities </span>
<span id="L1881" class="LineNr">1881 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { uf[expr] <span class="Type">:</span> expr <span class="Type">in</span> truths };
<span id="L1882" class="LineNr">1882 </span>    };
<span id="L1883" class="LineNr">1883 </span>
<span id="L1884" class="LineNr">1884 </span>  <span class="Comment Heading">/* Agential Identity</span>
<span id="L1885" class="LineNr">1885 </span><span class="Comment Heading">     -----------------</span>
<span id="L1886" class="LineNr">1886 </span><span class="Comment">     Agential Identity is much like Personal Identity a la Derek Parfit's </span>
<span id="L1887" class="LineNr">1887 </span><span class="Comment">     Reasons and Persons. But where personal identity roughly concerns when </span>
<span id="L1888" class="LineNr">1888 </span><span class="Comment">     someone is the same person for the purposes of care, agential identity</span>
<span id="L1889" class="LineNr">1889 </span><span class="Comment">     concerns when someone is the same agent for purposes of trusting their</span>
<span id="L1890" class="LineNr">1890 </span><span class="Comment">     normative judgments. </span>
<span id="L1891" class="LineNr">1891 </span>
<span id="L1892" class="LineNr">1892 </span><span class="Comment">     If we are thinking in terms of ideal advisor / observer theories, we might</span>
<span id="L1893" class="LineNr">1893 </span><span class="Comment">     be considering hypothetical versions of ourselves with more information </span>
<span id="L1894" class="LineNr">1894 </span><span class="Comment">     or other qualities. But consider the full knowledge of what heroin feels </span>
<span id="L1895" class="LineNr">1895 </span><span class="Comment">     like. If we had that information, we might become addicts and change our </span>
<span id="L1896" class="LineNr">1896 </span><span class="Comment">     values. But this probably isn't a change that would make us want to defer</span>
<span id="L1897" class="LineNr">1897 </span><span class="Comment">     to that self's values. We may protest that something in the process of</span>
<span id="L1898" class="LineNr">1898 </span><span class="Comment">     adding this knowledge has changed our values, not illuminated them.</span>
<span id="L1899" class="LineNr">1899 </span><span class="Comment">     </span>
<span id="L1900" class="LineNr">1900 </span><span class="Comment">     The concept of agential identity is meant to measure how much other </span>
<span id="L1901" class="LineNr">1901 </span><span class="Comment">     possible selves truly reflect *our* values and agency. Generally, this </span>
<span id="L1902" class="LineNr">1902 </span><span class="Comment">     will be measured either by similarity to our current selves or by</span>
<span id="L1903" class="LineNr">1903 </span><span class="Comment">     identifying the changes as cognitive changes made through inference or</span>
<span id="L1904" class="LineNr">1904 </span><span class="Comment">     applying higher-order decision criteria to values. </span>
<span id="L1905" class="LineNr">1905 </span><span class="Comment">  */</span>
<span id="L1906" class="LineNr">1906 <a title="1.2.3.3" class="back_to_li" href="#t-1-2-3-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">agential_identity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(dss, w, b) { <span class="Comment">// dss : list of decision states</span>
<span id="L1907" class="LineNr">1907 </span>    <span class="Statement">return</span> <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-1912">agential_continuity</a>(dss, w, b) <span class="Type">+</span>
<span id="L1908" class="LineNr">1908 </span>           <span class="Comment">// kinda like: 0.5 * agential_connection(dss[1], {}, dss[#dss])</span>
<span id="L1909" class="LineNr">1909 </span>           <span class="Constant">0.5</span> <span class="Type">*</span> (<span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-1931">p_conn</a>(dss[<span class="Constant">1</span>], <span class="Identifier">last</span>(dss)) <span class="Type">+</span>
<span id="L1910" class="LineNr">1910 </span>                  <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-2050">u_conn</a>(dss[<span class="Constant">1</span>], {}, <span class="Identifier">last</span>(<span class="Type">#</span>dss)));
<span id="L1911" class="LineNr">1911 </span>  };
<span id="L1912" class="LineNr">1912 </span>  <span class="Identifier">agential_continuity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(dss, w, b) {
<span id="L1913" class="LineNr">1913 </span>    conns <span class="Statement">:=</span> [<a class="Identifier code-proc-link" href="#da-1917">agential_connection</a>(dss[j], dss[j<span class="Type">+</span><span class="Constant">1</span>], dss[j<span class="Type">+</span><span class="Constant">2</span>], w, b, j)
<span id="L1914" class="LineNr">1914 </span>              <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>(<span class="Type">#</span>dss <span class="Type">-</span> <span class="Constant">2</span>)] ];
<span id="L1915" class="LineNr">1915 </span>    <span class="Statement">return</span> <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-10">min</a>(conns) <span class="Type">+</span> <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>(conns);
<span id="L1916" class="LineNr">1916 </span>  };
<span id="L1917" class="LineNr">1917 </span>  <span class="Identifier">agential_connection</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds1, ds2, ds3, w, b, t_i) {
<span id="L1918" class="LineNr">1918 </span>    <span class="Statement">return</span> <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>([<a class="Identifier code-proc-link" href="#da-1931">p_conn</a>(ds1, ds2), <a class="Identifier code-proc-link" href="#da-1931">p_conn</a>(ds2, ds3)]) <span class="Type">+</span>
<span id="L1919" class="LineNr">1919 </span>           <span class="Constant">0.5</span> <span class="Type">*</span> <a class="Identifier code-proc-link" href="#da-2050">u_conn</a>(ds1, ds2, ds3, w, b, t_i);
<span id="L1920" class="LineNr">1920 </span>  };
<span id="L1921" class="LineNr">1921 </span>  <span class="Comment">/* Agential continuity restricted to p_conn.</span>
<span id="L1922" class="LineNr">1922 </span><span class="Comment">     Used for measuring diachronic rationality in incoherence. */</span>
<span id="L1923" class="LineNr">1923 <a title="1.2.1.4.3" class="back_to_li" href="#t-1-2-1-4-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">p_conn_continuity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(dss) {
<span id="L1924" class="LineNr">1924 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>({ <a class="Identifier code-proc-link" href="#da-1931">p_conn</a>(dss[j], dss[j<span class="Type">+</span><span class="Constant">1</span>]) <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>(<span class="Type">#</span>dss <span class="Type">-</span> <span class="Constant">1</span>)] });
<span id="L1925" class="LineNr">1925 </span>  };
<span id="L1926" class="LineNr">1926 </span>  <span class="Comment">/* Measures connectedness of credences between two decision states. They</span>
<span id="L1927" class="LineNr">1927 </span><span class="Comment">     are connected by either having similar probability values or by reflecting</span>
<span id="L1928" class="LineNr">1928 </span><span class="Comment">     cognitive changes, i.e. updating using conditional probabilities and</span>
<span id="L1929" class="LineNr">1929 </span><span class="Comment">     resulting in probability values that are close to (locally) ideally </span>
<span id="L1930" class="LineNr">1930 </span><span class="Comment">     rational inferences. */</span>
<span id="L1931" class="LineNr">1931 </span>  <span class="Identifier">p_conn</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds1, ds2) {
<span id="L1932" class="LineNr">1932 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>({
<span id="L1933" class="LineNr">1933 </span>      <span class="Comment">// Gain full credit of the higher of similarity or cognitive score and</span>
<span id="L1934" class="LineNr">1934 </span>      <span class="Identifier">max</span>( <a class="Identifier code-proc-link" href="#da-1944">sim_cog_scores</a>(ds1, ds2, p_i) ) <span class="Type">+</span>
<span id="L1935" class="LineNr">1935 </span>        <span class="Comment">// Close the remaining distance proportional to</span>
<span id="L1936" class="LineNr">1936 </span>        (<span class="Constant">1</span> <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-15">max</a>( <a class="Identifier code-proc-link" href="#da-1944">sim_cog_scores</a>(ds1, ds2, p_i) )) <span class="Type">*</span>
<span id="L1937" class="LineNr">1937 </span>        <span class="Comment">// the other of the similarity or cognitive score</span>
<span id="L1938" class="LineNr">1938 </span>        <span class="Identifier">min</span>( <a class="Identifier code-proc-link" href="#da-1944">sim_cog_scores</a>(ds1, ds2, p_i) )
<span id="L1939" class="LineNr">1939 </span>      <span class="Comment">// For every p var</span>
<span id="L1940" class="LineNr">1940 </span>      <span class="Type">:</span> p_i <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-178">p_vars</a>()
<span id="L1941" class="LineNr">1941 </span>    });
<span id="L1942" class="LineNr">1942 </span>  };
<span id="L1943" class="LineNr">1943 </span>
<span id="L1944" class="LineNr">1944 </span>    <span class="Identifier">sim_cog_scores</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds1, ds2, p_i) {
<span id="L1945" class="LineNr">1945 </span>      <span class="Statement">return</span> [<a class="Identifier code-proc-link" href="#da-1949">p_i_sim</a>(ds1, ds2, p_i), <a class="Identifier code-proc-link" href="#da-1955">cog_change</a>(ds1, ds2, p_i)];
<span id="L1946" class="LineNr">1946 </span>    };
<span id="L1947" class="LineNr">1947 </span>
<span id="L1948" class="LineNr">1948 </span>    <span class="Comment">// Similarity / closeness. Returns 0-1.</span>
<span id="L1949" class="LineNr"><a href="#tda-1134" data-file="test_decision_algorithm" title="test_p_i_sim" class="checkmark">&#10004;</a>1949 </span>    <span class="Identifier">p_i_sim</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds1, ds2, p_i) {
<span id="L1950" class="LineNr">1950 </span>      max_dist <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-15">max</a>({ <span class="Identifier">abs</span>(ds1[p_i] <span class="Type">-</span> r_i) <span class="Type">:</span> r_i <span class="Type">in</span> r[p_i] });
<span id="L1951" class="LineNr">1951 </span>      <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">-</span> <span class="Identifier">abs</span>(ds1[p_i] <span class="Type">-</span> ds2[<a class="Identifier code-proc-link" href="#da-2005">id_var</a>(p_i)]) <span class="Type">/</span> max_dist;
<span id="L1952" class="LineNr">1952 </span>    };
<span id="L1953" class="LineNr">1953 </span>
<span id="L1954" class="LineNr">1954 </span>    <span class="Comment">// Cognitive change. Returns 0-1.</span>
<span id="L1955" class="LineNr">1955 <a title="1.2.3.3.2" class="back_to_li" href="#t-1-2-3-3-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">cog_change</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds1, ds2, p_i) {
<span id="L1956" class="LineNr">1956 </span>      <span class="Statement">if</span> (p_i <span class="Type">in</span> <span class="Identifier">range</span>(p)) { <span class="Comment">// rather than range(cp)</span>
<span id="L1957" class="LineNr">1957 </span>        <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L1958" class="LineNr">1958 </span>      } <span class="Statement">else</span> {
<span id="L1959" class="LineNr">1959 </span>        arr <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(p_i);
<span id="L1960" class="LineNr">1960 </span>        hyp <span class="Statement">:=</span> arr[<span class="Constant">1</span>];
<span id="L1961" class="LineNr">1961 </span>        evd <span class="Statement">:=</span> arr[<span class="Constant">2</span>];
<span id="L1962" class="LineNr">1962 </span>        ancs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-225">non_shared_ancestors</a>(p_i, m);
<span id="L1963" class="LineNr">1963 </span>        <span class="Statement">if</span> (p[hyp] <span class="Type">in</span> ancs <span class="Type">&amp;&amp;</span> p[evd] <span class="Type">in</span> ancs <span class="Type">&amp;&amp;</span> cp[[evd, hyp]] <span class="Type">in</span> ancs) {
<span id="L1964" class="LineNr">1964 </span>          <span class="Comment">/* For simplicity we just use the p vals in the immediate parent </span>
<span id="L1965" class="LineNr">1965 </span><span class="Comment">             (ds1). Really we should construct and use </span>
<span id="L1966" class="LineNr">1966 </span><span class="Comment">             non_shared_ancestors_with_depth and pull the p values from the </span>
<span id="L1967" class="LineNr">1967 </span><span class="Comment">             correct time slice. Similarly for id_expr. */</span>
<span id="L1968" class="LineNr">1968 </span>
<span id="L1969" class="LineNr">1969 </span>          <span class="Comment">// Rational P(H|E) = P(E|H) * P(H) / P(E)</span>
<span id="L1970" class="LineNr">1970 </span>          rat_h_e <span class="Statement">:=</span> ds1[cp[[evd, hyp]]] <span class="Type">*</span> ds1[p[hyp]] <span class="Type">/</span> ds1[p[evd]];
<span id="L1971" class="LineNr">1971 </span>          <span class="Comment">// Distance from rational</span>
<span id="L1972" class="LineNr">1972 </span>          dist_rat <span class="Statement">:=</span> <span class="Identifier">abs</span>(rat_h_e <span class="Type">-</span> ds2[ cp[ [<a class="Identifier code-proc-link" href="#da-1989">id_expr</a>(hyp), <a class="Identifier code-proc-link" href="#da-1989">id_expr</a>(evd)] ] ]);
<span id="L1973" class="LineNr">1973 </span>          <span class="Comment">// Maximum distance possible</span>
<span id="L1974" class="LineNr">1974 </span>          max_dist <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-15">max</a>({ <span class="Identifier">abs</span>(rat_h_e <span class="Type">-</span> r_i) <span class="Type">:</span> r_i <span class="Type">in</span> r[p_i] });
<span id="L1975" class="LineNr">1975 </span>          <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">-</span> dist_rat <span class="Type">/</span> max_dist;
<span id="L1976" class="LineNr">1976 </span>        } <span class="Statement">else</span> {
<span id="L1977" class="LineNr">1977 </span>          <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L1978" class="LineNr">1978 </span>        }
<span id="L1979" class="LineNr">1979 </span>      } <span class="Comment">// end else </span>
<span id="L1980" class="LineNr">1980 </span>    }; <span class="Comment">// end cog_change</span>
<span id="L1981" class="LineNr">1981 </span>
<span id="L1982" class="LineNr">1982 </span>  <span class="Comment">/* Takes an expression e and returns the expression at the next time step</span>
<span id="L1983" class="LineNr">1983 </span><span class="Comment">     that would be identical. In many cases, this is just the same expression e,</span>
<span id="L1984" class="LineNr">1984 </span><span class="Comment">     but we define input variables as indexicals so the same expression next</span>
<span id="L1985" class="LineNr">1985 </span><span class="Comment">     time step does not refer to the expression in this time step. So, we</span>
<span id="L1986" class="LineNr">1986 </span><span class="Comment">     introduce a new term At(expr, -1) which at that time step, would refer to </span>
<span id="L1987" class="LineNr">1987 </span><span class="Comment">     the same as this time's expr.  </span>
<span id="L1988" class="LineNr">1988 </span><span class="Comment">  */</span>
<span id="L1989" class="LineNr"><a href="#tda-1146" data-file="test_decision_algorithm" title="test_id_expr" class="checkmark">&#10004;</a>1989 </span>  <span class="Identifier">id_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L1990" class="LineNr">1990 </span>    <span class="Statement">if</span> (<span class="Identifier">isList</span>(expr)) { <span class="Comment">// in case it's called on p_inv of cp var</span>
<span id="L1991" class="LineNr">1991 </span>      <span class="Statement">return</span> [ <a class="Identifier code-proc-link" href="#da-1989">id_expr</a>(expr_i) <span class="Type">:</span> expr_i <span class="Type">in</span> expr ];
<span id="L1992" class="LineNr">1992 </span>    } <span class="Statement">else</span> {
<span id="L1993" class="LineNr">1993 </span>      <span class="Statement">if</span> (p[expr] <span class="Type">in</span> i) { <span class="Comment">// current input</span>
<span id="L1994" class="LineNr">1994 </span>        <span class="Statement">return</span> <span class="Identifier">At_t</span>(expr, <span class="Type">-</span><span class="Constant">1</span>);
<span id="L1995" class="LineNr">1995 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"At_t"</span>) { <span class="Comment">// past, add 1 more step</span>
<span id="L1996" class="LineNr">1996 </span>        <span class="Statement">return</span> <span class="Identifier">At_t</span>(<span class="Identifier">args</span>(expr)[<span class="Constant">1</span>], <span class="Identifier">args</span>(expr)[<span class="Constant">2</span>] <span class="Type">-</span> <span class="Constant">1</span>);
<span id="L1997" class="LineNr">1997 </span>      } <span class="Statement">else</span> {
<span id="L1998" class="LineNr">1998 </span>        <span class="Statement">return</span> expr;
<span id="L1999" class="LineNr">1999 </span>      }
<span id="L2000" class="LineNr">2000 </span>    }
<span id="L2001" class="LineNr">2001 </span>  };
<span id="L2002" class="LineNr">2002 </span>
<span id="L2003" class="LineNr">2003 </span>  <span class="Comment">/* Takes a prob variable and finds its expr preimage, then finds the expr that</span>
<span id="L2004" class="LineNr">2004 </span><span class="Comment">     in the next time would be identical to this expr. Returns that expr var. */</span>
<span id="L2005" class="LineNr"><a href="#tda-1164" data-file="test_decision_algorithm" title="test_id_var" class="checkmark">&#10004;</a>2005 </span>  <span class="Identifier">id_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_var) {
<span id="L2006" class="LineNr">2006 </span>    <span class="Statement">return</span> p[<a class="Identifier code-proc-link" href="#da-1989">id_expr</a>(<a class="Identifier code-proc-link" href="#da-1137">p_inv</a>(p_var))];
<span id="L2007" class="LineNr">2007 </span>  };
<span id="L2008" class="LineNr">2008 </span>
<span id="L2009" class="LineNr"><a href="#tda-1166" data-file="test_decision_algorithm" title="test_poss_i_events" class="checkmark">&#10004;</a>2009 </span>  <span class="Identifier">poss_i_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2010" class="LineNr">2010 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(isub, r) <span class="Type">:</span> isub <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-6">ne_pow</a>(i) };
<span id="L2011" class="LineNr">2011 </span>  };
<span id="L2012" class="LineNr">2012 </span>
<span id="L2013" class="LineNr"><a href="#tda-1182" data-file="test_decision_algorithm" title="test_e_vars" class="checkmark">&#10004;</a>2013 </span>  <span class="Identifier">e_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2014" class="LineNr">2014 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Identifier">range</span>(n_i[<span class="Constant">'e'</span>]) <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L2015" class="LineNr">2015 </span>  };
<span id="L2016" class="LineNr">2016 </span>
<span id="L2017" class="LineNr"><a href="#tda-1192" data-file="test_decision_algorithm" title="test_poss_ue_events" class="checkmark">&#10004;</a>2017 </span>  <span class="Identifier">poss_ue_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2018" class="LineNr">2018 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(ue_sub, r)
<span id="L2019" class="LineNr">2019 </span>                <span class="Type">:</span> ue_sub <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-6">ne_pow</a>(<span class="Identifier">range</span>(u) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#da-2013">e_vars</a>()) };
<span id="L2020" class="LineNr">2020 </span>  };
<span id="L2021" class="LineNr">2021 </span>
<span id="L2022" class="LineNr"><a href="#tda-1205" data-file="test_decision_algorithm" title="test_poss_p_i_events" class="checkmark">&#10004;</a>2022 </span>  <span class="Identifier">poss_p_i_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2023" class="LineNr">2023 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { { [p_i, r_i] <span class="Type">:</span> r_i <span class="Type">in</span> r[p_i] } <span class="Type">:</span> p_i <span class="Type">in</span> <span class="Identifier">range</span>(p) };
<span id="L2024" class="LineNr">2024 </span>  };
<span id="L2025" class="LineNr">2025 </span>
<span id="L2026" class="LineNr">2026 </span>  <span class="Identifier">poss_p_var_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2027" class="LineNr">2027 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { { [p_i, r_i] <span class="Type">:</span> r_i <span class="Type">in</span> r[p_i] } <span class="Type">:</span> p_i <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-178">p_vars</a>() };
<span id="L2028" class="LineNr">2028 </span>  };
<span id="L2029" class="LineNr">2029 </span>
<span id="L2030" class="LineNr">2030 </span>  <span class="Comment">// Possible states of all prescription vars</span>
<span id="L2031" class="LineNr"><a href="#tda-1215" data-file="test_decision_algorithm" title="test_poss_rx_states" class="checkmark">&#10004;</a>2031 </span>  <span class="Identifier">poss_rx_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2032" class="LineNr">2032 </span>    n_o_vars <span class="Statement">:=</span> <span class="Type">+/</span> { n_i[<span class="Constant">'o'</span>] <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L2033" class="LineNr">2033 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(n_o_vars, r);
<span id="L2034" class="LineNr">2034 </span>  };
<span id="L2035" class="LineNr">2035 </span>
<span id="L2036" class="LineNr">2036 </span>  <span class="Comment">// Possible single prescriptions for some higher-order utility</span>
<span id="L2037" class="LineNr"><a href="#tda-1229" data-file="test_decision_algorithm" title="test_poss_rxs" class="checkmark">&#10004;</a>2037 </span>  <span class="Identifier">poss_rxs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2038" class="LineNr">2038 </span>    n_os <span class="Statement">:=</span> { n_i[<span class="Constant">'o'</span>] <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L2039" class="LineNr">2039 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(n_o, r) <span class="Type">:</span> n_o <span class="Type">in</span> n_os };
<span id="L2040" class="LineNr">2040 </span>  };
<span id="L2041" class="LineNr">2041 </span>
<span id="L2042" class="LineNr">2042 </span>  <span class="Comment Heading">/* Utility Function Connectedness</span>
<span id="L2043" class="LineNr">2043 </span><span class="Comment Heading">     ------------------------------</span>
<span id="L2044" class="LineNr">2044 </span><span class="Comment">     Measures how much the utility function has either remained similar or </span>
<span id="L2045" class="LineNr">2045 </span><span class="Comment">     changed as the result of a cognitive process involving i) recognition that </span>
<span id="L2046" class="LineNr">2046 </span><span class="Comment">     some prescription (rx) would cause a utility change, ii) that recognition</span>
<span id="L2047" class="LineNr">2047 </span><span class="Comment">     in fact causes the prescription and iii) that prescription causes the </span>
<span id="L2048" class="LineNr">2048 </span><span class="Comment">     utility change. These are to be contrasted with changes to utilities from</span>
<span id="L2049" class="LineNr">2049 </span><span class="Comment">     mere noise, associations or biases.  */</span>
<span id="L2050" class="LineNr">2050 <a title="1.2.3.3.3" class="back_to_li" href="#t-1-2-3-3-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">u_conn</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds1, ds2, ds3) {
<span id="L2051" class="LineNr">2051 </span>    actual_rxs <span class="Statement">:=</span> { rx <span class="Type">:</span> rx <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-2037">poss_rxs</a>()
<span id="L2052" class="LineNr">2052 </span>                       <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-2062">rx_to_tuple</a>(w, b, t_i, ds1, ds2, ds3, rx) <span class="Type">!=</span> {} };
<span id="L2053" class="LineNr">2053 </span>    rx_subsets <span class="Statement">:=</span> <span class="Identifier">pow</span>(actual_rxs);
<span id="L2054" class="LineNr">2054 </span>
<span id="L2055" class="LineNr">2055 </span>    dists <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#da-2102">dist_to</a>(w, b, t_i, ds1, ds2, ds3, rx_subset)
<span id="L2056" class="LineNr">2056 </span>               <span class="Type">:</span> rx_subset <span class="Type">in</span> rx_subsets };
<span id="L2057" class="LineNr">2057 </span>    <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-10">min</a>(dists);
<span id="L2058" class="LineNr">2058 </span>  }; <span class="Comment">// end u_conn</span>
<span id="L2059" class="LineNr">2059 </span>
<span id="L2060" class="LineNr">2060 </span>    <span class="Comment">/* Takes a prescription and returns the tuples if any which realize i, ii</span>
<span id="L2061" class="LineNr">2061 </span><span class="Comment">       and iii above.  */</span>
<span id="L2062" class="LineNr">2062 </span>    <span class="Identifier">rx_to_tuple</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds1, ds2, ds3, rx) {
<span id="L2063" class="LineNr">2063 </span>      poss_tuples <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2026">poss_p_var_events</a>() <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#da-2009">poss_i_events</a>()  <span class="Type">&gt;&lt;</span>
<span id="L2064" class="LineNr">2064 </span>                               <span class="Identifier">p_range</span>() <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#da-2017">poss_ue_events</a>();
<span id="L2065" class="LineNr">2065 </span>      <span class="Statement">return</span> { tuple <span class="Type">:</span> tuple <span class="Type">in</span> poss_tuples
<span id="L2066" class="LineNr">2066 </span>                     <span class="Type">|</span> <a class="Identifier code-proc-link" href="#da-2069">observed</a>(w, b, t_i, rx, ds1, ds2, ds3, tuple) };
<span id="L2067" class="LineNr">2067 </span>    };
<span id="L2068" class="LineNr">2068 </span>
<span id="L2069" class="LineNr">2069 </span>      <span class="Identifier">observed</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, rx, ds1, ds2, ds3, tuple) {
<span id="L2070" class="LineNr">2070 </span>        f_p_i  <span class="Statement">:=</span> tuple[<span class="Constant">1</span>]; <span class="Comment">// Assignment of value to p_i, rx []-&gt; ue</span>
<span id="L2071" class="LineNr">2071 </span>        g_i_rx <span class="Statement">:=</span> tuple[<span class="Constant">2</span>]; <span class="Comment">/* Assignment of value to a prescription which is</span>
<span id="L2072" class="LineNr">2072 </span><span class="Comment">                               introspectively accessible as i vars */</span>
<span id="L2073" class="LineNr">2073 </span>        p_ue_val <span class="Statement">:=</span> tuple[<span class="Constant">3</span>]; <span class="Comment">// Credence placed in ue (the consequent of []-&gt;)</span>
<span id="L2074" class="LineNr">2074 </span>        h_ue   <span class="Statement">:=</span> tuple[<span class="Constant">4</span>]; <span class="Comment">// ue event</span>
<span id="L2075" class="LineNr">2075 </span>        <span class="Statement">return</span> f_p_i <span class="Type">!=</span> {} <span class="Type">&amp;&amp;</span> g_i_rx <span class="Type">!=</span> {} <span class="Type">&amp;&amp;</span> h_ue <span class="Type">!=</span> {} <span class="Type">&amp;&amp;</span>
<span id="L2076" class="LineNr">2076 </span>          <span class="Comment">// g_i_rx and rx are implemented by the same brain event and </span>
<span id="L2077" class="LineNr">2077 </span>          <span class="Comment">// the decision events occur at the right times</span>
<span id="L2078" class="LineNr">2078 </span>          <span class="Identifier">lf_inv</span>(g_i_rx) <span class="Type">==</span> <a class="Identifier code-proc-link" href="#da-401">lf_inv</a>(rx) <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>(ds2, g_i_rx) <span class="Type">&amp;&amp;</span>
<span id="L2079" class="LineNr">2079 </span>          <span class="Identifier">restricted_eq</span>(ds2, rx) <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>(ds1, f_p_i) <span class="Type">&amp;&amp;</span>
<span id="L2080" class="LineNr">2080 </span>          <span class="Identifier">restricted_eq</span>(ds3, h_ue) <span class="Type">&amp;&amp;</span>
<span id="L2081" class="LineNr">2081 </span>          <span class="Comment">// first(domain(f_p_i)) is p_i and p_i is _ []-&gt; _</span>
<span id="L2082" class="LineNr">2082 </span>          <span class="Identifier">fct</span>(<a class="Identifier code-proc-link" href="#da-1155">p_var_inv</a>(<span class="Identifier">first</span>(<span class="Identifier">domain</span>(f_p_i)))) <span class="Type">==</span> <span class="Constant">"BoxArrow"</span> <span class="Type">&amp;&amp;</span>
<span id="L2083" class="LineNr">2083 </span>          <span class="Comment">/* The ref of the brain event of ds1 implementing the placement of </span>
<span id="L2084" class="LineNr">2084 </span><span class="Comment">             prob in the p_i expr == lf_inv h_ue in two time steps</span>
<span id="L2085" class="LineNr">2085 </span><span class="Comment">             i.e. the consequent of []-&gt; refers to the intended ue change */</span>
<span id="L2086" class="LineNr">2086 </span>          <span class="Comment">/* Todo: Allow for changes that had i, ii, and iii but only partially </span>
<span id="L2087" class="LineNr">2087 </span><span class="Comment">             updated the utility / eval functions.  */</span>
<span id="L2088" class="LineNr">2088 </span>          <span class="Identifier">ref</span>(w,b)[<a class="Identifier code-proc-link" href="#da-407">lf_inv_at</a>(b, t_i)[
<span id="L2089" class="LineNr">2089 </span>            {[ p[<span class="Identifier">args</span>(<a class="Identifier code-proc-link" href="#da-1155">p_var_inv</a>(<span class="Identifier">first</span>(<span class="Identifier">domain</span>(f_p_i))))[<span class="Constant">2</span>]], p_ue_val ]}
<span id="L2090" class="LineNr">2090 </span>          ]] <span class="Type">==</span> <a class="Identifier code-proc-link" href="#da-407">lf_inv_at</a>(b, t_i <span class="Type">+</span> <span class="Constant">2</span>)[h_ue] <span class="Type">&amp;&amp;</span>
<span id="L2091" class="LineNr">2091 </span>          <span class="Comment">// p_i influences each var in rx</span>
<span id="L2092" class="LineNr">2092 </span>          <span class="Identifier">first</span>(<span class="Identifier">domain</span>(f_p_i)) <span class="Type">in</span> { <a class="Identifier code-proc-link" href="#da-197">parents</a>(v) <span class="Type">:</span> v <span class="Type">in</span> <span class="Identifier">domain</span>(rx) } <span class="Type">&amp;&amp;</span>
<span id="L2093" class="LineNr">2093 </span>          <span class="Comment">// each var in rx influences each var in the utility change </span>
<span id="L2094" class="LineNr">2094 </span>          <span class="Type">forall</span>(v <span class="Type">in</span> g_i_rx <span class="Type">|</span> v <span class="Type">in</span> { <a class="Identifier code-proc-link" href="#da-197">parents</a>(ue) <span class="Type">:</span> ue <span class="Type">in</span> <span class="Identifier">domain</span>(h_ue) });
<span id="L2095" class="LineNr">2095 </span>      };
<span id="L2096" class="LineNr">2096 </span>
<span id="L2097" class="LineNr">2097 </span>    <span class="Comment">/* Given a subset of observed prescriptions, we compare the resulting </span>
<span id="L2098" class="LineNr">2098 </span><span class="Comment">       utility function to what was prescribed within that subset. The overall </span>
<span id="L2099" class="LineNr">2099 </span><span class="Comment">       u_conn score will take the minimum distance seen this way.</span>
<span id="L2100" class="LineNr">2100 </span><span class="Comment">         Todo: Allow for changes that had i, ii, and iii but only partially </span>
<span id="L2101" class="LineNr">2101 </span><span class="Comment">       updated the utility / eval functions.  */</span>
<span id="L2102" class="LineNr">2102 </span>    <span class="Identifier">dist_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds1, ds2, ds3, rx_subset) {
<span id="L2103" class="LineNr">2103 </span>      u1 <span class="Statement">:=</span> { [u_i, ds1[u_i]] <span class="Type">:</span> u_i <span class="Type">in</span> u };
<span id="L2104" class="LineNr">2104 </span>      e1 <span class="Statement">:=</span> { u1 } <span class="Type">+</span> { { [e_i, ds1[e_i]] <span class="Type">:</span> e_i <span class="Type">in</span> n_i[<span class="Constant">'e'</span>] } <span class="Type">:</span> n_i <span class="Type">in</span> n };
<span id="L2105" class="LineNr">2105 </span>
<span id="L2106" class="LineNr">2106 </span>      rxd <span class="Statement">:=</span> { [e_i, <a class="Identifier code-proc-link" href="#da-2126">rx_e_i_val</a>(w, b, t_i, ds1, ds2, ds3, rx_subset, e_i)]
<span id="L2107" class="LineNr">2107 </span>               <span class="Type">:</span> e_i <span class="Type">in</span> <span class="Identifier">domain</span>(e1) };
<span id="L2108" class="LineNr">2108 </span>      rxd_u <span class="Statement">:=</span> { [u_i, rxd[u_i]] <span class="Type">:</span> u_i <span class="Type">in</span> u };
<span id="L2109" class="LineNr">2109 </span>      rxd_n <span class="Statement">:=</span> [ { [e_i, rxd[e_i]] <span class="Type">:</span> e_i <span class="Type">in</span> n_i[<span class="Constant">'e'</span>] } <span class="Type">:</span> n_i <span class="Type">in</span> n ];
<span id="L2110" class="LineNr">2110 </span>      rxd_e <span class="Statement">:=</span> [ rxd_u ] <span class="Type">+</span> rxd_n;
<span id="L2111" class="LineNr">2111 </span>      <span class="Comment">// The prescribed util / eval change</span>
<span id="L2112" class="LineNr">2112 </span>      ord_rxd_e <span class="Statement">:=</span> [ <a class="Identifier code-proc-link" href="#da-2168">additive_to_ordinal</a>(rxd_e[j], j, <a class="Identifier code-proc-link" href="#da-1756">ue_state_space</a>())
<span id="L2113" class="LineNr">2113 </span>                     <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>rxd_e] ];
<span id="L2114" class="LineNr">2114 </span>      <span class="Comment">// The actual change in ds3</span>
<span id="L2115" class="LineNr">2115 </span>      ord_e <span class="Statement">:=</span> [ <a class="Identifier code-proc-link" href="#da-2168">additive_to_ordinal</a>(<a class="Identifier code-proc-link" href="#da-2144">e_func</a>(ds3, j), j, <a class="Identifier code-proc-link" href="#da-1756">ue_state_space</a>())
<span id="L2116" class="LineNr">2116 </span>                 <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>rxd_e] ];
<span id="L2117" class="LineNr">2117 </span>
<span id="L2118" class="LineNr">2118 </span>      e_dists <span class="Statement">:=</span> [ <a class="Identifier code-proc-link" href="#l-674">ord_u_dist</a>(ord_e[j], ord_rxd_e[j]) <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>ord_e] ];
<span id="L2119" class="LineNr">2119 </span>
<span id="L2120" class="LineNr">2120 </span>      <span class="Comment">// Todo: Add weights? </span>
<span id="L2121" class="LineNr">2121 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-20">avg</a>(e_dists);
<span id="L2122" class="LineNr">2122 </span>    }; <span class="Comment">// end dist_to</span>
<span id="L2123" class="LineNr">2123 </span>
<span id="L2124" class="LineNr">2124 </span>      <span class="Comment">/* Given a subset of observed prescriptions and an e_i var, return the</span>
<span id="L2125" class="LineNr">2125 </span><span class="Comment">         value prescribed for the e_i var.  */</span>
<span id="L2126" class="LineNr">2126 </span>      <span class="Identifier">rx_e_i_val</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, t_i, ds1, ds2, ds3, rx_subset, e_i) {
<span id="L2127" class="LineNr">2127 </span>        <span class="Comment">/* The prescribed values (rxds) are the values of the e_i var in the </span>
<span id="L2128" class="LineNr">2128 </span><span class="Comment">           ue event from rx_to_tuple (for any rxs that prescribe for e_i). */</span>
<span id="L2129" class="LineNr">2129 </span>        rxds <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#da-2062">rx_to_tuple</a>(w, b, t_i, ds1, ds2, ds3, rx_i)[<span class="Constant">4</span>][e_i]
<span id="L2130" class="LineNr">2130 </span>          <span class="Type">:</span> rx_i <span class="Type">in</span> rx_subset  <span class="Comment">// h_ue[e_i]</span>
<span id="L2131" class="LineNr">2131 </span>          <span class="Type">|</span> e_i <span class="Type">in</span> <span class="Identifier">domain</span>(<a class="Identifier code-proc-link" href="#da-2062">rx_to_tuple</a>(w, b, t_i, ds1, ds2, ds3, rx_i)[<span class="Constant">4</span>]) };
<span id="L2132" class="LineNr">2132 </span>            <span class="Comment">// e_i in domain(h_ue)</span>
<span id="L2133" class="LineNr">2133 </span>        <span class="Statement">if</span> (<span class="Type">#</span>rxds <span class="Type">&gt;</span> <span class="Constant">0</span>) {
<span id="L2134" class="LineNr">2134 </span>          <span class="Comment">// If #rxds &gt; 1, they should all be the same anyway bc it was observed</span>
<span id="L2135" class="LineNr">2135 </span>          <span class="Statement">return</span> <span class="Identifier">first</span>(rxds);
<span id="L2136" class="LineNr">2136 </span>          <span class="Comment">/* Todo: In later versions, we probably want to allow for non-exact </span>
<span id="L2137" class="LineNr">2137 </span><span class="Comment">             changes and then choose the one closest to the observed.  */</span>
<span id="L2138" class="LineNr">2138 </span>        } <span class="Statement">else</span> {
<span id="L2139" class="LineNr">2139 </span>          <span class="Statement">return</span> e1[e_i]; <span class="Comment">// No change</span>
<span id="L2140" class="LineNr">2140 </span>        }
<span id="L2141" class="LineNr">2141 </span>      };
<span id="L2142" class="LineNr">2142 </span>
<span id="L2143" class="LineNr">2143 </span>  <span class="Comment">// Utility / Evaluation Function implemented in a given decision state ds</span>
<span id="L2144" class="LineNr"><a href="#tda-878" data-file="test_decision_algorithm" title="test_e_func" class="checkmark">&#10004;</a>2144 </span>  <span class="Identifier">e_func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds, j) {
<span id="L2145" class="LineNr">2145 </span>    <span class="Statement">if</span> (j <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L2146" class="LineNr">2146 </span>      <span class="Statement">return</span> { [u_i, ds[u_i]] <span class="Type">:</span>  u_i <span class="Type">in</span> <span class="Identifier">range</span>(u) };
<span id="L2147" class="LineNr">2147 </span>    } <span class="Statement">else</span> {
<span id="L2148" class="LineNr">2148 </span>      <span class="Statement">return</span> { [e_i, ds[e_i]] <span class="Type">:</span> e_i <span class="Type">in</span> <span class="Identifier">range</span>(n[j][<span class="Constant">'e'</span>]) };
<span id="L2149" class="LineNr">2149 </span>    }
<span id="L2150" class="LineNr">2150 </span>  };
<span id="L2151" class="LineNr">2151 </span>
<span id="L2152" class="LineNr"><a href="#tda-889" data-file="test_decision_algorithm" title="test_ue" class="checkmark">&#10004;</a>2152 </span>  <span class="Identifier">ue</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(j) {
<span id="L2153" class="LineNr">2153 </span>    <span class="Statement">if</span> (j <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L2154" class="LineNr">2154 </span>      <span class="Statement">return</span> u;
<span id="L2155" class="LineNr">2155 </span>    } <span class="Statement">else</span> {
<span id="L2156" class="LineNr">2156 </span>      <span class="Statement">return</span> n[j][<span class="Constant">'e'</span>];
<span id="L2157" class="LineNr">2157 </span>    }
<span id="L2158" class="LineNr">2158 </span>  };
<span id="L2159" class="LineNr">2159 </span>
<span id="L2160" class="LineNr"><a href="#tda-897" data-file="test_decision_algorithm" title="test_ue_base_exprs" class="checkmark">&#10004;</a>2160 </span>  <span class="Identifier">ue_base_exprs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(j) {
<span id="L2161" class="LineNr">2161 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-552">subformulas</a>(x_i) <span class="Type">:</span> x_i <span class="Type">in</span> <span class="Identifier">domain</span>(<a class="Identifier code-proc-link" href="#da-2152">ue</a>(j)) };
<span id="L2162" class="LineNr">2162 </span>  };
<span id="L2163" class="LineNr">2163 </span>
<span id="L2164" class="LineNr">2164 </span>  <span class="Comment">/* Takes a decision state, i.e. a function from (among other things) utility</span>
<span id="L2165" class="LineNr">2165 </span><span class="Comment">     variables to numbers (utilities), and an index j and returns a set of </span>
<span id="L2166" class="LineNr">2166 </span><span class="Comment">     SuccEq (succeeds or equals) setlx functors. If j is 0, then u is converted</span>
<span id="L2167" class="LineNr">2167 </span><span class="Comment">     to ordinal, otherwise, n[j]['e'] is. */</span>
<span id="L2168" class="LineNr">2168 </span>  <span class="Identifier">additive_to_ordinal</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ds, j, state_space) {
<span id="L2169" class="LineNr">2169 </span>    card_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-635">add_u_to_card_u</a>(<a class="Identifier code-proc-link" href="#da-2144">e_func</a>(ds,j), state_space);
<span id="L2170" class="LineNr">2170 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>( card_u, <span class="Identifier">domain</span>(card_u), r[<span class="Identifier">first</span>(p)] );
<span id="L2171" class="LineNr">2171 </span>  };
<span id="L2172" class="LineNr">2172 </span>
<span id="L2173" class="LineNr">2173 </span>  <span class="Comment Heading">/* Brain-State Measure Paths </span>
<span id="L2174" class="LineNr">2174 </span><span class="Comment Heading">     -------------------------</span>
<span id="L2175" class="LineNr">2175 </span><span class="Comment">     Returns a list where for each future time, there is a set of </span>
<span id="L2176" class="LineNr">2176 </span><span class="Comment">     bs_msr_paths, each of which in turn is a list of bs_msrs for each time </span>
<span id="L2177" class="LineNr">2177 </span><span class="Comment">     from the first to the given time. A bs_msr is a pair [bs, msr]. </span>
<span id="L2178" class="LineNr">2178 </span><span class="Comment">    </span>
<span id="L2179" class="LineNr">2179 </span><span class="Comment">     One can think in terms of a tree. At the root is the given starting brain </span>
<span id="L2180" class="LineNr">2180 </span><span class="Comment">     state. Each branch is a continuation with different inputs and a measure </span>
<span id="L2181" class="LineNr">2181 </span><span class="Comment">     for that branch based on subjective likelihood. A path is a full branch </span>
<span id="L2182" class="LineNr">2182 </span><span class="Comment">     line from root to leaf collecting pairs of brain states and measures along</span>
<span id="L2183" class="LineNr">2183 </span><span class="Comment">     the way. </span>
<span id="L2184" class="LineNr">2184 </span>
<span id="L2185" class="LineNr">2185 </span><span class="Comment">     e.g. [bs_msr_paths_t1, ..., bs_msr_paths_tz]</span>
<span id="L2186" class="LineNr">2186 </span><span class="Comment">       bs_msr_paths_tj := { bs_msrs_tj_1, bs_msr_tj_2, ... }</span>
<span id="L2187" class="LineNr">2187 </span><span class="Comment">         bs_msrs_tj_k := [ bs_msr_t1, ..., bs_msr_tj ]</span>
<span id="L2188" class="LineNr">2188 </span><span class="Comment">           bs_msr_tj := [bs_tj, msr]</span>
<span id="L2189" class="LineNr">2189 </span>
<span id="L2190" class="LineNr">2190 </span><span class="Comment">                     [ bs1, 1 ]</span>
<span id="L2191" class="LineNr">2191 </span><span class="Comment">                    /   |      \</span>
<span id="L2192" class="LineNr">2192 </span><span class="Comment">               is1 /    |is2    \  is3   (input states leading to continuations)</span>
<span id="L2193" class="LineNr">2193 </span><span class="Comment">                  /     |        \  </span>
<span id="L2194" class="LineNr">2194 </span><span class="Comment">                 /      |         \</span>
<span id="L2195" class="LineNr">2195 </span><span class="Comment">     [bs_t2a, 1/6]  [bs_t2b, 1/2]  [bs_t2c, 1/3]  </span>
<span id="L2196" class="LineNr">2196 </span><span class="Comment">      /    |    \     /   |   \      /   |   \</span>
<span id="L2197" class="LineNr">2197 </span><span class="Comment">     ...</span>
<span id="L2198" class="LineNr">2198 </span>
<span id="L2199" class="LineNr">2199 </span><span class="Comment">     There's some duplication and space inefficiency in having the previous </span>
<span id="L2200" class="LineNr">2200 </span><span class="Comment">     times' brain states and measures present both in the earlier elements of</span>
<span id="L2201" class="LineNr">2201 </span><span class="Comment">     the top level list as well as within the set of paths for each element.</span>
<span id="L2202" class="LineNr">2202 </span><span class="Comment">     We probably could do without it but it makes it a little more convenient</span>
<span id="L2203" class="LineNr">2203 </span><span class="Comment">     when calculating the voter weights for each time's voters in computing</span>
<span id="L2204" class="LineNr">2204 </span><span class="Comment">     the rational utility function. Some aspects of those weights like the </span>
<span id="L2205" class="LineNr">2205 </span><span class="Comment">     agential identity depend on the entire path taken and not just the final</span>
<span id="L2206" class="LineNr">2206 </span><span class="Comment">     brain state.</span>
<span id="L2207" class="LineNr">2207 </span><span class="Comment">  */</span>
<span id="L2208" class="LineNr">2208 <a title="1.2.3.1" class="back_to_li" href="#t-1-2-3-1"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">bs_msr_paths</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, bs1, t_j) {
<span id="L2209" class="LineNr">2209 </span>    <span class="Statement">if</span> (t_j <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L2210" class="LineNr">2210 </span>      <span class="Statement">return</span> [{[[bs1, <span class="Constant">1</span>]]}];
<span id="L2211" class="LineNr">2211 </span>    } <span class="Statement">else</span> {
<span id="L2212" class="LineNr">2212 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-2208">bs_msr_paths</a>(w, b, bs1, t_j <span class="Type">-</span> <span class="Constant">1</span>) <span class="Type">+</span>
<span id="L2213" class="LineNr">2213 </span>        [<span class="Type">+/</span> {
<span id="L2214" class="LineNr">2214 </span>           { bmp <span class="Type">+</span> [bs_msr]
<span id="L2215" class="LineNr">2215 </span>             <span class="Type">:</span> bs_msr <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-2224">next_bs_msrs</a>(w, b, <span class="Identifier">last</span>(bmp)[<span class="Constant">1</span>], <span class="Identifier">last</span>(bmp)[<span class="Constant">2</span>], t_j<span class="Type">-</span><span class="Constant">1</span>) }
<span id="L2216" class="LineNr">2216 </span>           <span class="Type">:</span> bmp <span class="Type">in</span> <span class="Identifier">last</span>(<a class="Identifier code-proc-link" href="#da-2208">bs_msr_paths</a>(w, b, bs1, t_j <span class="Type">-</span> <span class="Constant">1</span>))
<span id="L2217" class="LineNr">2217 </span>         }];
<span id="L2218" class="LineNr">2218 </span>    }
<span id="L2219" class="LineNr">2219 </span>  };
<span id="L2220" class="LineNr">2220 </span>
<span id="L2221" class="LineNr">2221 </span>  <span class="Comment">/* Takes a brain, brain state, measure and prev t_i and returns the possible</span>
<span id="L2222" class="LineNr">2222 </span><span class="Comment">     continuations in the next time step together with their measure </span>
<span id="L2223" class="LineNr">2223 </span><span class="Comment">     roughly proportional to the subjective likelihood.  */</span>
<span id="L2224" class="LineNr">2224 </span>  <span class="Identifier">next_bs_msrs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(w, b, bs_i, msr, t_j) {
<span id="L2225" class="LineNr">2225 </span>    bs_j <span class="Statement">:=</span> b.<a class="Identifier code-proc-link" href="#cmm-108">response</a>(bs_i);
<span id="L2226" class="LineNr">2226 </span>    <span class="Comment">// Possible brain input states from each di possible decision input states.</span>
<span id="L2227" class="LineNr">2227 </span>    pbis <span class="Statement">:=</span> { [di, <a class="Identifier code-proc-link" href="#da-401">lf_inv</a>(b)[di]] <span class="Type">:</span> di <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-1344">poss_i_states</a>() };
<span id="L2228" class="LineNr">2228 </span>    <span class="Comment">/* Possibly empty brain input states since we now filter by compatibility</span>
<span id="L2229" class="LineNr">2229 </span><span class="Comment">       with the brain response bs_j. (Recall that input vars may overlap with</span>
<span id="L2230" class="LineNr">2230 </span><span class="Comment">       other vars that bs_j may dictate values for.) */</span>
<span id="L2231" class="LineNr">2231 </span>    pe_bis <span class="Statement">:=</span> { [di, { pbi <span class="Type">:</span> pbi <span class="Type">in</span> pbi_s <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-346">compat</a>(pbi, bs_j) }]
<span id="L2232" class="LineNr">2232 </span>                <span class="Type">:</span> [di, pbi_s] <span class="Type">in</span> pbis };
<span id="L2233" class="LineNr">2233 </span>    <span class="Comment">// pbi_s = possible brain input sets</span>
<span id="L2234" class="LineNr">2234 </span>    bis <span class="Statement">:=</span> { [di, pbi_s] <span class="Type">:</span> [di, pbi_s] <span class="Type">in</span> pe_bis <span class="Type">|</span> pbi_s <span class="Type">!=</span> {} };
<span id="L2235" class="LineNr">2235 </span>
<span id="L2236" class="LineNr">2236 </span>    <span class="Comment">/* For each brain input state of each decision input state, map the total</span>
<span id="L2237" class="LineNr">2237 </span><span class="Comment">       brain state including the response bs_j to its new measure. </span>
<span id="L2238" class="LineNr">2238 </span>
<span id="L2239" class="LineNr">2239 </span><span class="Comment">       Ideally, the new measure would be proportional to the brain input </span>
<span id="L2240" class="LineNr">2240 </span><span class="Comment">       state's subjective probability. This was under development but doing it </span>
<span id="L2241" class="LineNr">2241 </span><span class="Comment">       in a way that is biologically plausible presents a challenge. To avoid </span>
<span id="L2242" class="LineNr">2242 </span><span class="Comment">       an implausible number of explicit probabilities, we'd probably have to </span>
<span id="L2243" class="LineNr">2243 </span><span class="Comment">       look at the closest coherent extensions of the current probability </span>
<span id="L2244" class="LineNr">2244 </span><span class="Comment">       distribution as well as allow for indirect reference, which introduces </span>
<span id="L2245" class="LineNr">2245 </span><span class="Comment">       its own challenges in translating probabilities from direct to indirect.</span>
<span id="L2246" class="LineNr">2246 </span><span class="Comment">       </span>
<span id="L2247" class="LineNr">2247 </span><span class="Comment">       Although I by no means think these challenges insurmountable, the </span>
<span id="L2248" class="LineNr">2248 </span><span class="Comment">       technical complications involved seemed too great for a first version</span>
<span id="L2249" class="LineNr">2249 </span><span class="Comment">       and not worth delaying the initial release over. As a placeholder here,</span>
<span id="L2250" class="LineNr">2250 </span><span class="Comment">       we simply assume each possible decision input state is equally probable</span>
<span id="L2251" class="LineNr">2251 </span><span class="Comment">       and each brain state implementing a given decision input state is</span>
<span id="L2252" class="LineNr">2252 </span><span class="Comment">       similarly equally probable to other such implementations.</span>
<span id="L2253" class="LineNr">2253 </span>
<span id="L2254" class="LineNr">2254 </span><span class="Comment">       While incorporating the subjective probability seems preferable, it's</span>
<span id="L2255" class="LineNr">2255 </span><span class="Comment">       also worth mentioning that it may not actually be necessary. The main</span>
<span id="L2256" class="LineNr">2256 </span><span class="Comment">       motivation is to make continuations of the agent under very weird </span>
<span id="L2257" class="LineNr">2257 </span><span class="Comment">       scenarios matter less. But if the worry there is that those </span>
<span id="L2258" class="LineNr">2258 </span><span class="Comment">       circumstances are distorting the agent's values, we already have the </span>
<span id="L2259" class="LineNr">2259 </span><span class="Comment">       agential_identity measure to discount them. In other words, agential</span>
<span id="L2260" class="LineNr">2260 </span><span class="Comment">       identity may screen off a circumstance's weirdness from its relevance.</span>
<span id="L2261" class="LineNr">2261 </span><span class="Comment">    */</span>
<span id="L2262" class="LineNr">2262 </span>    <span class="Statement">return</span> <span class="Type">+/</span> {
<span id="L2263" class="LineNr">2263 </span>      { [ bi <span class="Type">+</span> bs_j, msr <span class="Type">*</span> (<span class="Constant">1</span> <span class="Type">/</span> <span class="Type">#</span><span class="Identifier">domain</span>(bis)) <span class="Type">*</span> (<span class="Constant">1</span> <span class="Type">/</span> <span class="Type">#</span>bis[di]) ]
<span id="L2264" class="LineNr">2264 </span>        <span class="Type">:</span> bi <span class="Type">in</span> bis[di] }
<span id="L2265" class="LineNr">2265 </span>      <span class="Type">:</span> di <span class="Type">in</span> <span class="Identifier">domain</span>(bis)
<span id="L2266" class="LineNr">2266 </span>    };
<span id="L2267" class="LineNr">2267 </span>  };
<span id="L2268" class="LineNr">2268 </span>
<span id="L2269" class="LineNr">2269 </span>
<span id="L2270" class="LineNr">2270 </span><span class="Comment Heading">// Class Methods</span>
<span id="L2271" class="LineNr">2271 </span><span class="Comment Heading">// =============</span>
<span id="L2272" class="LineNr">2272 </span>
<span id="L2273" class="LineNr">2273 </span>  <span class="Statement">static</span> {
<span id="L2274" class="LineNr">2274 </span>    <span class="Comment">/* Function from a causal_model of a brain b and a set of decision </span>
<span id="L2275" class="LineNr">2275 </span><span class="Comment">       algorithm candidates to the decision algorithm that is the best </span>
<span id="L2276" class="LineNr">2276 </span><span class="Comment">       compression of the brain.  */</span>
<span id="L2277" class="LineNr">2277 </span>    <span class="Identifier">implemented_by</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b, ds) {
<span id="L2278" class="LineNr">2278 </span>      <span class="Statement">if</span> (ds <span class="Type">==</span> {}) {
<span id="L2279" class="LineNr">2279 </span>        ds <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2293">all</a>(b);
<span id="L2280" class="LineNr">2280 </span>      }
<span id="L2281" class="LineNr">2281 </span>      <span class="Comment">/* Requiring simplest version helps ensure higher-order ambitiousness,</span>
<span id="L2282" class="LineNr">2282 </span><span class="Comment">         i.e. prevents smuggling in higher-order norms within the n[j]['m2'] </span>
<span id="L2283" class="LineNr">2283 </span><span class="Comment">         variables. In future iterations, this might be softened.  */</span>
<span id="L2284" class="LineNr">2284 </span>      ds <span class="Statement">:=</span> [d <span class="Type">:</span> d <span class="Type">in</span> ds <span class="Type">|</span> d.<a class="Identifier code-proc-link" href="#da-293">is_implemented_by</a>(b) <span class="Type">&amp;&amp;</span> d.<a class="Identifier code-proc-link" href="#da-1539">is_simplest_version</a>(b)];
<span id="L2285" class="LineNr">2285 </span>      ds <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(ds, decision_algorithm.<a class="Identifier code-proc-link" href="#da-2415">better_explanation</a>(b));
<span id="L2286" class="LineNr">2286 </span>      <span class="Statement">return</span> ds[<span class="Constant">1</span>];
<span id="L2287" class="LineNr">2287 </span>    };
<span id="L2288" class="LineNr">2288 </span>
<span id="L2289" class="LineNr">2289 </span>    <span class="Comment">/* Given a causal model of a brain, return the set of possible decision </span>
<span id="L2290" class="LineNr">2290 </span><span class="Comment">       algorithms which could be implemented by it based simply on number of </span>
<span id="L2291" class="LineNr">2291 </span><span class="Comment">       states. A decision algorithm can't be more fine-grained than its </span>
<span id="L2292" class="LineNr">2292 </span><span class="Comment">       substrate.  */</span>
<span id="L2293" class="LineNr">2293 </span>    <span class="Identifier">all</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b) {
<span id="L2294" class="LineNr">2294 </span>      <span class="Statement">return</span> { d <span class="Type">:</span> d <span class="Type">in</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2299">all_lte</a>(<span class="Type">#</span>b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>()) };
<span id="L2295" class="LineNr">2295 </span>    };
<span id="L2296" class="LineNr">2296 </span>
<span id="L2297" class="LineNr">2297 </span>    <span class="Comment">// All with #poss_states &lt;= z</span>
<span id="L2298" class="LineNr">2298 </span>    <span class="Comment">// Todo: Add possible At_t exprs and predicates and quantifiers</span>
<span id="L2299" class="LineNr">2299 </span>    <span class="Identifier">all_lte</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(z) {
<span id="L2300" class="LineNr">2300 </span>      poss_i <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'I'</span>, z<span class="Type">/</span><span class="Constant">2</span>);
<span id="L2301" class="LineNr">2301 </span>      var_ltrs <span class="Statement">:=</span> { <span class="Constant">'A'</span>, <span class="Constant">'B'</span>, <span class="Constant">'C'</span> };
<span id="L2302" class="LineNr">2302 </span>      poss_base_vars <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2329">vars_up_to</a>(var_ltrs, n);
<span id="L2303" class="LineNr">2303 </span>      poss_exprs <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2342">add_up_to</a>(pbe, z<span class="Type">/</span><span class="Constant">2</span>)
<span id="L2304" class="LineNr">2304 </span>                      <span class="Type">:</span> pbe <span class="Type">in</span> poss_base_vars };
<span id="L2305" class="LineNr">2305 </span>      poss_p <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2354">poss_expr_to_ltr</a>(poss_exprs, <span class="Constant">'P'</span>);
<span id="L2306" class="LineNr">2306 </span>      <span class="Comment">// e.g. { [[x, y], 'P(x|y)'], ... } </span>
<span id="L2307" class="LineNr">2307 </span>      poss_cp <span class="Statement">:=</span> <span class="Identifier">pow</span>({ [[x, y], <span class="Constant">'P('</span> <span class="Type">+</span> <span class="Identifier">str</span>(x) <span class="Type">+</span> <span class="Constant">'|'</span> <span class="Type">+</span> <span class="Identifier">str</span>(y) <span class="Type">+</span> <span class="Constant">')'</span>]
<span id="L2308" class="LineNr">2308 </span>                       <span class="Type">:</span> [x, y] <span class="Type">in</span> poss_exprs <span class="Type">&gt;&lt;</span> poss_exprs });
<span id="L2309" class="LineNr">2309 </span>      poss_o <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'O'</span>, z<span class="Type">/</span><span class="Constant">2</span>);
<span id="L2310" class="LineNr">2310 </span>      poss_u <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2354">poss_expr_to_ltr</a>(poss_exprs, <span class="Constant">'U'</span>);
<span id="L2311" class="LineNr">2311 </span>      poss_m <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'M'</span>, z<span class="Type">/</span><span class="Constant">2</span>);
<span id="L2312" class="LineNr">2312 </span>      poss_m2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'M2'</span>, z<span class="Type">/</span><span class="Constant">2</span>);
<span id="L2313" class="LineNr">2313 </span>      poss_n <span class="Statement">:=</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-297">choices</a>({ <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2359">poss_nj</a>(poss_exprs, z, j) <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>x] })
<span id="L2314" class="LineNr">2314 </span>                     <span class="Type">:</span> x <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>z] };
<span id="L2315" class="LineNr">2315 </span>      <span class="Statement">return</span> <span class="Type">+/</span> {
<span id="L2316" class="LineNr">2316 </span>        <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2396">poss_ds</a>(d_i, d_o, d_p, d_cp, d_u, d_m, d_m2, d_n, poss_r)
<span id="L2317" class="LineNr">2317 </span>             <span class="Type">:</span> poss_r <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2367">poss_rs</a>(z, d_i, d_o, d_p, d_cp,
<span id="L2318" class="LineNr">2318 </span>                                         d_u, d_m, d_m2, d_n) }
<span id="L2319" class="LineNr">2319 </span>        <span class="Type">:</span> [d_i, d_o, d_p, d_cp, d_u, d_m, d_m2, d_n] <span class="Type">in</span>
<span id="L2320" class="LineNr">2320 </span>          <span class="Identifier">da</span>().<a class="Identifier code-proc-link" href="#l-269">cart_prod</a>(poss_i, poss_o, poss_p, poss_cp,
<span id="L2321" class="LineNr">2321 </span>                         poss_u, poss_m, poss_m2, poss_n)
<span id="L2322" class="LineNr">2322 </span>      };
<span id="L2323" class="LineNr">2323 </span>    }; <span class="Comment">// end all_lte</span>
<span id="L2324" class="LineNr">2324 </span>
<span id="L2325" class="LineNr"><a href="#tda-1272" data-file="test_decision_algorithm" title="test_ltr_up_to" class="checkmark">&#10004;</a>2325 </span>      <span class="Identifier">ltr_up_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ltr, j) {
<span id="L2326" class="LineNr">2326 </span>        <span class="Statement">return</span> { ltr <span class="Type">+</span> <span class="Constant">'_'</span> <span class="Type">+</span> y <span class="Type">:</span> y <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>j] };
<span id="L2327" class="LineNr">2327 </span>      };
<span id="L2328" class="LineNr">2328 </span>
<span id="L2329" class="LineNr"><a href="#tda-1279" data-file="test_decision_algorithm" title="test_vars_up_to" class="checkmark">&#10004;</a>2329 </span>      <span class="Identifier">vars_up_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ltrs, j) {
<span id="L2330" class="LineNr">2330 </span>        <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(ltr, j) <span class="Type">:</span> ltr <span class="Type">in</span> ltrs };
<span id="L2331" class="LineNr">2331 </span>      };
<span id="L2332" class="LineNr">2332 </span>
<span id="L2333" class="LineNr">2333 </span>      <span class="Identifier">add_one</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(exprs) {
<span id="L2334" class="LineNr">2334 </span>        unary <span class="Statement">:=</span> { <span class="Constant">'Not'</span> };
<span id="L2335" class="LineNr">2335 </span>        binary <span class="Statement">:=</span> { <span class="Constant">'And'</span>, <span class="Constant">'Or'</span>, <span class="Constant">'Implies'</span>, <span class="Constant">'BoxArrow'</span> };
<span id="L2336" class="LineNr">2336 </span>        add_un <span class="Statement">:=</span> { <span class="Identifier">makeTerm</span>(op, [expr]) <span class="Type">:</span> [op, expr] <span class="Type">in</span> unary <span class="Type">&gt;&lt;</span> exprs };
<span id="L2337" class="LineNr">2337 </span>        add_bi <span class="Statement">:=</span> { <span class="Identifier">makeTerm</span>(op, [expr1, expr2])
<span id="L2338" class="LineNr">2338 </span>                    <span class="Type">:</span> [op, [expr1, expr2]] <span class="Type">in</span> binary <span class="Type">&gt;&lt;</span> (exprs <span class="Type">&gt;&lt;</span> exprs) };
<span id="L2339" class="LineNr">2339 </span>        <span class="Statement">return</span> exprs <span class="Type">+</span> add_un <span class="Type">+</span> add_bi;
<span id="L2340" class="LineNr">2340 </span>      };
<span id="L2341" class="LineNr">2341 </span>
<span id="L2342" class="LineNr">2342 </span>      <span class="Identifier">add_up_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(base_vars, j) {
<span id="L2343" class="LineNr">2343 </span>        <span class="Statement">if</span> (j <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L2344" class="LineNr">2344 </span>          <span class="Statement">return</span> base_vars;
<span id="L2345" class="LineNr">2345 </span>        } <span class="Statement">else</span> {
<span id="L2346" class="LineNr">2346 </span>          <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2333">add_one</a>( <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2342">add_up_to</a>(base_vars, j <span class="Type">-</span> <span class="Constant">1</span>) );
<span id="L2347" class="LineNr">2347 </span>        }
<span id="L2348" class="LineNr">2348 </span>      };
<span id="L2349" class="LineNr">2349 </span>
<span id="L2350" class="LineNr"><a href="#tda-1287" data-file="test_decision_algorithm" title="test_expr_to_ltr_var" class="checkmark">&#10004;</a>2350 </span>      <span class="Identifier">expr_to_ltr_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr, ltr) {
<span id="L2351" class="LineNr">2351 </span>        <span class="Statement">return</span> ltr <span class="Type">+</span> <span class="Constant">'('</span> <span class="Type">+</span> <span class="Identifier">replace</span>(<span class="Identifier">str</span>(expr), <span class="Constant">'"'</span>, <span class="Constant">''</span>) <span class="Type">+</span> <span class="Constant">')'</span>;
<span id="L2352" class="LineNr">2352 </span>      };
<span id="L2353" class="LineNr">2353 </span>
<span id="L2354" class="LineNr">2354 </span>      <span class="Identifier">poss_expr_to_ltr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(poss_exprs, ltr) {
<span id="L2355" class="LineNr">2355 </span>        <span class="Statement">return</span> { { [expr, <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2350">expr_to_ltr_var</a>(expr, ltr)] <span class="Type">:</span> expr <span class="Type">in</span> subset }
<span id="L2356" class="LineNr">2356 </span>                 <span class="Type">:</span> subset <span class="Type">in</span> <span class="Identifier">pow</span>(poss_exprs) };
<span id="L2357" class="LineNr">2357 </span>      };
<span id="L2358" class="LineNr">2358 </span>
<span id="L2359" class="LineNr">2359 </span>      <span class="Identifier">poss_nj</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(poss_exprs, z, j) {
<span id="L2360" class="LineNr">2360 </span>        poss_e_nj <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2354">poss_expr_to_ltr</a>(poss_exprs, <span class="Constant">'E_n'</span> <span class="Type">+</span> j);
<span id="L2361" class="LineNr">2361 </span>        poss_m2_nj <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'M2_n'</span> <span class="Type">+</span> j, z<span class="Type">/</span><span class="Constant">2</span>);
<span id="L2362" class="LineNr">2362 </span>        poss_o_nj <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'O_n'</span> <span class="Type">+</span> j, z<span class="Type">/</span><span class="Constant">2</span>);
<span id="L2363" class="LineNr">2363 </span>        <span class="Statement">return</span> { { [<span class="Constant">'e'</span>, e_n], [<span class="Constant">'m'</span>, m_n], [<span class="Constant">'o'</span>, o_n] }
<span id="L2364" class="LineNr">2364 </span>          <span class="Type">:</span> [e_n, m_n, o_n] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-269">cart_prod</a>([poss_e_nj, poss_m2_nj, poss_o_nj]) };
<span id="L2365" class="LineNr">2365 </span>      };
<span id="L2366" class="LineNr">2366 </span>
<span id="L2367" class="LineNr">2367 </span>      <span class="Identifier">poss_rs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(z, d_i, d_o, d_p, d_cp, d_u, d_m, d_m2, d_n) {
<span id="L2368" class="LineNr">2368 </span>        poss_p_vals <span class="Statement">:=</span> { { j <span class="Type">/</span> x <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">0</span><span class="Statement">..</span>x] } <span class="Type">:</span> x <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>z] };
<span id="L2369" class="LineNr">2369 </span>        poss_ue_vals <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-6">ne_pow</a>({ j <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Constant">2</span><span class="Type">**</span>z] });
<span id="L2370" class="LineNr">2370 </span>        poss_z_vals <span class="Statement">:=</span> { { j <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>x] } <span class="Type">:</span> x <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>z] };
<span id="L2371" class="LineNr">2371 </span>        poss_o_vals <span class="Statement">:=</span> poss_z_vals;
<span id="L2372" class="LineNr">2372 </span>
<span id="L2373" class="LineNr">2373 </span>        poss_r_ps <span class="Statement">:=</span> {
<span id="L2374" class="LineNr">2374 </span>          { [i_var,  p_vals] <span class="Type">:</span> i_var  <span class="Type">in</span> d_i         } <span class="Type">+</span>
<span id="L2375" class="LineNr">2375 </span>          { [p_var,  p_vals] <span class="Type">:</span> p_var  <span class="Type">in</span> <span class="Identifier">range</span>(d_p)  } <span class="Type">+</span>
<span id="L2376" class="LineNr">2376 </span>          { [cp_var, p_vals] <span class="Type">:</span> cp_var <span class="Type">in</span> <span class="Identifier">range</span>(d_cp) }
<span id="L2377" class="LineNr">2377 </span>          <span class="Type">:</span> p_vals <span class="Type">in</span> poss_p_vals
<span id="L2378" class="LineNr">2378 </span>        };
<span id="L2379" class="LineNr">2379 </span>
<span id="L2380" class="LineNr">2380 </span>        <span class="Statement">return</span> <span class="Type">+/</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>(
<span id="L2381" class="LineNr">2381 </span>          { poss_r_ps, <span class="Identifier">da</span>().<a class="Identifier code-proc-link" href="#da-2387">poss_r_ue</a>(poss_ue_vals, d_u) } <span class="Type">+</span>
<span id="L2382" class="LineNr">2382 </span>          { <span class="Identifier">da</span>().<a class="Identifier code-proc-link" href="#da-2387">poss_r_ue</a>(poss_ue_vals, n_i[<span class="Constant">'e'</span>]) <span class="Type">:</span> n_i <span class="Type">in</span> d_n } <span class="Type">+</span>
<span id="L2383" class="LineNr">2383 </span>          { <span class="Identifier">da</span>().<a class="Identifier code-proc-link" href="#da-2392">poss_r_z</a>(poss_z_vals, d_z) <span class="Type">:</span> d_z <span class="Type">in</span> { d_o, d_m, d_m2 } }
<span id="L2384" class="LineNr">2384 </span>        );
<span id="L2385" class="LineNr">2385 </span>      }; <span class="Comment">// end poss_rs</span>
<span id="L2386" class="LineNr">2386 </span>
<span id="L2387" class="LineNr"><a href="#tda-1311" data-file="test_decision_algorithm" title="test_poss_r_ue" class="checkmark">&#10004;</a>2387 </span>        <span class="Identifier">poss_r_ue</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(poss_ue_vals, ue) {
<span id="L2388" class="LineNr">2388 </span>          <span class="Statement">return</span> { { [ue_var, ue_vals] <span class="Type">:</span> ue_var <span class="Type">in</span> <span class="Identifier">range</span>(ue) }
<span id="L2389" class="LineNr">2389 </span>                   <span class="Type">:</span> ue_vals <span class="Type">in</span> poss_ue_vals };
<span id="L2390" class="LineNr">2390 </span>        };
<span id="L2391" class="LineNr">2391 </span>
<span id="L2392" class="LineNr"><a href="#tda-1294" data-file="test_decision_algorithm" title="test_poss_r_z" class="checkmark">&#10004;</a>2392 </span>        <span class="Identifier">poss_r_z</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(poss_z_vals, d_z) {
<span id="L2393" class="LineNr">2393 </span>          <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {z_var} <span class="Type">&gt;&lt;</span> poss_z_vals <span class="Type">:</span> z_var <span class="Type">in</span> d_z });
<span id="L2394" class="LineNr">2394 </span>        };
<span id="L2395" class="LineNr">2395 </span>
<span id="L2396" class="LineNr">2396 </span>      <span class="Identifier">poss_ds</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(z, d_i, d_o, d_p, d_cp, d_u, d_m, d_m2, d_n, d_r) {
<span id="L2397" class="LineNr">2397 </span>        poss_is_state <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(d_i <span class="Type">+</span> d_p <span class="Type">+</span> d_cp <span class="Type">+</span>
<span id="L2398" class="LineNr">2398 </span>                                         d_u <span class="Type">+</span> d_m <span class="Type">+</span> d_m2 <span class="Type">+</span> d_n, d_r);
<span id="L2399" class="LineNr">2399 </span>        poss_s_state  <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(d_p <span class="Type">+</span> d_cp <span class="Type">+</span> d_u <span class="Type">+</span>
<span id="L2400" class="LineNr">2400 </span>                                         d_m <span class="Type">+</span> d_m2 <span class="Type">+</span> d_n, d_r);
<span id="L2401" class="LineNr">2401 </span>        poss_t_s <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-319">function_space</a>(poss_is_state, poss_s_state);
<span id="L2402" class="LineNr">2402 </span>
<span id="L2403" class="LineNr">2403 </span>        poss_p_u_m2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(d_p <span class="Type">+</span> d_u <span class="Type">+</span> d_m2, d_r);
<span id="L2404" class="LineNr">2404 </span>        poss_o_state <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(d_o, d_r);
<span id="L2405" class="LineNr">2405 </span>        poss_t_o <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-319">function_space</a>(poss_p_u_m2, poss_o_state);
<span id="L2406" class="LineNr">2406 </span>
<span id="L2407" class="LineNr">2407 </span>        das <span class="Statement">:=</span> {
<span id="L2408" class="LineNr">2408 </span>          <span class="Identifier">decision_algorithm</span>(d_i, d_o, d_p, d_cp, d_u, d_m, d_m2, d_n,
<span id="L2409" class="LineNr">2409 </span>                             d_r, d_t_s, d_t_o, <span class="Constant">om</span>, <span class="Constant">om</span>, <span class="Constant">om</span>)
<span id="L2410" class="LineNr">2410 </span>          <span class="Type">:</span> [d_t_s, d_t_o] <span class="Type">in</span> poss_t_s <span class="Type">&gt;&lt;</span> poss_t_o
<span id="L2411" class="LineNr">2411 </span>        };
<span id="L2412" class="LineNr">2412 </span>        <span class="Statement">return</span> { da <span class="Type">:</span> da <span class="Type">in</span> das <span class="Type">|</span> da.<a class="Identifier code-proc-link" href="#da-455">is_valid</a>() <span class="Type">&amp;&amp;</span> <span class="Type">#</span>da.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() <span class="Type">&lt;=</span> z};
<span id="L2413" class="LineNr">2413 </span>      };
<span id="L2414" class="LineNr">2414 </span>
<span id="L2415" class="LineNr">2415 <a title="1.2.1" class="back_to_li" href="#t-1-2-1"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">better_explanation</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(b) {
<span id="L2416" class="LineNr">2416 </span>      <span class="Statement">return</span> <span class="Type">procedure</span>(d1, d2) {
<span id="L2417" class="LineNr">2417 </span>               <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2421">expl_score</a>(b, d1) <span class="Type">&gt;</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2421">expl_score</a>(b, d2);
<span id="L2418" class="LineNr">2418 </span>             };
<span id="L2419" class="LineNr">2419 </span>    };
<span id="L2420" class="LineNr">2420 </span>
<span id="L2421" class="LineNr">2421 </span>      <span class="Identifier">expl_score</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(b, d_i) {
<span id="L2422" class="LineNr">2422 </span>        <span class="Statement">return</span> d_i.<a class="Identifier code-proc-link" href="#da-1434">ambitiousness</a>(b) <span class="Type">-</span> d_i.<a class="Identifier code-proc-link" href="#da-1383">complexity</a>(b)
<span id="L2423" class="LineNr">2423 </span>               <span class="Type">-</span> d_i.<a class="Identifier code-proc-link" href="#da-789">instr_irrat</a>(b) <span class="Type">-</span> d_i.<a class="Identifier code-proc-link" href="#da-866">incoherence</a>(b);
<span id="L2424" class="LineNr">2424 </span>      };
<span id="L2425" class="LineNr">2425 </span>
<span id="L2426" class="LineNr">2426 </span>    <span class="Identifier">simpler</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L2427" class="LineNr">2427 </span>      <span class="Statement">return</span> <span class="Type">procedure</span>(d1, d2) {
<span id="L2428" class="LineNr">2428 </span>               <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(d1.to_s) <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#l-769">k</a>(d2.to_s);
<span id="L2429" class="LineNr">2429 </span>             };
<span id="L2430" class="LineNr">2430 </span>    };
<span id="L2431" class="LineNr">2431 </span>
<span id="L2432" class="LineNr"><a href="#tda-55" data-file="test_decision_algorithm" title="test_new" class="checkmark">&#10004;</a>2432 </span>    <span class="Identifier">new</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L2433" class="LineNr">2433 </span>      <span class="Statement">return</span> <span class="Identifier">decision_algorithm</span>({}, {}, {}, {}, {}, {}, {}, [], {}, {}, {},
<span id="L2434" class="LineNr">2434 </span>                                <span class="Constant">om</span>, <span class="Constant">om</span>, <span class="Constant">om</span>);
<span id="L2435" class="LineNr">2435 </span>    };
<span id="L2436" class="LineNr">2436 </span>
<span id="L2437" class="LineNr">2437 </span>  }
<span id="L2438" class="LineNr">2438 </span>}
<span id="L2439" class="LineNr">2439 </span>
<span id="L2440" class="LineNr">2440 </span><span class="Comment">// alias </span>
<span id="L2441" class="LineNr">2441 </span><span class="Identifier">da</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <span class="Statement">return</span> decision_algorithm; };
</pre>
<pre class="vimCodeElement test_code" id="test_decision_algorithm"><span id="L1" class="LineNr">   1 </span><span class="Identifier">print</span>(<span class="Constant">"</span><span class="Special">\n</span><span class="Constant">Testing Decision Algorithm"</span>);
<span id="L2" class="LineNr">   2 </span><span class="Identifier">print</span>(  <span class="Constant">"=========================="</span>);
<span id="L3" class="LineNr">   3 </span>
<span id="L4" class="LineNr"><a href="#da-123" data-file="decision_algorithm" title="s" class="back_to_proc">&#8629;</a>   4 </span><span class="Identifier">test_s</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L5" class="LineNr">   5 </span>  d <span class="Statement">:=</span> <span class="Identifier">decision_algorithm</span>({<span class="Constant">'I'</span>}, {<span class="Constant">'O'</span>}, { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>] }, <span class="Comment">// i, o, p</span>
<span id="L6" class="LineNr">   6 </span>    { [[<span class="Constant">'A'</span>, <span class="Constant">'A'</span>], <span class="Constant">'P(A|A)'</span>] }, {[<span class="Constant">'A'</span>,<span class="Constant">'U(A)'</span>]}, {<span class="Constant">'M'</span>}, {<span class="Constant">'M2'</span>}, <span class="Comment">// cp, u, m, m2</span>
<span id="L7" class="LineNr">   7 </span>    [{ [<span class="Constant">'e'</span>, {[<span class="Constant">'B'</span>,<span class="Constant">'E_n1(B)'</span>]}], [<span class="Constant">'m2'</span>, {<span class="Constant">'M2_n1'</span>}], [<span class="Constant">'o'</span>, {<span class="Constant">'O_n1'</span>}] }], <span class="Comment">// n</span>
<span id="L8" class="LineNr">   8 </span>    {}, {}, {}, <span class="Constant">om</span>, <span class="Constant">om</span>, <span class="Constant">om</span>); <span class="Comment">// r, t_s, t_o, cacheds</span>
<span id="L9" class="LineNr">   9 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-123">s</a>() <span class="Type">==</span> { <span class="Constant">'P(A)'</span>, <span class="Constant">'P(A|A)'</span>, <span class="Constant">'U(A)'</span>, <span class="Constant">'M'</span>, <span class="Constant">'M2'</span>,
<span id="L10" class="LineNr">  10 </span>                    <span class="Constant">'E_n1(B)'</span>, <span class="Constant">'M2_n1'</span>, <span class="Constant">'O_n1'</span> },
<span id="L11" class="LineNr">  11 </span>         <span class="Constant">"Error: s is incorrect."</span>);
<span id="L12" class="LineNr">  12 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] s'</span>);
<span id="L13" class="LineNr">  13 </span>};
<span id="L14" class="LineNr">  14 </span><span class="Identifier">test_s</span>();
<span id="L15" class="LineNr">  15 </span>
<span id="L16" class="LineNr"><a href="#da-152" data-file="decision_algorithm" title="t" class="back_to_proc">&#8629;</a>  16 </span><span class="Identifier">test_t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L17" class="LineNr">  17 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L18" class="LineNr">  18 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'I'</span> };
<span id="L19" class="LineNr">  19 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L20" class="LineNr">  20 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P'</span>] };
<span id="L21" class="LineNr">  21 </span>  d.t_s <span class="Statement">:=</span> { <span class="Comment">// is                         -&gt; s</span>
<span id="L22" class="LineNr">  22 </span>             [{ [<span class="Constant">'I'</span>, <span class="Constant">false</span>], [<span class="Constant">'P'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'P'</span>, <span class="Constant">false</span>] }],
<span id="L23" class="LineNr">  23 </span>             [{ [<span class="Constant">'I'</span>, <span class="Constant">false</span>], [<span class="Constant">'P'</span>, <span class="Constant">true</span> ] }, { [<span class="Constant">'P'</span>, <span class="Constant">true</span> ] }],
<span id="L24" class="LineNr">  24 </span>             [{ [<span class="Constant">'I'</span>, <span class="Constant">true</span> ], [<span class="Constant">'P'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'P'</span>, <span class="Constant">true</span> ] }],
<span id="L25" class="LineNr">  25 </span>             [{ [<span class="Constant">'I'</span>, <span class="Constant">true</span> ], [<span class="Constant">'P'</span>, <span class="Constant">true</span> ] }, { [<span class="Constant">'P'</span>, <span class="Constant">false</span>] }]
<span id="L26" class="LineNr">  26 </span>           }; <span class="Comment">// xor</span>
<span id="L27" class="LineNr">  27 </span>  d.t_o <span class="Statement">:=</span> { <span class="Comment">// p u m2       -&gt; o</span>
<span id="L28" class="LineNr">  28 </span>             [{ [<span class="Constant">'P'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'O'</span>, <span class="Constant">false</span>] }],
<span id="L29" class="LineNr">  29 </span>             [{ [<span class="Constant">'P'</span>, <span class="Constant">true</span> ] }, { [<span class="Constant">'O'</span>, <span class="Constant">true</span> ] }]
<span id="L30" class="LineNr">  30 </span>           }; <span class="Comment">// identity</span>
<span id="L31" class="LineNr">  31 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-152">t</a>() <span class="Type">==</span> {
<span id="L32" class="LineNr">  32 </span>           <span class="Comment">// is                         -&gt;  so</span>
<span id="L33" class="LineNr">  33 </span>           [{[<span class="Constant">"I"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">false</span>]}, {[<span class="Constant">"O"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">false</span>]}],
<span id="L34" class="LineNr">  34 </span>           [{[<span class="Constant">"I"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">true</span> ]}, {[<span class="Constant">"O"</span>, <span class="Constant">true</span> ], [<span class="Constant">"P"</span>, <span class="Constant">true</span> ]}],
<span id="L35" class="LineNr">  35 </span>           [{[<span class="Constant">"I"</span>, <span class="Constant">true</span> ], [<span class="Constant">"P"</span>, <span class="Constant">false</span>]}, {[<span class="Constant">"O"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">true</span> ]}],
<span id="L36" class="LineNr">  36 </span>           [{[<span class="Constant">"I"</span>, <span class="Constant">true</span> ], [<span class="Constant">"P"</span>, <span class="Constant">true</span> ]}, {[<span class="Constant">"O"</span>, <span class="Constant">true</span> ], [<span class="Constant">"P"</span>, <span class="Constant">false</span>]}]
<span id="L37" class="LineNr">  37 </span>         },
<span id="L38" class="LineNr">  38 </span>         <span class="Constant">"Error: t is incorrect."</span>);
<span id="L39" class="LineNr">  39 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] t'</span>);
<span id="L40" class="LineNr">  40 </span>};
<span id="L41" class="LineNr">  41 </span><span class="Identifier">test_t</span>();
<span id="L42" class="LineNr">  42 </span>
<span id="L43" class="LineNr"><a href="#da-170" data-file="decision_algorithm" title="ns" class="back_to_proc">&#8629;</a>  43 </span><span class="Identifier">test_ns</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L44" class="LineNr">  44 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L45" class="LineNr">  45 </span>  d.n <span class="Statement">:=</span> [{ [<span class="Constant">'e'</span>, {[<span class="Constant">'A'</span>,<span class="Constant">'E_n1(A)'</span>]}], [<span class="Constant">'m2'</span>, {<span class="Constant">'M2_n1'</span>}], [<span class="Constant">'o'</span>, {<span class="Constant">'O_n1'</span>}] },
<span id="L46" class="LineNr">  46 </span>          { [<span class="Constant">'e'</span>, {[<span class="Constant">'B'</span>,<span class="Constant">'E_n2(B)'</span>]}], [<span class="Constant">'m2'</span>, {<span class="Constant">'M2_n2'</span>}], [<span class="Constant">'o'</span>, {<span class="Constant">'O_n2'</span>}] } ];
<span id="L47" class="LineNr">  47 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-170">ns</a>( <span class="Constant">'e'</span>) <span class="Type">==</span> { <span class="Constant">'E_n1(A)'</span>, <span class="Constant">'E_n2(B)'</span> } <span class="Type">&amp;&amp;</span>
<span id="L48" class="LineNr">  48 </span>         d.<span class="Identifier">ns</span>(<span class="Constant">'m2'</span>) <span class="Type">==</span> {   <span class="Constant">'M2_n1'</span>, <span class="Constant">'M2_n2'</span>   } <span class="Type">&amp;&amp;</span>
<span id="L49" class="LineNr">  49 </span>         d.<span class="Identifier">ns</span>( <span class="Constant">'o'</span>) <span class="Type">==</span> {    <span class="Constant">'O_n1'</span>, <span class="Constant">'O_n2'</span>    },
<span id="L50" class="LineNr">  50 </span>         <span class="Constant">"Error: ns is incorrect."</span>);
<span id="L51" class="LineNr">  51 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] ns'</span>);
<span id="L52" class="LineNr">  52 </span>};
<span id="L53" class="LineNr">  53 </span><span class="Identifier">test_ns</span>();
<span id="L54" class="LineNr">  54 </span>
<span id="L55" class="LineNr"><a href="#da-2432" data-file="decision_algorithm" title="new" class="back_to_proc">&#8629;</a>  55 </span><span class="Identifier">test_new</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L56" class="LineNr">  56 </span>  <span class="Statement">assert</span>(decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>().t_o <span class="Type">==</span> {},
<span id="L57" class="LineNr">  57 </span>         <span class="Constant">"Error: new is incorrect."</span>);
<span id="L58" class="LineNr">  58 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] new'</span>);
<span id="L59" class="LineNr">  59 </span>};
<span id="L60" class="LineNr">  60 </span><span class="Identifier">test_new</span>();
<span id="L61" class="LineNr">  61 </span>
<span id="L62" class="LineNr"><a href="#da-182" data-file="decision_algorithm" title="p_u_vars" class="back_to_proc">&#8629;</a>  62 </span><span class="Identifier">test_p_u_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L63" class="LineNr">  63 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L64" class="LineNr">  64 </span>  d.p  <span class="Statement">:=</span> { [       <span class="Constant">'A'</span>,   <span class="Constant">'P(A)'</span>] };
<span id="L65" class="LineNr">  65 </span>  d.cp <span class="Statement">:=</span> { [[<span class="Constant">'A'</span>, <span class="Constant">'A'</span>], <span class="Constant">'P(A|A)'</span>] };
<span id="L66" class="LineNr">  66 </span>  d.u  <span class="Statement">:=</span> { [       <span class="Constant">'A'</span>,   <span class="Constant">'U(A)'</span>] };
<span id="L67" class="LineNr">  67 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-182">p_u_vars</a>() <span class="Type">==</span> {<span class="Constant">'P(A)'</span>, <span class="Constant">'P(A|A)'</span>, <span class="Constant">'U(A)'</span>},
<span id="L68" class="LineNr">  68 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L69" class="LineNr">  69 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] p_u_vars'</span>);
<span id="L70" class="LineNr">  70 </span>};
<span id="L71" class="LineNr">  71 </span><span class="Identifier">test_p_u_vars</span>();
<span id="L72" class="LineNr"><a href="#da-178" data-file="decision_algorithm" title="p_vars" class="back_to_proc">&#8629;</a>  72 </span><span class="Identifier">test_p_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-62">test_p_u_vars</a>(); };
<span id="L73" class="LineNr">  73 </span>
<span id="L74" class="LineNr"><a href="#da-188" data-file="decision_algorithm" title="just_p_u_m2" class="back_to_proc">&#8629;</a>  74 </span><span class="Identifier">test_just_p_u_m2</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L75" class="LineNr">  75 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L76" class="LineNr">  76 </span>  d.i  <span class="Statement">:=</span> { <span class="Constant">'I'</span> };
<span id="L77" class="LineNr">  77 </span>  d.p  <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>] };
<span id="L78" class="LineNr">  78 </span>  d.u  <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'U(A)'</span>] };
<span id="L79" class="LineNr">  79 </span>  d.m2 <span class="Statement">:=</span> { <span class="Constant">'M2'</span> };
<span id="L80" class="LineNr">  80 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-188">just_p_u_m2</a>({ [<span class="Constant">'I'</span>, <span class="Constant">true</span>],
<span id="L81" class="LineNr">  81 </span>                         [<span class="Constant">'P(A)'</span>, <span class="Constant">0.3</span>], [<span class="Constant">'U(A)'</span>, <span class="Constant">4</span>], [<span class="Constant">'M2'</span>, <span class="Constant">true</span>] }) <span class="Type">==</span>
<span id="L82" class="LineNr">  82 </span>                       { [<span class="Constant">'P(A)'</span>, <span class="Constant">0.3</span>], [<span class="Constant">'U(A)'</span>, <span class="Constant">4</span>], [<span class="Constant">'M2'</span>, <span class="Constant">true</span>] },
<span id="L83" class="LineNr">  83 </span>         <span class="Constant">"Error: just_p_u_m2 is incorrect."</span>);
<span id="L84" class="LineNr">  84 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] just_p_u_m2'</span>);
<span id="L85" class="LineNr">  85 </span>};
<span id="L86" class="LineNr">  86 </span><span class="Identifier">test_just_p_u_m2</span>();
<span id="L87" class="LineNr">  87 </span>
<span id="L88" class="LineNr"><a href="#da-197" data-file="decision_algorithm" title="parents" class="back_to_proc">&#8629;</a>  88 </span><span class="Identifier">test_parents</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L89" class="LineNr">  89 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L90" class="LineNr">  90 </span>  d.m <span class="Statement">:=</span> { <span class="Constant">'M1'</span>, <span class="Constant">'M2'</span> };
<span id="L91" class="LineNr">  91 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'M1'</span>, {<span class="Constant">true</span>, <span class="Constant">false</span>}], [<span class="Constant">'M2'</span>, {<span class="Constant">true</span>,<span class="Constant">false</span>}] };
<span id="L92" class="LineNr">  92 </span>  d.t_s <span class="Statement">:=</span> { <span class="Comment">// is                  -&gt; s</span>
<span id="L93" class="LineNr">  93 </span>    [{ [<span class="Constant">'M1'</span>, <span class="Constant">false</span>], [<span class="Constant">'M2'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'M1'</span>, <span class="Constant">true</span> ], [<span class="Constant">'M2'</span>, <span class="Constant">true</span> ] }],
<span id="L94" class="LineNr">  94 </span>    [{ [<span class="Constant">'M1'</span>, <span class="Constant">false</span>], [<span class="Constant">'M2'</span>, <span class="Constant">true</span> ] }, { [<span class="Constant">'M1'</span>, <span class="Constant">false</span>], [<span class="Constant">'M2'</span>, <span class="Constant">true</span> ] }],
<span id="L95" class="LineNr">  95 </span>    [{ [<span class="Constant">'M1'</span>, <span class="Constant">true</span> ], [<span class="Constant">'M2'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'M1'</span>, <span class="Constant">false</span>], [<span class="Constant">'M2'</span>, <span class="Constant">false</span>] }],
<span id="L96" class="LineNr">  96 </span>    [{ [<span class="Constant">'M1'</span>, <span class="Constant">true</span> ], [<span class="Constant">'M2'</span>, <span class="Constant">true</span> ] }, { [<span class="Constant">'M1'</span>, <span class="Constant">true</span> ], [<span class="Constant">'M2'</span>, <span class="Constant">false</span>] }]
<span id="L97" class="LineNr">  97 </span>  }; <span class="Comment Heading">// M1 = ~xor; M2 = ~M1</span>
<span id="L98" class="LineNr">  98 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-197">parents</a>(<span class="Constant">'M1'</span>) <span class="Type">==</span> {<span class="Constant">'M1'</span>, <span class="Constant">'M2'</span>} <span class="Type">&amp;&amp;</span> d.<a class="Identifier code-proc-link" href="#da-197">parents</a>(<span class="Constant">'M2'</span>) <span class="Type">==</span> {<span class="Constant">'M1'</span>},
<span id="L99" class="LineNr">  99 </span>         <span class="Constant">"Error: parents is incorrect."</span>);
<span id="L100" class="LineNr"> 100 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] parents'</span>);
<span id="L101" class="LineNr"> 101 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-218">children</a>(<span class="Constant">'M1'</span>) <span class="Type">==</span> { <span class="Constant">'M1'</span>, <span class="Constant">'M2'</span> } <span class="Type">&amp;&amp;</span> d.<a class="Identifier code-proc-link" href="#da-218">children</a>(<span class="Constant">'M2'</span>) <span class="Type">==</span> {<span class="Constant">'M1'</span>},
<span id="L102" class="LineNr"> 102 </span>        <span class="Constant">"Error: children is incorrect."</span>);
<span id="L103" class="LineNr"> 103 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] children'</span>);
<span id="L104" class="LineNr"> 104 </span>};
<span id="L105" class="LineNr"><a href="#da-218" data-file="decision_algorithm" title="children" class="back_to_proc">&#8629;</a> 105 </span><span class="Identifier">test_children</span>               <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-88">test_parents</a>(); };
<span id="L106" class="LineNr"><a href="#da-202" data-file="decision_algorithm" title="is_necessary_parent_of" class="back_to_proc">&#8629;</a> 106 </span><span class="Identifier">test_is_necessary_parent_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-88">test_parents</a>(); };
<span id="L107" class="LineNr"><a href="#da-212" data-file="decision_algorithm" title="vals_diff" class="back_to_proc">&#8629;</a> 107 </span><span class="Identifier">test_vals_diff</span>              <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-88">test_parents</a>(); };
<span id="L108" class="LineNr"> 108 </span><span class="Identifier">test_parents</span>();
<span id="L109" class="LineNr"> 109 </span>
<span id="L110" class="LineNr"> 110 </span><span class="Comment Heading">/*   ,------.</span>
<span id="L111" class="LineNr"> 111 </span><span class="Comment">    I--P--Y--X</span>
<span id="L112" class="LineNr"> 112 </span><span class="Comment">     `--U-'</span>
<span id="L113" class="LineNr"> 113 </span><span class="Comment">         `--Z</span>
<span id="L114" class="LineNr"> 114 </span><span class="Comment">*/</span>
<span id="L115" class="LineNr"><a href="#da-225" data-file="decision_algorithm" title="non_shared_ancestors" class="back_to_proc">&#8629;</a> 115 </span><span class="Identifier">test_non_shared_ancestors</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L116" class="LineNr"> 116 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L117" class="LineNr"> 117 </span>  d.i <span class="Statement">:=</span> {<span class="Constant">'I'</span>};
<span id="L118" class="LineNr"> 118 </span>  d.p <span class="Statement">:=</span> {[<span class="Constant">'A'</span>, <span class="Constant">'P'</span>]};
<span id="L119" class="LineNr"> 119 </span>  d.u <span class="Statement">:=</span> {[<span class="Constant">'B'</span>, <span class="Constant">'U'</span>]};
<span id="L120" class="LineNr"> 120 </span>  d.m2 <span class="Statement">:=</span> {<span class="Constant">'X'</span>, <span class="Constant">'Y'</span>, <span class="Constant">'Z'</span>};
<span id="L121" class="LineNr"> 121 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'I'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'P'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}], [<span class="Constant">'U'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}],
<span id="L122" class="LineNr"> 122 </span>           [<span class="Constant">'X'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'Y'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'Z'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L123" class="LineNr"> 123 </span>  <span class="Identifier">ts_proc</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(is_state) {
<span id="L124" class="LineNr"> 124 </span>    <span class="Statement">return</span> { [<span class="Constant">'P'</span>, <span class="Type">!</span>is_state[<span class="Constant">'I'</span>]], [<span class="Constant">'U'</span>, is_state[<span class="Constant">'I'</span>]],
<span id="L125" class="LineNr"> 125 </span>             [<span class="Constant">'X'</span>, <span class="Type">!</span>is_state[<span class="Constant">'Y'</span>] <span class="Type">||</span> is_state[<span class="Constant">'I'</span>]],
<span id="L126" class="LineNr"> 126 </span>             [<span class="Constant">'Y'</span>, is_state[<span class="Constant">'P'</span>] <span class="Type">+</span> is_state[<span class="Constant">'U'</span>] <span class="Type">%</span> <span class="Constant">2</span>],
<span id="L127" class="LineNr"> 127 </span>             [<span class="Constant">'Z'</span>, is_state[<span class="Constant">'U'</span>] <span class="Type">==</span> <span class="Constant">0</span>] };
<span id="L128" class="LineNr"> 128 </span>  };
<span id="L129" class="LineNr"> 129 </span>  d.t_s <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(ts_proc, d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>());
<span id="L130" class="LineNr"> 130 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-225">non_shared_ancestors</a>(<span class="Constant">'X'</span>, d.m2) <span class="Type">==</span> { <span class="Constant">'I'</span>, <span class="Constant">'P'</span>, <span class="Constant">'U'</span> } <span class="Type">&amp;&amp;</span>
<span id="L131" class="LineNr"> 131 </span>         d.<span class="Identifier">non_shared_ancestors</span>(<span class="Constant">'Y'</span>, d.m2) <span class="Type">==</span> { <span class="Constant">'P'</span>, <span class="Constant">'U'</span> } <span class="Type">&amp;&amp;</span>
<span id="L132" class="LineNr"> 132 </span>         d.<span class="Identifier">non_shared_ancestors</span>(<span class="Constant">'Z'</span>, d.m2) <span class="Type">==</span> { <span class="Constant">'U'</span> },
<span id="L133" class="LineNr"> 133 </span>         <span class="Constant">"Error: non_shared_ancestors is incorrect."</span>);
<span id="L134" class="LineNr"> 134 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] non_shared_ancestors'</span>);
<span id="L135" class="LineNr"> 135 </span>
<span id="L136" class="LineNr"> 136 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1344">poss_i_states</a>() <span class="Type">==</span> { {[<span class="Constant">'I'</span>, <span class="Constant">true</span>]}, {[<span class="Constant">'I'</span>, <span class="Constant">false</span>]} },
<span id="L137" class="LineNr"> 137 </span>         <span class="Constant">"Error: poss_i_states is incorrect."</span>);
<span id="L138" class="LineNr"> 138 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_i_states'</span>);
<span id="L139" class="LineNr"> 139 </span>
<span id="L140" class="LineNr"> 140 </span>  <span class="Statement">assert</span>({ {[<span class="Constant">"P"</span>, <span class="Constant">0</span>], [<span class="Constant">"U"</span>, <span class="Constant">0</span>], [<span class="Constant">"X"</span>,  <span class="Constant">true</span>], [<span class="Constant">"Y"</span>,  <span class="Constant">true</span>], [<span class="Constant">"Z"</span>,  <span class="Constant">true</span>]},
<span id="L141" class="LineNr"> 141 </span>           {[<span class="Constant">"P"</span>, <span class="Constant">1</span>], [<span class="Constant">"U"</span>, <span class="Constant">1</span>], [<span class="Constant">"X"</span>, <span class="Constant">false</span>], [<span class="Constant">"Y"</span>, <span class="Constant">false</span>], [<span class="Constant">"Z"</span>, <span class="Constant">false</span>]}
<span id="L142" class="LineNr"> 142 </span>         } <span class="Type">&lt;</span> d.<a class="Identifier code-proc-link" href="#da-1328">poss_s_states</a>(),
<span id="L143" class="LineNr"> 143 </span>         <span class="Constant">"Error: poss_s_states is incorrect"</span>);
<span id="L144" class="LineNr"> 144 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_s_states'</span>);
<span id="L145" class="LineNr"> 145 </span>
<span id="L146" class="LineNr"> 146 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1356">poss_u_states</a>() <span class="Type">==</span> { {[<span class="Constant">'U'</span>, <span class="Constant">0</span>]}, {[<span class="Constant">'U'</span>, <span class="Constant">1</span>]} },
<span id="L147" class="LineNr"> 147 </span>         <span class="Constant">"Error: poss_u_states is incorrect."</span>);
<span id="L148" class="LineNr"> 148 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_u_states'</span>);
<span id="L149" class="LineNr"> 149 </span>
<span id="L150" class="LineNr"> 150 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1555">is_equal_to</a>(d),
<span id="L151" class="LineNr"> 151 </span>         <span class="Constant">"Error: is_equal_to is incorrect"</span>);
<span id="L152" class="LineNr"> 152 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] is_equal_to true'</span>);
<span id="L153" class="LineNr"> 153 </span>
<span id="L154" class="LineNr"> 154 </span>  d2 <span class="Statement">:=</span> d;
<span id="L155" class="LineNr"> 155 </span>  d2.i <span class="Statement">:=</span> d.i <span class="Type">+</span> { <span class="Constant">'I2'</span> };
<span id="L156" class="LineNr"> 156 </span>  <span class="Statement">assert</span>(<span class="Type">!</span>d2.<a class="Identifier code-proc-link" href="#da-1555">is_equal_to</a>(d),
<span id="L157" class="LineNr"> 157 </span>         <span class="Constant">"Error: is_equal_to is incorrect"</span>);
<span id="L158" class="LineNr"> 158 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] is_equal_to false'</span>);
<span id="L159" class="LineNr"> 159 </span>};
<span id="L160" class="LineNr"> 160 </span><span class="Identifier">test_non_shared_ancestors</span>();
<span id="L161" class="LineNr"><a href="#da-1348" data-file="decision_algorithm" title="poss_is_states" class="back_to_proc">&#8629;</a> 161 </span><span class="Identifier">test_poss_is_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-115">test_non_shared_ancestors</a>(); };
<span id="L162" class="LineNr"><a href="#da-1344" data-file="decision_algorithm" title="poss_i_states" class="back_to_proc">&#8629;</a> 162 </span><span class="Identifier">test_poss_i_states</span>  <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-115">test_non_shared_ancestors</a>(); };
<span id="L163" class="LineNr"><a href="#da-1328" data-file="decision_algorithm" title="poss_s_states" class="back_to_proc">&#8629;</a> 163 </span><span class="Identifier">test_poss_s_states</span>  <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-115">test_non_shared_ancestors</a>(); };
<span id="L164" class="LineNr"><a href="#da-1356" data-file="decision_algorithm" title="poss_u_states" class="back_to_proc">&#8629;</a> 164 </span><span class="Identifier">test_poss_u_states</span>  <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-115">test_non_shared_ancestors</a>(); };
<span id="L165" class="LineNr"><a href="#da-1555" data-file="decision_algorithm" title="is_equal_to" class="back_to_proc">&#8629;</a> 165 </span><span class="Identifier">test_is_equal_to</span>    <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-115">test_non_shared_ancestors</a>(); };
<span id="L166" class="LineNr"> 166 </span>
<span id="L167" class="LineNr"> 167 </span>
<span id="L168" class="LineNr"> 168 </span>
<span id="L169" class="LineNr"> 169 </span><span class="Comment">/* X--Y--O</span>
<span id="L170" class="LineNr"> 170 </span><span class="Comment">    `--M--P</span>
<span id="L171" class="LineNr"> 171 </span><span class="Comment">*/</span>
<span id="L172" class="LineNr"><a href="#da-240" data-file="decision_algorithm" title="non_shared_descendants" class="back_to_proc">&#8629;</a> 172 </span><span class="Identifier">test_non_shared_descendants</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L173" class="LineNr"> 173 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L174" class="LineNr"> 174 </span>  d.m2 <span class="Statement">:=</span> {<span class="Constant">'X'</span>, <span class="Constant">'Y'</span>};
<span id="L175" class="LineNr"> 175 </span>  d.o <span class="Statement">:=</span> {<span class="Constant">'O'</span>};
<span id="L176" class="LineNr"> 176 </span>  d.m <span class="Statement">:=</span> {<span class="Constant">'M'</span>};
<span id="L177" class="LineNr"> 177 </span>  d.p <span class="Statement">:=</span> {[<span class="Constant">'A'</span>,<span class="Constant">'P'</span>]};
<span id="L178" class="LineNr"> 178 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'X'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'Y'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'O'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'M'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'P'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}] };
<span id="L179" class="LineNr"> 179 </span>  <span class="Identifier">ts_proc</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(is_state) {
<span id="L180" class="LineNr"> 180 </span>    <span class="Statement">return</span> { [<span class="Constant">'X'</span>, <span class="Constant">true</span>], [<span class="Constant">'Y'</span>, <span class="Type">!</span>is_state[<span class="Constant">'X'</span>]], [<span class="Constant">'O'</span>, is_state[<span class="Constant">'Y'</span>]],
<span id="L181" class="LineNr"> 181 </span>             [<span class="Constant">'M'</span>, is_state[<span class="Constant">'X'</span>]], [<span class="Constant">'P'</span>, <span class="Type">#</span>{ j <span class="Type">:</span> j <span class="Type">in</span> {<span class="Constant">1</span>} <span class="Type">|</span> is_state[<span class="Constant">'M'</span>]}] };
<span id="L182" class="LineNr"> 182 </span>  };
<span id="L183" class="LineNr"> 183 </span>  d.t_s <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(ts_proc, d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>());
<span id="L184" class="LineNr"> 184 </span>  <span class="Identifier">to_proc</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_u_m2) {
<span id="L185" class="LineNr"> 185 </span>    <span class="Statement">return</span> {[ <span class="Constant">'O'</span>, p_u_m2[<span class="Constant">'Y'</span>] ]};
<span id="L186" class="LineNr"> 186 </span>  };
<span id="L187" class="LineNr"> 187 </span>  d.t_o <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(to_proc, { d.<a class="Identifier code-proc-link" href="#da-188">just_p_u_m2</a>(is) <span class="Type">:</span> is <span class="Type">in</span> d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>() });
<span id="L188" class="LineNr"> 188 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-240">non_shared_descendants</a>(<span class="Constant">'X'</span>, d.m2) <span class="Type">==</span> {<span class="Constant">'M'</span>, <span class="Constant">'O'</span>} <span class="Type">&amp;&amp;</span>
<span id="L189" class="LineNr"> 189 </span>         d.<span class="Identifier">non_shared_descendants</span>(<span class="Constant">'Y'</span>, d.m2) <span class="Type">==</span> {<span class="Constant">'O'</span>},
<span id="L190" class="LineNr"> 190 </span>         <span class="Constant">"Error: non_shared_descendants is incorrect."</span>);
<span id="L191" class="LineNr"> 191 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] non_shared_descendants'</span>);
<span id="L192" class="LineNr"> 192 </span>};
<span id="L193" class="LineNr"> 193 </span><span class="Identifier">test_non_shared_descendants</span>();
<span id="L194" class="LineNr"> 194 </span>
<span id="L195" class="LineNr"> 195 </span><span class="Identifier">d1</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L196" class="LineNr"> 196 </span>  d   <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L197" class="LineNr"> 197 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'I'</span> };
<span id="L198" class="LineNr"> 198 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P'</span>] };
<span id="L199" class="LineNr"> 199 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L200" class="LineNr"> 200 </span>  d.r <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> {<span class="Constant">'I'</span>,<span class="Constant">'O'</span>} } <span class="Type">+</span> { [<span class="Constant">'P'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}] };
<span id="L201" class="LineNr"> 201 </span>  d.t_s <span class="Statement">:=</span> { [{[<span class="Constant">'I'</span>, <span class="Constant">false</span>], [<span class="Constant">'P'</span>, <span class="Constant">0</span>]}, {[<span class="Constant">'P'</span>, <span class="Constant">1</span>]}], <span class="Comment">// eg P_t2 = ~I xor P_t1</span>
<span id="L202" class="LineNr"> 202 </span>             [{[<span class="Constant">'I'</span>, <span class="Constant">false</span>], [<span class="Constant">'P'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'P'</span>, <span class="Constant">0</span>]}],
<span id="L203" class="LineNr"> 203 </span>             [{[<span class="Constant">'I'</span>,  <span class="Constant">true</span>], [<span class="Constant">'P'</span>, <span class="Constant">0</span>]}, {[<span class="Constant">'P'</span>, <span class="Constant">0</span>]}],
<span id="L204" class="LineNr"> 204 </span>             [{[<span class="Constant">'I'</span>,  <span class="Constant">true</span>], [<span class="Constant">'P'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'P'</span>, <span class="Constant">1</span>]}]
<span id="L205" class="LineNr"> 205 </span>           };
<span id="L206" class="LineNr"> 206 </span>  d.t_o <span class="Statement">:=</span> { [ {[<span class="Constant">'P'</span>, <span class="Constant">0</span>]}, {[<span class="Constant">'O'</span>,  <span class="Constant">true</span>]} ],  <span class="Comment">// O = ~P</span>
<span id="L207" class="LineNr"> 207 </span>             [ {[<span class="Constant">'P'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'O'</span>, <span class="Constant">false</span>]} ] };
<span id="L208" class="LineNr"> 208 </span>  <span class="Statement">return</span> d;
<span id="L209" class="LineNr"> 209 </span>};
<span id="L210" class="LineNr"> 210 </span>
<span id="L211" class="LineNr"> 211 </span><span class="Identifier">b1</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L212" class="LineNr"> 212 </span>  b   <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L213" class="LineNr"> 213 </span>  b.u <span class="Statement">:=</span> { <span class="Constant">'U'</span> };
<span id="L214" class="LineNr"> 214 </span>  b.v <span class="Statement">:=</span> { <span class="Constant">'V_P1'</span>, <span class="Constant">'V_P2'</span>, <span class="Constant">'O'</span> };
<span id="L215" class="LineNr"> 215 </span>  b.r <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> {<span class="Constant">'V_P1'</span>, <span class="Constant">'V_P2'</span>, <span class="Constant">'O'</span>} } <span class="Type">+</span> {[<span class="Constant">'U'</span>,{<span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span>}]};
<span id="L216" class="LineNr"> 216 </span>  <span class="Comment">/* P = V_P1 &lt;-&gt; V_P2</span>
<span id="L217" class="LineNr"> 217 </span><span class="Comment">     O = ~ P</span>
<span id="L218" class="LineNr"> 218 </span><span class="Comment">     O = ~ (V_P1 &lt;-&gt; V_P2) </span>
<span id="L219" class="LineNr"> 219 </span><span class="Comment">  */</span>
<span id="L220" class="LineNr"> 220 </span>  b.f[<span class="Constant">'O'</span>] <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(<span class="Type">procedure</span>(cmm_st) {
<span id="L221" class="LineNr"> 221 </span>                          <span class="Statement">return</span> <span class="Type">!</span>(cmm_st[<span class="Constant">'V_P1'</span>] <span class="Type">==</span> cmm_st[<span class="Constant">'V_P2'</span>]);
<span id="L222" class="LineNr"> 222 </span>                        }, b.<span class="Identifier">poss_states</span>());
<span id="L223" class="LineNr"> 223 </span>  <span class="Comment">/* P_t2 = I xor P_t1</span>
<span id="L224" class="LineNr"> 224 </span><span class="Comment">          = U xor (V_P1 &lt;-&gt; V_P2)     </span>
<span id="L225" class="LineNr"> 225 </span><span class="Comment">    t1  U V_P1 V_P2 P  ~I  t2  P  V_P1  V_P2</span>
<span id="L226" class="LineNr"> 226 </span><span class="Comment">        1   F   F   T   T      F   T    F</span>
<span id="L227" class="LineNr"> 227 </span><span class="Comment">        1   F   T   F   T      T   T    T</span>
<span id="L228" class="LineNr"> 228 </span><span class="Comment">        1   T   F   F   T      T   F    F</span>
<span id="L229" class="LineNr"> 229 </span><span class="Comment">        1   T   T   T   T      F   F    T</span>
<span id="L230" class="LineNr"> 230 </span><span class="Comment">        2   F   F   T   T      F    </span>
<span id="L231" class="LineNr"> 231 </span><span class="Comment">        2   F   T   F   T      T</span>
<span id="L232" class="LineNr"> 232 </span><span class="Comment">        2   T   F   F   T      T</span>
<span id="L233" class="LineNr"> 233 </span><span class="Comment">        2   T   T   T   T      F</span>
<span id="L234" class="LineNr"> 234 </span><span class="Comment">        3   F   F   T   F      T   F    F    </span>
<span id="L235" class="LineNr"> 235 </span><span class="Comment">        3   F   T   F   F      F   T    F</span>
<span id="L236" class="LineNr"> 236 </span><span class="Comment">        3   T   F   F   F      F   F    T</span>
<span id="L237" class="LineNr"> 237 </span><span class="Comment">        3   T   T   T   F      T   T    T</span>
<span id="L238" class="LineNr"> 238 </span>
<span id="L239" class="LineNr"> 239 </span><span class="Comment">    two ways for U to be false {1,2}. {3} is truth</span>
<span id="L240" class="LineNr"> 240 </span><span class="Comment">  */</span>
<span id="L241" class="LineNr"> 241 </span>  b.f[<span class="Constant">'V_P1'</span>] <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(<span class="Type">procedure</span>(cmm_st) {
<span id="L242" class="LineNr"> 242 </span>                   <span class="Statement">if</span> (cmm_st[<span class="Constant">'U'</span>] <span class="Type">==</span> <span class="Constant">3</span>) {
<span id="L243" class="LineNr"> 243 </span>                     <span class="Statement">return</span> cmm_st[<span class="Constant">'V_P2'</span>];
<span id="L244" class="LineNr"> 244 </span>                   } <span class="Statement">else</span> {
<span id="L245" class="LineNr"> 245 </span>                     <span class="Statement">return</span> <span class="Type">!</span>cmm_st[<span class="Constant">'V_P1'</span>];
<span id="L246" class="LineNr"> 246 </span>                   }
<span id="L247" class="LineNr"> 247 </span>                 }, b.<span class="Identifier">poss_states</span>());
<span id="L248" class="LineNr"> 248 </span>  b.f[<span class="Constant">'V_P2'</span>] <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(<span class="Type">procedure</span>(cmm_st) {
<span id="L249" class="LineNr"> 249 </span>                   <span class="Statement">if</span> (cmm_st[<span class="Constant">'U'</span>] <span class="Type">==</span> <span class="Constant">3</span>) {
<span id="L250" class="LineNr"> 250 </span>                     <span class="Statement">return</span> cmm_st[<span class="Constant">'V_P1'</span>];
<span id="L251" class="LineNr"> 251 </span>                   } <span class="Statement">else</span> {
<span id="L252" class="LineNr"> 252 </span>                     <span class="Statement">return</span> cmm_st[<span class="Constant">'V_P2'</span>];
<span id="L253" class="LineNr"> 253 </span>                   }
<span id="L254" class="LineNr"> 254 </span>                 }, b.<span class="Identifier">poss_states</span>());
<span id="L255" class="LineNr"> 255 </span>  b.n <span class="Statement">:=</span> <span class="Constant">3</span>;
<span id="L256" class="LineNr"> 256 </span>  <span class="Statement">return</span> b;
<span id="L257" class="LineNr"> 257 </span>};
<span id="L258" class="LineNr"> 258 </span>
<span id="L259" class="LineNr"> 259 </span><span class="Identifier">plf1</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L260" class="LineNr"> 260 </span>  <span class="Statement">return</span> { [{ [<span class="Constant">'U'</span>, <span class="Constant">1</span>]                         }, { [<span class="Constant">'I'</span>, <span class="Constant">false</span>] }],
<span id="L261" class="LineNr"> 261 </span>           [{ [<span class="Constant">'U'</span>, <span class="Constant">2</span>]                         }, { [<span class="Constant">'I'</span>, <span class="Constant">false</span>] }],
<span id="L262" class="LineNr"> 262 </span>           [{ [<span class="Constant">'U'</span>, <span class="Constant">3</span>]                         }, { [<span class="Constant">'I'</span>,  <span class="Constant">true</span>] }],
<span id="L263" class="LineNr"> 263 </span>           [{ [<span class="Constant">'V_P1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'P'</span>,     <span class="Constant">1</span>] }],
<span id="L264" class="LineNr"> 264 </span>           [{ [<span class="Constant">'V_P1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2'</span>,  <span class="Constant">true</span>] }, { [<span class="Constant">'P'</span>,     <span class="Constant">0</span>] }],
<span id="L265" class="LineNr"> 265 </span>           [{ [<span class="Constant">'V_P1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_P2'</span>, <span class="Constant">false</span>] }, { [<span class="Constant">'P'</span>,     <span class="Constant">0</span>] }],
<span id="L266" class="LineNr"> 266 </span>           [{ [<span class="Constant">'V_P1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_P2'</span>,  <span class="Constant">true</span>] }, { [<span class="Constant">'P'</span>,     <span class="Constant">1</span>] }],
<span id="L267" class="LineNr"> 267 </span>           [{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>]                     }, { [<span class="Constant">'O'</span>, <span class="Constant">false</span>] }],
<span id="L268" class="LineNr"> 268 </span>           [{ [<span class="Constant">'O'</span>,  <span class="Constant">true</span>]                     }, { [<span class="Constant">'O'</span>,  <span class="Constant">true</span>] }]
<span id="L269" class="LineNr"> 269 </span>         };
<span id="L270" class="LineNr"> 270 </span>};
<span id="L271" class="LineNr"> 271 </span>
<span id="L272" class="LineNr"> 272 </span><span class="Identifier">pf1</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L273" class="LineNr"> 273 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#tda-195">d1</a>().<a class="Identifier code-proc-link" href="#da-439">plf_to_pf</a>(<a class="Identifier code-proc-link" href="#tda-211">b1</a>(), <a class="Identifier code-proc-link" href="#tda-259">plf1</a>());
<span id="L274" class="LineNr"> 274 </span>};
<span id="L275" class="LineNr"> 275 </span>
<span id="L276" class="LineNr"><a href="#da-289" data-file="decision_algorithm" title="poss_states" class="back_to_proc">&#8629;</a> 276 </span><span class="Identifier">test_poss_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L277" class="LineNr"> 277 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-195">d1</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() <span class="Type">==</span> {
<span id="L278" class="LineNr"> 278 </span>           {[<span class="Constant">"I"</span>, <span class="Constant">false</span>], [<span class="Constant">"O"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">0</span>]},
<span id="L279" class="LineNr"> 279 </span>           {[<span class="Constant">"I"</span>, <span class="Constant">false</span>], [<span class="Constant">"O"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">1</span>]},
<span id="L280" class="LineNr"> 280 </span>           {[<span class="Constant">"I"</span>, <span class="Constant">false</span>], [<span class="Constant">"O"</span>,  <span class="Constant">true</span>], [<span class="Constant">"P"</span>, <span class="Constant">0</span>]},
<span id="L281" class="LineNr"> 281 </span>           {[<span class="Constant">"I"</span>, <span class="Constant">false</span>], [<span class="Constant">"O"</span>,  <span class="Constant">true</span>], [<span class="Constant">"P"</span>, <span class="Constant">1</span>]},
<span id="L282" class="LineNr"> 282 </span>           {[<span class="Constant">"I"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">0</span>]},
<span id="L283" class="LineNr"> 283 </span>           {[<span class="Constant">"I"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O"</span>, <span class="Constant">false</span>], [<span class="Constant">"P"</span>, <span class="Constant">1</span>]},
<span id="L284" class="LineNr"> 284 </span>           {[<span class="Constant">"I"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O"</span>,  <span class="Constant">true</span>], [<span class="Constant">"P"</span>, <span class="Constant">0</span>]},
<span id="L285" class="LineNr"> 285 </span>           {[<span class="Constant">"I"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O"</span>,  <span class="Constant">true</span>], [<span class="Constant">"P"</span>, <span class="Constant">1</span>]}
<span id="L286" class="LineNr"> 286 </span>         }, <span class="Constant">"Error: poss_states is incorrect."</span>);
<span id="L287" class="LineNr"> 287 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_states'</span>);
<span id="L288" class="LineNr"> 288 </span>};
<span id="L289" class="LineNr"> 289 </span><span class="Identifier">test_poss_states</span>();
<span id="L290" class="LineNr"> 290 </span>
<span id="L291" class="LineNr"><a href="#da-315" data-file="decision_algorithm" title="commutes" class="back_to_proc">&#8629;</a> 291 </span><span class="Identifier">test_commutes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L292" class="LineNr"> 292 </span>  <span class="Comment">// print('pf ' + pf1());  </span>
<span id="L293" class="LineNr"> 293 </span>
<span id="L294" class="LineNr"> 294 </span>  <span class="Comment">// This may take a while so it's commented out but it worked last time.</span>
<span id="L295" class="LineNr"> 295 </span>  <span class="Comment">// assert(d1().commutes(pf1(), b1()) == true, "Error: commutes true is incorrect.");</span>
<span id="L296" class="LineNr"> 296 </span>  <span class="Comment">// print('[ok] commutes true');</span>
<span id="L297" class="LineNr"> 297 </span>  <span class="Identifier">print</span>(<span class="Constant">'[..] commutes true'</span>);
<span id="L298" class="LineNr"> 298 </span>};
<span id="L299" class="LineNr"> 299 </span><span class="Identifier">test_commutes</span>();
<span id="L300" class="LineNr"> 300 </span>
<span id="L301" class="LineNr"><a href="#da-386" data-file="decision_algorithm" title="lf_commutes" class="back_to_proc">&#8629;</a> 301 </span><span class="Identifier">test_lf_commutes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L302" class="LineNr"> 302 </span>  d <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-195">d1</a>();
<span id="L303" class="LineNr"> 303 </span>  d.cached_f <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-272">pf1</a>();
<span id="L304" class="LineNr"> 304 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-386">lf_commutes</a>(<a class="Identifier code-proc-link" href="#tda-259">plf1</a>(), <a class="Identifier code-proc-link" href="#tda-211">b1</a>()) <span class="Type">==</span> <span class="Constant">true</span>,
<span id="L305" class="LineNr"> 305 </span>         <span class="Constant">"Error: lf_commutes true is incorrect"</span>);
<span id="L306" class="LineNr"> 306 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_commutes true'</span>);
<span id="L307" class="LineNr"> 307 </span>
<span id="L308" class="LineNr"> 308 </span>  plf <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-259">plf1</a>();
<span id="L309" class="LineNr"> 309 </span>  plf[ {[<span class="Constant">'O'</span>, <span class="Constant">false</span>]} ] <span class="Statement">:=</span> { [<span class="Constant">'O'</span>, <span class="Constant">true</span>] };
<span id="L310" class="LineNr"> 310 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-386">lf_commutes</a>(plf, <a class="Identifier code-proc-link" href="#tda-211">b1</a>()) <span class="Type">==</span> <span class="Constant">false</span>,
<span id="L311" class="LineNr"> 311 </span>         <span class="Constant">"Error: lf_commutes false is incorrect"</span>);
<span id="L312" class="LineNr"> 312 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_commutes false'</span>);
<span id="L313" class="LineNr"> 313 </span>};
<span id="L314" class="LineNr"> 314 </span><span class="Identifier">test_lf_commutes</span>();
<span id="L315" class="LineNr"> 315 </span>
<span id="L316" class="LineNr"> 316 </span><span class="Identifier">d2</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L317" class="LineNr"> 317 </span>  d <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-195">d1</a>();
<span id="L318" class="LineNr"> 318 </span>  d.cached_f  <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-272">pf1</a>();
<span id="L319" class="LineNr"> 319 </span>  d.cached_lf <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-259">plf1</a>();
<span id="L320" class="LineNr"> 320 </span>  <span class="Statement">return</span> d;
<span id="L321" class="LineNr"> 321 </span>};
<span id="L322" class="LineNr"> 322 </span>
<span id="L323" class="LineNr"><a href="#da-293" data-file="decision_algorithm" title="is_implemented_by" class="back_to_proc">&#8629;</a> 323 </span><span class="Identifier">test_is_implemented_by</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L324" class="LineNr"> 324 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-293">is_implemented_by</a>(<a class="Identifier code-proc-link" href="#tda-211">b1</a>()) <span class="Type">==</span> <span class="Constant">true</span>,
<span id="L325" class="LineNr"> 325 </span>         <span class="Constant">"Error: is_implemented_by is incorrect."</span>);
<span id="L326" class="LineNr"> 326 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] is_implemented_by'</span>);
<span id="L327" class="LineNr"> 327 </span>};
<span id="L328" class="LineNr"> 328 </span><span class="Identifier">test_is_implemented_by</span>();
<span id="L329" class="LineNr"> 329 </span>
<span id="L330" class="LineNr"><a href="#da-401" data-file="decision_algorithm" title="lf_inv" class="back_to_proc">&#8629;</a> 330 </span><span class="Identifier">test_lf_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L331" class="LineNr"> 331 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-401">lf_inv</a>(<a class="Identifier code-proc-link" href="#tda-211">b1</a>())[ {[<span class="Constant">'P'</span>,<span class="Constant">1</span>]} ] <span class="Type">==</span> {
<span id="L332" class="LineNr"> 332 </span>           { [<span class="Constant">'V_P1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2'</span>, <span class="Constant">false</span>] },
<span id="L333" class="LineNr"> 333 </span>           { [<span class="Constant">'V_P1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_P2'</span>,  <span class="Constant">true</span>] }
<span id="L334" class="LineNr"> 334 </span>         }, <span class="Constant">"Error: lf_inv is incorrect"</span>);
<span id="L335" class="LineNr"> 335 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_inv'</span>);
<span id="L336" class="LineNr"> 336 </span>};
<span id="L337" class="LineNr"> 337 </span><span class="Identifier">test_lf_inv</span>();
<span id="L338" class="LineNr"><a href="#da-439" data-file="decision_algorithm" title="plf_to_pf" class="back_to_proc">&#8629;</a> 338 </span><span class="Identifier">test_plf_to_pf</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-330">test_lf_inv</a>(); };
<span id="L339" class="LineNr"> 339 </span>
<span id="L340" class="LineNr"><a href="#da-407" data-file="decision_algorithm" title="lf_inv_at" class="back_to_proc">&#8629;</a> 340 </span><span class="Identifier">test_lf_inv_at</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L341" class="LineNr"> 341 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-407">lf_inv_at</a>(<a class="Identifier code-proc-link" href="#tda-211">b1</a>(), <span class="Constant">2</span>)[ {[<span class="Constant">'P'</span>,<span class="Constant">1</span>]} ] <span class="Type">==</span> {
<span id="L342" class="LineNr"> 342 </span>           { [<span class="Constant">'V_P1_t2'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2_t2'</span>, <span class="Constant">false</span>] },
<span id="L343" class="LineNr"> 343 </span>           { [<span class="Constant">'V_P1_t2'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_P2_t2'</span>,  <span class="Constant">true</span>] }
<span id="L344" class="LineNr"> 344 </span>         }, <span class="Constant">"Error: lf_inv_at is incorrect"</span>);
<span id="L345" class="LineNr"> 345 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_inv_at'</span>);
<span id="L346" class="LineNr"> 346 </span>};
<span id="L347" class="LineNr"> 347 </span><span class="Identifier">test_lf_inv_at</span>();
<span id="L348" class="LineNr"> 348 </span>
<span id="L349" class="LineNr"><a href="#da-414" data-file="decision_algorithm" title="lf_cm" class="back_to_proc">&#8629;</a> 349 </span><span class="Identifier">test_lf_cm</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L350" class="LineNr"> 350 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-414">lf_cm</a>(<a class="Identifier code-proc-link" href="#tda-211">b1</a>(), {[<span class="Constant">'V_P1_t2'</span>,<span class="Constant">false</span>],[<span class="Constant">'V_P2_t2'</span>,<span class="Constant">false</span>]}) <span class="Type">==</span> {[<span class="Constant">'P'</span>,<span class="Constant">1</span>]},
<span id="L351" class="LineNr"> 351 </span>         <span class="Constant">"Error: lf_cm is incorrect"</span>);
<span id="L352" class="LineNr"> 352 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_cm'</span>);
<span id="L353" class="LineNr"> 353 </span>};
<span id="L354" class="LineNr"> 354 </span><span class="Identifier">test_lf_cm</span>();
<span id="L355" class="LineNr"> 355 </span>
<span id="L356" class="LineNr"><a href="#da-419" data-file="decision_algorithm" title="lf_cm_vs" class="back_to_proc">&#8629;</a> 356 </span><span class="Identifier">test_lf_cm_vs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L357" class="LineNr"> 357 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-419">lf_cm_vs</a>(<a class="Identifier code-proc-link" href="#tda-211">b1</a>(), {[<span class="Constant">'V_P1_t2'</span>,<span class="Constant">false</span>],[<span class="Constant">'V_P2_t2'</span>,<span class="Constant">false</span>] }) <span class="Type">==</span> {<span class="Constant">'P'</span>},
<span id="L358" class="LineNr"> 358 </span>         <span class="Constant">"Error: lf_cm_vs is incorrect"</span>);
<span id="L359" class="LineNr"> 359 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_cm_vs'</span>);
<span id="L360" class="LineNr"> 360 </span>};
<span id="L361" class="LineNr"> 361 </span><span class="Identifier">test_lf_cm_vs</span>();
<span id="L362" class="LineNr"> 362 </span>
<span id="L363" class="LineNr"><a href="#da-430" data-file="decision_algorithm" title="lf_cm_p_inv" class="back_to_proc">&#8629;</a> 363 </span><span class="Identifier">test_lf_cm_p_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L364" class="LineNr"> 364 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-430">lf_cm_p_inv</a>(b, { [<span class="Constant">'V_P1_t2'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2_t2'</span>, <span class="Constant">false</span>] }) <span class="Type">==</span> <span class="Constant">'A'</span>,
<span id="L365" class="LineNr"> 365 </span>         <span class="Constant">"Error: lf_cm_p_inv is incorrect"</span>);
<span id="L366" class="LineNr"> 366 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] p_inv'</span>);
<span id="L367" class="LineNr"> 367 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] lf_cm_p_inv'</span>);
<span id="L368" class="LineNr"> 368 </span>};
<span id="L369" class="LineNr"> 369 </span><span class="Identifier">test_lf_cm_p_inv</span>();
<span id="L370" class="LineNr"><a href="#da-1137" data-file="decision_algorithm" title="p_inv" class="back_to_proc">&#8629;</a> 370 </span><span class="Identifier">test_p_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-363">test_lf_cm_p_inv</a>(); };
<span id="L371" class="LineNr"> 371 </span>
<span id="L372" class="LineNr"> 372 </span><span class="Identifier">test_commutes_f</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L373" class="LineNr"> 373 </span>  <span class="Comment">// print('b.f[O] ' + b.f['O']);</span>
<span id="L374" class="LineNr"> 374 </span>  b <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-211">b1</a>();
<span id="L375" class="LineNr"> 375 </span>  b.f[<span class="Constant">'O'</span>] <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(<span class="Type">procedure</span>(cmm_st) {
<span id="L376" class="LineNr"> 376 </span>                          <span class="Statement">return</span> cmm_st[<span class="Constant">'V_P1'</span>] <span class="Type">&amp;&amp;</span> cmm_st[<span class="Constant">'V_P2'</span>];
<span id="L377" class="LineNr"> 377 </span>                        }, b.<span class="Identifier">poss_states</span>());
<span id="L378" class="LineNr"> 378 </span>  <span class="Comment">// print('b.f[O] ' + b.f['O']);</span>
<span id="L379" class="LineNr"> 379 </span>  <span class="Comment">// bs := {["O", true], ["U", 3], ["V_P1", true], ["V_P2", true]};</span>
<span id="L380" class="LineNr"> 380 </span>  <span class="Comment">// print('pf[bs] ' + pf[bs]);</span>
<span id="L381" class="LineNr"> 381 </span>  <span class="Comment">// print('t()[pf[bs]] ' + d.t()[pf[bs]]);</span>
<span id="L382" class="LineNr"> 382 </span>  <span class="Comment">// print('b.resp ' + b.response(b.v, bs));</span>
<span id="L383" class="LineNr"> 383 </span>  <span class="Comment">// print('pf[b.resp] ' + pf[b.response(b.v, bs)]);</span>
<span id="L384" class="LineNr"> 384 </span>
<span id="L385" class="LineNr"> 385 </span>  <span class="Comment">// assert(d1().commutes(pf1(), b) == false, "Error: commutes false is incorrect.");</span>
<span id="L386" class="LineNr"> 386 </span>  <span class="Comment">// print('[ok] commutes false');</span>
<span id="L387" class="LineNr"> 387 </span>  <span class="Identifier">print</span>(<span class="Constant">'[..] commutes false'</span>);
<span id="L388" class="LineNr"> 388 </span>};
<span id="L389" class="LineNr"> 389 </span><span class="Identifier">test_commutes_f</span>();
<span id="L390" class="LineNr"> 390 </span>
<span id="L391" class="LineNr"><a href="#da-356" data-file="decision_algorithm" title="drop_i" class="back_to_proc">&#8629;</a> 391 </span><span class="Identifier">test_drop_i</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L392" class="LineNr"> 392 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L393" class="LineNr"> 393 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'P(I_1)'</span>, <span class="Constant">'P(I_2)'</span> };
<span id="L394" class="LineNr"> 394 </span>  ds  <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">1</span>], [<span class="Constant">'P(I_1)'</span>, <span class="Constant">true</span>], [<span class="Constant">'P(I_2)'</span>, <span class="Constant">false</span>], [<span class="Constant">'M1'</span>, <span class="Constant">true</span>] };
<span id="L395" class="LineNr"> 395 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-356">drop_i</a>(ds) <span class="Type">==</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">1</span>], [<span class="Constant">'M1'</span>, <span class="Constant">true</span>] },
<span id="L396" class="LineNr"> 396 </span>         <span class="Constant">"Error: drop_i is incorrect."</span>);
<span id="L397" class="LineNr"> 397 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] drop_i'</span>);
<span id="L398" class="LineNr"> 398 </span>};
<span id="L399" class="LineNr"> 399 </span><span class="Identifier">test_drop_i</span>();
<span id="L400" class="LineNr"> 400 </span>
<span id="L401" class="LineNr"> 401 </span><span class="Comment">/*   </span>
<span id="L402" class="LineNr"> 402 </span><span class="Comment">    I--P--Y--X--O</span>
<span id="L403" class="LineNr"> 403 </span><span class="Comment">     `--U-'</span>
<span id="L404" class="LineNr"> 404 </span><span class="Comment">         `--Z--W</span>
<span id="L405" class="LineNr"> 405 </span><span class="Comment Heading">*/</span>
<span id="L406" class="LineNr"><a href="#da-463" data-file="decision_algorithm" title="m2s_are_valid" class="back_to_proc">&#8629;</a> 406 </span><span class="Identifier">test_m2s_are_valid</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L407" class="LineNr"> 407 </span>  d    <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L408" class="LineNr"> 408 </span>  d.i  <span class="Statement">:=</span> { <span class="Constant">'I'</span> };
<span id="L409" class="LineNr"> 409 </span>  d.p  <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P'</span>] };
<span id="L410" class="LineNr"> 410 </span>  d.u  <span class="Statement">:=</span> { [<span class="Constant">'B'</span>, <span class="Constant">'U'</span>] };
<span id="L411" class="LineNr"> 411 </span>  d.m2 <span class="Statement">:=</span> { <span class="Constant">'X'</span>, <span class="Constant">'Y'</span>, <span class="Constant">'Z'</span> };
<span id="L412" class="LineNr"> 412 </span>  d.o  <span class="Statement">:=</span> { <span class="Constant">'W'</span>, <span class="Constant">'O'</span> };
<span id="L413" class="LineNr"> 413 </span>  d.r  <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> d.i <span class="Type">+</span> d.<a class="Identifier code-proc-link" href="#da-123">s</a>() };
<span id="L414" class="LineNr"> 414 </span>  <span class="Identifier">ts_proc</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(is_state) {
<span id="L415" class="LineNr"> 415 </span>    <span class="Statement">return</span> { [<span class="Constant">'P'</span>, <span class="Type">!</span>is_state[<span class="Constant">'I'</span>]], [<span class="Constant">'U'</span>, is_state[<span class="Constant">'I'</span>]],
<span id="L416" class="LineNr"> 416 </span>             [<span class="Constant">'X'</span>, <span class="Type">!</span>is_state[<span class="Constant">'Y'</span>]],
<span id="L417" class="LineNr"> 417 </span>             [<span class="Constant">'Y'</span>, is_state[<span class="Constant">'P'</span>] <span class="Type">&amp;&amp;</span> is_state[<span class="Constant">'U'</span>]],
<span id="L418" class="LineNr"> 418 </span>             [<span class="Constant">'Z'</span>, is_state[<span class="Constant">'U'</span>] <span class="Type">==</span> <span class="Constant">0</span>] };
<span id="L419" class="LineNr"> 419 </span>  };
<span id="L420" class="LineNr"> 420 </span>  d.t_s <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(ts_proc, d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>());
<span id="L421" class="LineNr"> 421 </span>  <span class="Identifier">to_proc</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p_u_m2) {
<span id="L422" class="LineNr"> 422 </span>    <span class="Statement">return</span> { [<span class="Constant">'O'</span>, p_u_m2[<span class="Constant">'X'</span>]], [<span class="Constant">'W'</span>, p_u_m2[<span class="Constant">'W'</span>]] };
<span id="L423" class="LineNr"> 423 </span>  };
<span id="L424" class="LineNr"> 424 </span>  d.t_o <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(to_proc, { d.<a class="Identifier code-proc-link" href="#da-188">just_p_u_m2</a>(is) <span class="Type">:</span> is <span class="Type">in</span> d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>() });
<span id="L425" class="LineNr"> 425 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-463">m2s_are_valid</a>() <span class="Type">==</span> <span class="Constant">true</span>, <span class="Constant">"Error: is incorrect."</span>);
<span id="L426" class="LineNr"> 426 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] m2s_are_valid true'</span>);
<span id="L427" class="LineNr"> 427 </span>
<span id="L428" class="LineNr"> 428 </span>  <span class="Comment Heading">// I------X</span>
<span id="L429" class="LineNr"> 429 </span>  <span class="Identifier">ts_proc2</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(is_state) {
<span id="L430" class="LineNr"> 430 </span>    <span class="Statement">return</span> { [<span class="Constant">'P'</span>, <span class="Type">!</span>is_state[<span class="Constant">'I'</span>]], [<span class="Constant">'U'</span>, is_state[<span class="Constant">'I'</span>]],
<span id="L431" class="LineNr"> 431 </span>             [<span class="Constant">'X'</span>, <span class="Type">!</span>is_state[<span class="Constant">'Y'</span>] <span class="Type">||</span> is_state[<span class="Constant">'I'</span>]],
<span id="L432" class="LineNr"> 432 </span>             [<span class="Constant">'Y'</span>, is_state[<span class="Constant">'P'</span>] <span class="Type">&amp;&amp;</span> is_state[<span class="Constant">'U'</span>]],
<span id="L433" class="LineNr"> 433 </span>             [<span class="Constant">'Z'</span>, is_state[<span class="Constant">'U'</span>] <span class="Type">==</span> <span class="Constant">0</span>] };
<span id="L434" class="LineNr"> 434 </span>  };
<span id="L435" class="LineNr"> 435 </span>  d.t_s <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(ts_proc2, d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>());
<span id="L436" class="LineNr"> 436 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-463">m2s_are_valid</a>() <span class="Type">==</span> <span class="Constant">false</span>, <span class="Constant">"Error: is incorrect."</span>);
<span id="L437" class="LineNr"> 437 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] m2s_are_valid false'</span>);
<span id="L438" class="LineNr"> 438 </span>
<span id="L439" class="LineNr"> 439 </span>  <span class="Comment Heading">// W-----U</span>
<span id="L440" class="LineNr"> 440 </span>  <span class="Identifier">ts_proc3</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(is_state) {
<span id="L441" class="LineNr"> 441 </span>    <span class="Statement">return</span> { [<span class="Constant">'P'</span>, <span class="Type">!</span>is_state[<span class="Constant">'I'</span>]], [<span class="Constant">'U'</span>, is_state[<span class="Constant">'I'</span>] <span class="Type">&amp;&amp;</span> is_state[<span class="Constant">'W'</span>]],
<span id="L442" class="LineNr"> 442 </span>             [<span class="Constant">'X'</span>, <span class="Type">!</span>is_state[<span class="Constant">'Y'</span>]],
<span id="L443" class="LineNr"> 443 </span>             [<span class="Constant">'Y'</span>, is_state[<span class="Constant">'P'</span>] <span class="Type">&amp;&amp;</span> is_state[<span class="Constant">'U'</span>]],
<span id="L444" class="LineNr"> 444 </span>             [<span class="Constant">'Z'</span>, is_state[<span class="Constant">'U'</span>] <span class="Type">==</span> <span class="Constant">0</span>] };
<span id="L445" class="LineNr"> 445 </span>  };
<span id="L446" class="LineNr"> 446 </span>  d.t_s <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(ts_proc2, d.<a class="Identifier code-proc-link" href="#da-1348">poss_is_states</a>());
<span id="L447" class="LineNr"> 447 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-463">m2s_are_valid</a>() <span class="Type">==</span> <span class="Constant">false</span>, <span class="Constant">"Error: is incorrect."</span>);
<span id="L448" class="LineNr"> 448 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] m2s_are_valid false 2'</span>);
<span id="L449" class="LineNr"> 449 </span>};
<span id="L450" class="LineNr"> 450 </span><span class="Identifier">test_m2s_are_valid</span>();
<span id="L451" class="LineNr"> 451 </span>
<span id="L452" class="LineNr"> 452 </span><span class="Comment">/*</span>
<span id="L453" class="LineNr"> 453 </span><span class="Comment">test_no_e_in_u := procedure() {</span>
<span id="L454" class="LineNr"> 454 </span><span class="Comment">  d := decision_algorithm.new();</span>
<span id="L455" class="LineNr"> 455 </span><span class="Comment">  assert(d.no_e_in_u() == ,</span>
<span id="L456" class="LineNr"> 456 </span><span class="Comment">         "Error: no_e_in_u is incorrect.");</span>
<span id="L457" class="LineNr"> 457 </span><span class="Comment">  print('[ok] no_e_in_u false');</span>
<span id="L458" class="LineNr"> 458 </span>
<span id="L459" class="LineNr"> 459 </span><span class="Comment">  assert(d.no_e_in_u() == ,</span>
<span id="L460" class="LineNr"> 460 </span><span class="Comment">         "Error: no_e_in_u is incorrect.");</span>
<span id="L461" class="LineNr"> 461 </span><span class="Comment">  print('[ok] no_e_in_u true');</span>
<span id="L462" class="LineNr"> 462 </span><span class="Comment">};</span>
<span id="L463" class="LineNr"> 463 </span><span class="Comment">test_no_e_in_u();</span>
<span id="L464" class="LineNr"> 464 </span><span class="Comment">*/</span>
<span id="L465" class="LineNr"> 465 </span>
<span id="L466" class="LineNr"> 466 </span><span class="Comment">/* test_i_ref := procedure() {</span>
<span id="L467" class="LineNr"> 467 </span><span class="Comment">  print(d1().i_ref(b2(), b2())); // out of memory</span>
<span id="L468" class="LineNr"> 468 </span><span class="Comment">//  assert(d1().i_ref(b1(), b1()) == </span>
<span id="L469" class="LineNr"> 469 </span><span class="Comment">//         "Error: i_ref is incorrect.");</span>
<span id="L470" class="LineNr"> 470 </span><span class="Comment">  print('[  ] i_ref');</span>
<span id="L471" class="LineNr"> 471 </span><span class="Comment">};</span>
<span id="L472" class="LineNr"> 472 </span><span class="Comment">test_i_ref();</span>
<span id="L473" class="LineNr"> 473 </span><span class="Comment">*/</span>
<span id="L474" class="LineNr"> 474 </span>
<span id="L475" class="LineNr"><a href="#da-568" data-file="decision_algorithm" title="str_exprs" class="back_to_proc">&#8629;</a> 475 </span><span class="Identifier">test_str_exprs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L476" class="LineNr"> 476 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L477" class="LineNr"> 477 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'P(I_1)'</span> };
<span id="L478" class="LineNr"> 478 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>], [<span class="Constant">'I_1'</span>, <span class="Constant">'P(I_1)'</span>],
<span id="L479" class="LineNr"> 479 </span>           [<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'P(A^B)'</span>],
<span id="L480" class="LineNr"> 480 </span>           [<span class="Identifier">BoxArrow</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'P(A[]-&gt;B)'</span>] };
<span id="L481" class="LineNr"> 481 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-568">str_exprs</a>() <span class="Type">==</span> { [<span class="Constant">'A'</span>,<span class="Constant">0</span>] , [<span class="Constant">'B'</span>,<span class="Constant">0</span>] },
<span id="L482" class="LineNr"> 482 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L483" class="LineNr"> 483 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] str_exprs'</span>);
<span id="L484" class="LineNr"> 484 </span>};
<span id="L485" class="LineNr"> 485 </span><span class="Identifier">test_str_exprs</span>();
<span id="L486" class="LineNr"> 486 </span>
<span id="L487" class="LineNr"><a href="#da-573" data-file="decision_algorithm" title="preds" class="back_to_proc">&#8629;</a> 487 </span><span class="Identifier">test_preds</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L488" class="LineNr"> 488 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L489" class="LineNr"> 489 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'P(I_1)'</span> };
<span id="L490" class="LineNr"> 490 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>], [<span class="Constant">'I_1'</span>, <span class="Constant">'P(I_1)'</span>],
<span id="L491" class="LineNr"> 491 </span>           [<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'P(A^B)'</span>], [<span class="Identifier">Q</span>(<span class="Constant">'A'</span>), <span class="Constant">'P(Q(A))'</span>],
<span id="L492" class="LineNr"> 492 </span>           [<span class="Identifier">R</span>(<span class="Constant">'A'</span>,<span class="Constant">'B'</span>), <span class="Constant">'P(R(A,B))'</span>],
<span id="L493" class="LineNr"> 493 </span>           [<span class="Identifier">BoxArrow</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'P(A[]-&gt;B)'</span>] };
<span id="L494" class="LineNr"> 494 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-573">preds</a>() <span class="Type">==</span> { [<span class="Constant">'Q'</span>, <span class="Constant">1</span>], [<span class="Constant">'R'</span>, <span class="Constant">2</span>] },
<span id="L495" class="LineNr"> 495 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L496" class="LineNr"> 496 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] preds arity'</span>);
<span id="L497" class="LineNr"> 497 </span>};
<span id="L498" class="LineNr"> 498 </span><span class="Identifier">test_preds</span>();
<span id="L499" class="LineNr"> 499 </span>
<span id="L500" class="LineNr"> 500 </span><span class="Identifier">w1</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L501" class="LineNr"> 501 </span>  w <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L502" class="LineNr"> 502 </span>  w.u <span class="Statement">:=</span> {};
<span id="L503" class="LineNr"> 503 </span>  w.v <span class="Statement">:=</span> { <span class="Constant">'X'</span>, <span class="Constant">'Y'</span> };
<span id="L504" class="LineNr"> 504 </span>  w.n <span class="Statement">:=</span> <span class="Constant">2</span>;
<span id="L505" class="LineNr"> 505 </span>  w.r <span class="Statement">:=</span> { [<span class="Constant">'X'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'Y'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L506" class="LineNr"> 506 </span>  w.f <span class="Statement">:=</span> { [<span class="Constant">'X'</span>, { [{[<span class="Constant">'X'</span>, <span class="Constant">false</span>], [<span class="Constant">'Y'</span>, <span class="Constant">false</span>]}, <span class="Constant">false</span>],
<span id="L507" class="LineNr"> 507 </span>                   [{[<span class="Constant">'X'</span>, <span class="Constant">false</span>], [<span class="Constant">'Y'</span>,  <span class="Constant">true</span>]},  <span class="Constant">true</span>],
<span id="L508" class="LineNr"> 508 </span>                   [{[<span class="Constant">'X'</span>,  <span class="Constant">true</span>], [<span class="Constant">'Y'</span>, <span class="Constant">false</span>]},  <span class="Constant">true</span>],
<span id="L509" class="LineNr"> 509 </span>                   [{[<span class="Constant">'X'</span>,  <span class="Constant">true</span>], [<span class="Constant">'Y'</span>,  <span class="Constant">true</span>]},  <span class="Constant">true</span>]
<span id="L510" class="LineNr"> 510 </span>                 }],
<span id="L511" class="LineNr"> 511 </span>           [<span class="Constant">'Y'</span>, { [{[<span class="Constant">'X'</span>, <span class="Constant">false</span>], [<span class="Constant">'Y'</span>, <span class="Constant">false</span>]},  <span class="Constant">true</span>],
<span id="L512" class="LineNr"> 512 </span>                   [{[<span class="Constant">'X'</span>, <span class="Constant">false</span>], [<span class="Constant">'Y'</span>,  <span class="Constant">true</span>]},  <span class="Constant">true</span>],
<span id="L513" class="LineNr"> 513 </span>                   [{[<span class="Constant">'X'</span>,  <span class="Constant">true</span>], [<span class="Constant">'Y'</span>, <span class="Constant">false</span>]},  <span class="Constant">true</span>],
<span id="L514" class="LineNr"> 514 </span>                   [{[<span class="Constant">'X'</span>,  <span class="Constant">true</span>], [<span class="Constant">'Y'</span>,  <span class="Constant">true</span>]}, <span class="Constant">false</span>]
<span id="L515" class="LineNr"> 515 </span>                 }]
<span id="L516" class="LineNr"> 516 </span>         };
<span id="L517" class="LineNr"> 517 </span>};
<span id="L518" class="LineNr"> 518 </span>
<span id="L519" class="LineNr"><a href="#da-580" data-file="decision_algorithm" title="poss_base_expr_refs" class="back_to_proc">&#8629;</a> 519 </span><span class="Identifier">test_poss_base_expr_refs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L520" class="LineNr"> 520 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L521" class="LineNr"> 521 </span>  w <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-500">w1</a>();
<span id="L522" class="LineNr"> 522 </span>  <span class="Comment">// print(d.poss_base_expr_refs(w, { ['A', 0] }));</span>
<span id="L523" class="LineNr"> 523 </span>  <span class="Comment">// print(d.poss_base_expr_refs(w, { ['A', 0], [Q('A'), 1], [R('A','B'), 2] }));</span>
<span id="L524" class="LineNr"> 524 </span>  <span class="Comment">// print(d.poss_base_expr_refs(w, { ['A', 0], [Q('A'), 1] }));</span>
<span id="L525" class="LineNr"> 525 </span>  <span class="Comment">// 2 ** 81 subsets</span>
<span id="L526" class="LineNr"> 526 </span>  <span class="Comment">// assert(d.poss_base_expr_refs(w, { 'A', Q('A'), R('A','B') }),</span>
<span id="L527" class="LineNr"> 527 </span>  <span class="Comment">//        "Error: is incorrect.");</span>
<span id="L528" class="LineNr"> 528 </span>  <span class="Comment">// print('[ok] poss_base_expr_refs');</span>
<span id="L529" class="LineNr"> 529 </span>};
<span id="L530" class="LineNr"> 530 </span><span class="Identifier">test_poss_base_expr_refs</span>();
<span id="L531" class="LineNr"> 531 </span>
<span id="L532" class="LineNr"> 532 </span><span class="Comment">/*</span>
<span id="L533" class="LineNr"> 533 </span><span class="Comment">test_poss_base_refs := procedure() {</span>
<span id="L534" class="LineNr"> 534 </span><span class="Comment">  d := decision_algorithm.new();</span>
<span id="L535" class="LineNr"> 535 </span><span class="Comment">  d.cached_lf := { };</span>
<span id="L536" class="LineNr"> 536 </span><span class="Comment">  w := w1();</span>
<span id="L537" class="LineNr"> 537 </span><span class="Comment">  w_sts := w1.cm().poss_states();</span>
<span id="L538" class="LineNr"> 538 </span><span class="Comment">  pbers := { </span>
<span id="L539" class="LineNr"> 539 </span><span class="Comment">    { ['A', { w_sts[1], w_sts[2] }],</span>
<span id="L540" class="LineNr"> 540 </span><span class="Comment">      ['Q', { [{ w_sts[1], w_sts[2] }], </span>
<span id="L541" class="LineNr"> 541 </span><span class="Comment">              [{ w_sts[4] }] }] },</span>
<span id="L542" class="LineNr"> 542 </span><span class="Comment">    { ['A', { w_sts[3], w_sts[4] }],</span>
<span id="L543" class="LineNr"> 543 </span><span class="Comment">      ['Q', { [{ w_sts[2], w_sts[3] }], </span>
<span id="L544" class="LineNr"> 544 </span><span class="Comment">              [{ w_sts[5] }] }] }</span>
<span id="L545" class="LineNr"> 545 </span><span class="Comment">  };  </span>
<span id="L546" class="LineNr"> 546 </span><span class="Comment">  // assert(d.poss_base_refs(w, b, pbers) == ,</span>
<span id="L547" class="LineNr"> 547 </span><span class="Comment">  //         "Error: poss_base_refs is incorrect.");</span>
<span id="L548" class="LineNr"> 548 </span><span class="Comment">  print('[ok] poss_base_refs');</span>
<span id="L549" class="LineNr"> 549 </span><span class="Comment">};</span>
<span id="L550" class="LineNr"> 550 </span><span class="Comment">// test_poss_base_refs();</span>
<span id="L551" class="LineNr"> 551 </span><span class="Comment">*/</span>
<span id="L552" class="LineNr"> 552 </span>
<span id="L553" class="LineNr"><a href="#da-626" data-file="decision_algorithm" title="rr" class="back_to_proc">&#8629;</a> 553 </span><span class="Identifier">test_rr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L554" class="LineNr"> 554 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L555" class="LineNr"> 555 </span>  b <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L556" class="LineNr"> 556 </span>  b.v <span class="Statement">:=</span> { <span class="Constant">'V_1'</span> };
<span id="L557" class="LineNr"> 557 </span>  b.r <span class="Statement">:=</span> { [<span class="Constant">'V_1'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L558" class="LineNr"> 558 </span>  b.f <span class="Statement">:=</span> {
<span id="L559" class="LineNr"> 559 </span>    [<span class="Constant">'V_1'</span>, { [{ [<span class="Constant">'V_1'</span>, <span class="Constant">false</span>] },  <span class="Constant">true</span>],
<span id="L560" class="LineNr"> 560 </span>              [{ [<span class="Constant">'V_1'</span>,  <span class="Constant">true</span>] }, <span class="Constant">false</span>]
<span id="L561" class="LineNr"> 561 </span>            }]
<span id="L562" class="LineNr"> 562 </span>  };
<span id="L563" class="LineNr"> 563 </span>  b.n <span class="Statement">:=</span> <span class="Constant">3</span>; <span class="Comment">// bug when set to 2?</span>
<span id="L564" class="LineNr"> 564 </span>  <span class="Comment">// rr(expr, [w, b, atom_ref, ti, context])</span>
<span id="L565" class="LineNr"> 565 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Constant">'A'</span>, [b, b, {}, <span class="Constant">1</span>, { [<span class="Constant">'A'</span>, { {[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]} }] }]) <span class="Type">==</span>
<span id="L566" class="LineNr"> 566 </span>                                         { {[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]} },
<span id="L567" class="LineNr"> 567 </span>         <span class="Constant">"Error: rr context is incorrect."</span>);
<span id="L568" class="LineNr"> 568 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr context'</span>);
<span id="L569" class="LineNr"> 569 </span>
<span id="L570" class="LineNr"> 570 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'P(I_1)'</span> };
<span id="L571" class="LineNr"> 571 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'I_1'</span>,<span class="Constant">'P(I_1)'</span>] };
<span id="L572" class="LineNr"> 572 </span>  b.a <span class="Statement">:=</span> [ {[<span class="Constant">'V_1_t1'</span>,  <span class="Constant">true</span>]},
<span id="L573" class="LineNr"> 573 </span>           {[<span class="Constant">'V_1_t2'</span>, <span class="Constant">false</span>]},
<span id="L574" class="LineNr"> 574 </span>           {[<span class="Constant">'V_1_t3'</span>,  <span class="Constant">true</span>]} ];
<span id="L575" class="LineNr"> 575 </span>  d.cached_lf <span class="Statement">:=</span> {
<span id="L576" class="LineNr"> 576 </span>    [ {[<span class="Constant">'V_1'</span>, <span class="Constant">false</span>]}, {[<span class="Constant">'P(I_1)'</span>, <span class="Constant">false</span>]} ],
<span id="L577" class="LineNr"> 577 </span>    [ {[<span class="Constant">'V_1'</span>,  <span class="Constant">true</span>]}, {[<span class="Constant">'P(I_1)'</span>,  <span class="Constant">true</span>]} ]
<span id="L578" class="LineNr"> 578 </span>  };
<span id="L579" class="LineNr"> 579 </span>  all_sts <span class="Statement">:=</span> b.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>();
<span id="L580" class="LineNr"> 580 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Constant">'I_1'</span>, [b, b, {}, <span class="Constant">1</span>, {}]) <span class="Type">==</span>
<span id="L581" class="LineNr"> 581 </span>           <span class="Identifier">compat_compl_sts</span>( {[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts ),
<span id="L582" class="LineNr"> 582 </span>         <span class="Constant">"Error: rr i is incorrect."</span>);
<span id="L583" class="LineNr"> 583 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr i'</span>);
<span id="L584" class="LineNr"> 584 </span>
<span id="L585" class="LineNr"> 585 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">At_t</span>(<span class="Constant">'I_1'</span>, <span class="Type">-</span><span class="Constant">1</span>), [b, b, {}, <span class="Constant">2</span>, {}]) <span class="Type">==</span>
<span id="L586" class="LineNr"> 586 </span>           <span class="Identifier">compat_compl_sts</span>( {[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts ),
<span id="L587" class="LineNr"> 587 </span>         <span class="Constant">"Error: rr At_t is incorrect."</span>);
<span id="L588" class="LineNr"> 588 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr At_t'</span>);
<span id="L589" class="LineNr"> 589 </span>
<span id="L590" class="LineNr"> 590 </span>  atom_ref <span class="Statement">:=</span> { [<span class="Constant">'B'</span>, <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>( {[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts )],
<span id="L591" class="LineNr"> 591 </span>                [<span class="Constant">'IsAorB'</span>, { [<a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts)],
<span id="L592" class="LineNr"> 592 </span>                             [<span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t2'</span>, <span class="Constant">true</span>]}, all_sts)] }]
<span id="L593" class="LineNr"> 593 </span>              };
<span id="L594" class="LineNr"> 594 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Constant">'B'</span>, [b, b, atom_ref, <span class="Constant">1</span>, {}]) <span class="Type">==</span>
<span id="L595" class="LineNr"> 595 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts) <span class="Type">&amp;&amp;</span>
<span id="L596" class="LineNr"> 596 </span>         d.<span class="Identifier">rr</span>(<span class="Constant">'IsAorB'</span>, [b, b, atom_ref, <span class="Constant">1</span>, {}]) <span class="Type">==</span> {
<span id="L597" class="LineNr"> 597 </span>           [<span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts)],
<span id="L598" class="LineNr"> 598 </span>           [<span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t2'</span>, <span class="Constant">true</span>]}, all_sts)]
<span id="L599" class="LineNr"> 599 </span>         },
<span id="L600" class="LineNr"> 600 </span>         <span class="Constant">"Error: rr atom_ref is incorrect."</span>);
<span id="L601" class="LineNr"> 601 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr atom_ref'</span>);
<span id="L602" class="LineNr"> 602 </span>
<span id="L603" class="LineNr"> 603 </span>  atom_ref <span class="Statement">:=</span> { [<span class="Constant">'C'</span>, <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>( {[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts )],
<span id="L604" class="LineNr"> 604 </span>                [<span class="Constant">'D'</span>, <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>( {[<span class="Constant">'V_1_t2'</span>, <span class="Constant">true</span>]}, all_sts )] };
<span id="L605" class="LineNr"> 605 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">And</span>(<span class="Constant">'C'</span>, <span class="Constant">'D'</span>), [b, b, atom_ref, <span class="Constant">1</span>, {}]) <span class="Type">==</span>
<span id="L606" class="LineNr"> 606 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>], [<span class="Constant">'V_1_t2'</span>, <span class="Constant">true</span>]}, all_sts),
<span id="L607" class="LineNr"> 607 </span>         <span class="Constant">"Error: rr And is incorrect"</span>);
<span id="L608" class="LineNr"> 608 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr And'</span>);
<span id="L609" class="LineNr"> 609 </span>
<span id="L610" class="LineNr"> 610 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">Or</span>(<span class="Constant">'C'</span>, <span class="Constant">'D'</span>), [b, b, atom_ref, <span class="Constant">1</span>, {}]) <span class="Type">==</span>
<span id="L611" class="LineNr"> 611 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">true</span>]}, all_sts) <span class="Type">+</span>
<span id="L612" class="LineNr"> 612 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t2'</span>, <span class="Constant">true</span>]}, all_sts),
<span id="L613" class="LineNr"> 613 </span>         <span class="Constant">"Error: rr Or is incorrect"</span>);
<span id="L614" class="LineNr"> 614 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr Or'</span>);
<span id="L615" class="LineNr"> 615 </span>
<span id="L616" class="LineNr"> 616 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">Not</span>(<span class="Constant">'C'</span>), [b, b, atom_ref, <span class="Constant">1</span>, {}]) <span class="Type">==</span>
<span id="L617" class="LineNr"> 617 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">false</span>]}, all_sts),
<span id="L618" class="LineNr"> 618 </span>         <span class="Constant">"Error: rr Not is incorrect"</span>);
<span id="L619" class="LineNr"> 619 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr Not'</span>);
<span id="L620" class="LineNr"> 620 </span>
<span id="L621" class="LineNr"> 621 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-626">rr</a>(<span class="Identifier">Implies</span>(<span class="Constant">'C'</span>, <span class="Constant">'D'</span>), [b, b, atom_ref, <span class="Constant">1</span>, {}]) <span class="Type">==</span>
<span id="L622" class="LineNr"> 622 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t1'</span>, <span class="Constant">false</span>]}, all_sts) <span class="Type">+</span>
<span id="L623" class="LineNr"> 623 </span>           <span class="Identifier">compat_compl_sts</span>({[<span class="Constant">'V_1_t2'</span>, <span class="Constant">true</span>]}, all_sts),
<span id="L624" class="LineNr"> 624 </span>         <span class="Constant">"Error: rr Implies is incorrect"</span>);
<span id="L625" class="LineNr"> 625 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] rr Implies'</span>);
<span id="L626" class="LineNr"> 626 </span>
<span id="L627" class="LineNr"> 627 </span>  <span class="Identifier">print</span>(<span class="Constant">'[  ] rr'</span>);
<span id="L628" class="LineNr"> 628 </span>};
<span id="L629" class="LineNr"> 629 </span><span class="Identifier">test_rr</span>();
<span id="L630" class="LineNr"> 630 </span>
<span id="L631" class="LineNr"><a href="#da-732" data-file="decision_algorithm" title="true_p" class="back_to_proc">&#8629;</a> 631 </span><span class="Identifier">test_true_p</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L632" class="LineNr"> 632 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L633" class="LineNr"> 633 </span>  b_event <span class="Statement">:=</span> {[<span class="Constant">'V'</span>, <span class="Constant">true</span>]};
<span id="L634" class="LineNr"> 634 </span>  ref_i <span class="Statement">:=</span> { [ b_event, { {[<span class="Constant">'X'</span>, <span class="Constant">true</span>]}, {[<span class="Constant">'Y'</span>, <span class="Constant">true</span>]} }] };
<span id="L635" class="LineNr"> 635 </span>  w <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L636" class="LineNr"> 636 </span>  <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">: rewrite to use states rather than events</span>
<span id="L637" class="LineNr"> 637 </span><span class="Comment">// or just fold into sq_err</span>
<span id="L638" class="LineNr"> 638 </span>  w.a <span class="Statement">:=</span> [{ [<span class="Constant">'Y'</span>, <span class="Constant">true</span>] }];
<span id="L639" class="LineNr"> 639 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-732">true_p</a>(w, ref_i, b_event) <span class="Type">==</span> <span class="Constant">1</span>, <span class="Constant">"Error: true_p true is incorrect."</span>);
<span id="L640" class="LineNr"> 640 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] true_p true'</span>);
<span id="L641" class="LineNr"> 641 </span>
<span id="L642" class="LineNr"> 642 </span>  w.a <span class="Statement">:=</span> [{ [<span class="Constant">'X'</span>, <span class="Constant">true</span>] }];
<span id="L643" class="LineNr"> 643 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-732">true_p</a>(w, ref_i, b_event) <span class="Type">==</span> <span class="Constant">1</span>, <span class="Constant">"Error: true_p true is incorrect."</span>);
<span id="L644" class="LineNr"> 644 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] true_p true 2'</span>);
<span id="L645" class="LineNr"> 645 </span>
<span id="L646" class="LineNr"> 646 </span>  w.a <span class="Statement">:=</span> [{ [<span class="Constant">'X'</span>, <span class="Constant">false</span>] }];
<span id="L647" class="LineNr"> 647 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-732">true_p</a>(w, ref_i, b_event) <span class="Type">==</span> <span class="Constant">0</span>, <span class="Constant">"Error: true_p false is incorrect."</span>);
<span id="L648" class="LineNr"> 648 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] true_p false'</span>);
<span id="L649" class="LineNr"> 649 </span>};
<span id="L650" class="LineNr"> 650 </span><span class="Comment">//test_true_p();</span>
<span id="L651" class="LineNr"> 651 </span>
<span id="L652" class="LineNr"><a href="#da-725" data-file="decision_algorithm" title="sq_err" class="back_to_proc">&#8629;</a> 652 </span><span class="Identifier">test_sq_err</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L653" class="LineNr"> 653 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L654" class="LineNr"> 654 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>] };
<span id="L655" class="LineNr"> 655 </span>  d.cached_lf <span class="Statement">:=</span> { [ {[<span class="Constant">'V'</span>,  <span class="Constant">true</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.75</span>]} ],
<span id="L656" class="LineNr"> 656 </span>                   [ {[<span class="Constant">'V'</span>, <span class="Constant">false</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.33</span>]} ] };
<span id="L657" class="LineNr"> 657 </span>  b <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L658" class="LineNr"> 658 </span>  b.a <span class="Statement">:=</span> [{[<span class="Constant">'V_t1'</span>, <span class="Constant">true</span>]}, {[<span class="Constant">'V_t2'</span>, <span class="Constant">false</span>]}];
<span id="L659" class="LineNr"> 659 </span>  ref_i <span class="Statement">:=</span> { [{[<span class="Constant">'V_t1'</span>,  <span class="Constant">true</span>]}, { {[<span class="Constant">'V_t1'</span>, <span class="Constant">true</span>], [<span class="Constant">'V_t2'</span>, <span class="Constant">false</span>]},
<span id="L660" class="LineNr"> 660 </span>                                   {[<span class="Constant">'V_t1'</span>, <span class="Constant">true</span>], [<span class="Constant">'V_t2'</span>,  <span class="Constant">true</span>]} }],
<span id="L661" class="LineNr"> 661 </span>             [{[<span class="Constant">'V_t2'</span>, <span class="Constant">false</span>]}, { {[<span class="Constant">'V_t1'</span>, <span class="Constant">true</span>], [<span class="Constant">'V_t2'</span>, <span class="Constant">false</span>]},
<span id="L662" class="LineNr"> 662 </span>                                   {[<span class="Constant">'V_t1'</span>, <span class="Constant">true</span>], [<span class="Constant">'V_t2'</span>,  <span class="Constant">true</span>]} }] };
<span id="L663" class="LineNr"> 663 </span>  <span class="Statement">assert</span>(<span class="Identifier">abs</span>(d.<a class="Identifier code-proc-link" href="#da-725">sq_err</a>(b, b, ref_i) <span class="Type">-</span> <span class="Constant">0.5114</span>) <span class="Type">&lt;</span> <span class="Constant">0.01</span>,
<span id="L664" class="LineNr"> 664 </span>         <span class="Constant">"Error: sq_err is incorrect."</span>);
<span id="L665" class="LineNr"> 665 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] true_p'</span>);
<span id="L666" class="LineNr"> 666 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] sq_err'</span>);
<span id="L667" class="LineNr"> 667 </span>};
<span id="L668" class="LineNr"> 668 </span><span class="Identifier">test_sq_err</span>();
<span id="L669" class="LineNr"> 669 </span><span class="Identifier">test_true_p</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-652">test_sq_err</a>(); };
<span id="L670" class="LineNr"> 670 </span>
<span id="L671" class="LineNr"> 671 </span><span class="Identifier">b2</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L672" class="LineNr"> 672 </span>  b <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-211">b1</a>();
<span id="L673" class="LineNr"> 673 </span>  b.n <span class="Statement">:=</span> <span class="Constant">2</span>;
<span id="L674" class="LineNr"> 674 </span>  b.a <span class="Statement">:=</span> [
<span id="L675" class="LineNr"> 675 </span>    { [<span class="Constant">'U_t1'</span>, <span class="Constant">1</span>], [<span class="Constant">'V_P1_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'O_t1'</span>,  <span class="Constant">true</span>] },
<span id="L676" class="LineNr"> 676 </span>    { [<span class="Constant">'U_t2'</span>, <span class="Constant">2</span>], [<span class="Constant">'V_P1_t2'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_P2_t2'</span>, <span class="Constant">false</span>], [<span class="Constant">'O_t2'</span>, <span class="Constant">false</span>] }
<span id="L677" class="LineNr"> 677 </span>  ];
<span id="L678" class="LineNr"> 678 </span>  <span class="Statement">return</span> b;
<span id="L679" class="LineNr"> 679 </span>};
<span id="L680" class="LineNr"> 680 </span>
<span id="L681" class="LineNr"><a href="#da-741" data-file="decision_algorithm" title="ref_expr" class="back_to_proc">&#8629;</a> 681 </span><span class="Identifier">test_ref_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L682" class="LineNr"> 682 </span>  d <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-316">d2</a>();
<span id="L683" class="LineNr"> 683 </span>  b <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-671">b2</a>();
<span id="L684" class="LineNr"> 684 </span>  bs1 <span class="Statement">:=</span> {{[<span class="Constant">'U'</span>, <span class="Constant">1</span>], [<span class="Constant">'V_P1_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'O'</span>, <span class="Constant">false</span>]}};
<span id="L685" class="LineNr"> 685 </span>  d.cached_ref <span class="Statement">:=</span> {
<span id="L686" class="LineNr"> 686 </span>    [ {[<span class="Constant">'V_P1_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2_t1'</span>, <span class="Constant">false</span>]}, bs1 ]
<span id="L687" class="LineNr"> 687 </span>  };
<span id="L688" class="LineNr"> 688 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-741">ref_expr</a>(b, b, <span class="Constant">1</span>, <span class="Constant">'A'</span>) <span class="Type">==</span> bs1,
<span id="L689" class="LineNr"> 689 </span>         <span class="Constant">"Error: ref_expr is incorrect."</span>);
<span id="L690" class="LineNr"> 690 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] ref_expr'</span>);
<span id="L691" class="LineNr"> 691 </span>};
<span id="L692" class="LineNr"> 692 </span><span class="Identifier">test_ref_expr</span>();
<span id="L693" class="LineNr"> 693 </span>
<span id="L694" class="LineNr"><a href="#da-750" data-file="decision_algorithm" title="actual_p_events" class="back_to_proc">&#8629;</a> 694 </span><span class="Identifier">test_actual_p_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L695" class="LineNr"> 695 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-750">actual_p_events</a>(<a class="Identifier code-proc-link" href="#tda-671">b2</a>()) <span class="Type">==</span> {
<span id="L696" class="LineNr"> 696 </span>           { [<span class="Constant">'V_P1_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_P2_t1'</span>, <span class="Constant">false</span>] },
<span id="L697" class="LineNr"> 697 </span>           { [<span class="Constant">'V_P1_t2'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_P2_t2'</span>, <span class="Constant">false</span>] }
<span id="L698" class="LineNr"> 698 </span>         },
<span id="L699" class="LineNr"> 699 </span>         <span class="Constant">"Error: actual_p_events is incorrect."</span>);
<span id="L700" class="LineNr"> 700 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] actual_p_events'</span>);
<span id="L701" class="LineNr"> 701 </span>};
<span id="L702" class="LineNr"> 702 </span><span class="Identifier">test_actual_p_events</span>();
<span id="L703" class="LineNr"> 703 </span>
<span id="L704" class="LineNr"><a href="#da-764" data-file="decision_algorithm" title="prob_states" class="back_to_proc">&#8629;</a> 704 </span><span class="Identifier">test_prob_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L705" class="LineNr"> 705 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-316">d2</a>().<a class="Identifier code-proc-link" href="#da-764">prob_states</a>(<a class="Identifier code-proc-link" href="#tda-671">b2</a>()) <span class="Type">==</span> { [<span class="Constant">1</span>, {[<span class="Constant">'P'</span>, <span class="Constant">1</span>]}], [<span class="Constant">2</span>, {[<span class="Constant">'P'</span>, <span class="Constant">0</span>]}] },
<span id="L706" class="LineNr"> 706 </span>         <span class="Constant">"Error: prob_states is incorrect."</span>);
<span id="L707" class="LineNr"> 707 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] prob_states'</span>);
<span id="L708" class="LineNr"> 708 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] prob_states_t'</span>);
<span id="L709" class="LineNr"> 709 </span>};
<span id="L710" class="LineNr"> 710 </span><span class="Identifier">test_prob_states</span>();
<span id="L711" class="LineNr"><a href="#da-772" data-file="decision_algorithm" title="prob_states_t" class="back_to_proc">&#8629;</a> 711 </span><span class="Identifier">test_prob_states_t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-704">test_prob_states</a>(); };
<span id="L712" class="LineNr"> 712 </span>
<span id="L713" class="LineNr"> 713 </span><span class="Identifier">d3</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L714" class="LineNr"> 714 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L715" class="LineNr"> 715 </span>  d.u <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'U(A)'</span>] };
<span id="L716" class="LineNr"> 716 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L717" class="LineNr"> 717 </span>  d.n <span class="Statement">:=</span> [{ [<span class="Constant">'e'</span>, {[<span class="Constant">'B'</span>,<span class="Constant">'E1(B)'</span>]}], [<span class="Constant">'m2'</span>,{<span class="Constant">'M2_1'</span>}], [<span class="Constant">'o'</span>,{<span class="Constant">'O_1'</span>}] },
<span id="L718" class="LineNr"> 718 </span>          { [<span class="Constant">'e'</span>, {[<span class="Constant">'C'</span>,<span class="Constant">'E2(C)'</span>]}], [<span class="Constant">'m2'</span>,{<span class="Constant">'M2_2'</span>}], [<span class="Constant">'o'</span>,{<span class="Constant">'O_2'</span>}] }];
<span id="L719" class="LineNr"> 719 </span>  <span class="Statement">return</span> d;
<span id="L720" class="LineNr"> 720 </span>};
<span id="L721" class="LineNr"> 721 </span>
<span id="L722" class="LineNr"><a href="#da-783" data-file="decision_algorithm" title="eo" class="back_to_proc">&#8629;</a> 722 </span><span class="Identifier">test_eo</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L723" class="LineNr"> 723 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tda-713">d3</a>().<a class="Identifier code-proc-link" href="#da-783">eo</a>() <span class="Type">==</span> { [{ [<span class="Constant">'A'</span>,  <span class="Constant">'U(A)'</span>] }, { <span class="Constant">'O'</span> }],
<span id="L724" class="LineNr"> 724 </span>                        [{ [<span class="Constant">'B'</span>, <span class="Constant">'E1(B)'</span>] }, {<span class="Constant">'O_1'</span>}],
<span id="L725" class="LineNr"> 725 </span>                        [{ [<span class="Constant">'C'</span>, <span class="Constant">'E2(C)'</span>] }, {<span class="Constant">'O_2'</span>}] },
<span id="L726" class="LineNr"> 726 </span>         <span class="Constant">"Error: eo is incorrect."</span>);
<span id="L727" class="LineNr"> 727 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] eo'</span>);
<span id="L728" class="LineNr"> 728 </span>};
<span id="L729" class="LineNr"> 729 </span><span class="Identifier">test_eo</span>();
<span id="L730" class="LineNr"> 730 </span>
<span id="L731" class="LineNr"><a href="#da-789" data-file="decision_algorithm" title="instr_irrat" class="back_to_proc">&#8629;</a> 731 </span><span class="Identifier">test_instr_irrat</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L732" class="LineNr"> 732 </span>  <span class="Identifier">print</span>(<span class="Constant">'test instr irrat'</span>);
<span id="L733" class="LineNr"> 733 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L734" class="LineNr"> 734 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L735" class="LineNr"> 735 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>],
<span id="L736" class="LineNr"> 736 </span>           [<span class="Identifier">Not</span>(<span class="Constant">'A'</span>), <span class="Constant">'P(~A)'</span>],
<span id="L737" class="LineNr"> 737 </span>           [<span class="Identifier">BoxArrow</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'P(A []-&gt; B)'</span>],
<span id="L738" class="LineNr"> 738 </span>           [<span class="Identifier">BoxArrow</span>(<span class="Identifier">Not</span>(<span class="Constant">'A'</span>), <span class="Constant">'B'</span>), <span class="Constant">'P(~A []-&gt; B)'</span>] };
<span id="L739" class="LineNr"> 739 </span>  d.u <span class="Statement">:=</span> { [<span class="Constant">'B'</span>, <span class="Constant">'U(B)'</span>] };
<span id="L740" class="LineNr"> 740 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, {<span class="Constant">0.3</span>, <span class="Constant">0.7</span>}],
<span id="L741" class="LineNr"> 741 </span>           [<span class="Constant">'P(~A)'</span>, {<span class="Constant">0.1</span>, <span class="Constant">0.9</span>}],
<span id="L742" class="LineNr"> 742 </span>           [<span class="Constant">'P(A []-&gt; B)'</span>, {<span class="Constant">0.2</span>, <span class="Constant">0.8</span>}],
<span id="L743" class="LineNr"> 743 </span>           [<span class="Constant">'P(~A []-&gt; B)'</span>, {<span class="Constant">0.25</span>, <span class="Constant">0.75</span>}],
<span id="L744" class="LineNr"> 744 </span>           [<span class="Constant">'U(B)'</span>, { <span class="Constant">5</span> }], [<span class="Constant">'O'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L745" class="LineNr"> 745 </span>  b <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L746" class="LineNr"> 746 </span>  b.u <span class="Statement">:=</span> {};
<span id="L747" class="LineNr"> 747 </span>  b.v <span class="Statement">:=</span> { <span class="Constant">'V_A'</span>, <span class="Constant">'V_~A'</span>, <span class="Constant">'V_A_[]-&gt;_B'</span>, <span class="Constant">'V_~A_[]-&gt;_B'</span>, <span class="Constant">'V_O'</span>, <span class="Constant">'V_U'</span> };
<span id="L748" class="LineNr"> 748 </span>  b.r <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> b.v };
<span id="L749" class="LineNr"> 749 </span>  false_func <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-377">proc2func</a>(<span class="Type">procedure</span>(bs) { <span class="Statement">return</span> <span class="Constant">false</span>; }, b.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>());
<span id="L750" class="LineNr"> 750 </span>  <span class="Identifier">print</span>(<span class="Constant">'false func'</span>);
<span id="L751" class="LineNr"> 751 </span>  b.f <span class="Statement">:=</span> {
<span id="L752" class="LineNr"> 752 </span>    [<span class="Constant">'V_A'</span>, false_func],
<span id="L753" class="LineNr"> 753 </span>    [<span class="Constant">'V_~A'</span>, false_func],
<span id="L754" class="LineNr"> 754 </span>    [<span class="Constant">'V_A_[]-&gt;_B'</span>, false_func],
<span id="L755" class="LineNr"> 755 </span>    [<span class="Constant">'V_~A_[]-&gt;_B'</span>, false_func],
<span id="L756" class="LineNr"> 756 </span>    [<span class="Constant">'V_O'</span>, false_func],
<span id="L757" class="LineNr"> 757 </span>    [<span class="Constant">'V_U'</span>, false_func]
<span id="L758" class="LineNr"> 758 </span>  };
<span id="L759" class="LineNr"> 759 </span>  b.n <span class="Statement">:=</span> <span class="Constant">3</span>;
<span id="L760" class="LineNr"> 760 </span>  b.a <span class="Statement">:=</span> [
<span id="L761" class="LineNr"> 761 </span>    { [<span class="Constant">'V_A_t1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_~A_t1'</span>, <span class="Constant">false</span>],
<span id="L762" class="LineNr"> 762 </span>      [<span class="Constant">'V_~A_[]-&gt;_B_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_~A_[]-&gt;_B_t1'</span>, <span class="Constant">true</span>],
<span id="L763" class="LineNr"> 763 </span>      [<span class="Constant">'V_O_t1'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_U_t1'</span>, <span class="Constant">false</span>] },
<span id="L764" class="LineNr"> 764 </span>    { [<span class="Constant">'V_A_t2'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_~A_t2'</span>, <span class="Constant">false</span>],
<span id="L765" class="LineNr"> 765 </span>      [<span class="Constant">'V_~A_[]-&gt;_B_t2'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_~A_[]-&gt;_B_t2'</span>, <span class="Constant">true</span>],
<span id="L766" class="LineNr"> 766 </span>      [<span class="Constant">'V_O_t2'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_U_t2'</span>, <span class="Constant">false</span>] },
<span id="L767" class="LineNr"> 767 </span>    { [<span class="Constant">'V_A_t3'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_~A_t3'</span>, <span class="Constant">false</span>],
<span id="L768" class="LineNr"> 768 </span>      [<span class="Constant">'V_~A_[]-&gt;_B_t3'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_~A_[]-&gt;_B_t3'</span>, <span class="Constant">true</span>],
<span id="L769" class="LineNr"> 769 </span>      [<span class="Constant">'V_O_t3'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_U_t3'</span>, <span class="Constant">false</span>] }
<span id="L770" class="LineNr"> 770 </span>  ];
<span id="L771" class="LineNr"> 771 </span>  d.cached_lf <span class="Statement">:=</span> {
<span id="L772" class="LineNr"> 772 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">false</span>]},         {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.3</span>]}        ],
<span id="L773" class="LineNr"> 773 </span>    [{[<span class="Constant">'V_A'</span>,  <span class="Constant">true</span>]},         {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.7</span>]}        ],
<span id="L774" class="LineNr"> 774 </span>    [{[<span class="Constant">'V_~A'</span>, <span class="Constant">false</span>]},        {[<span class="Constant">'P(~A)'</span>, <span class="Constant">0.1</span>]}       ],
<span id="L775" class="LineNr"> 775 </span>    [{[<span class="Constant">'V_~A'</span>,  <span class="Constant">true</span>]},        {[<span class="Constant">'P(~A)'</span>, <span class="Constant">0.9</span>]}       ],
<span id="L776" class="LineNr"> 776 </span>    [{[<span class="Constant">'V_A_[]-&gt;_B'</span>, <span class="Constant">false</span>]},  {[<span class="Constant">'P(A []-&gt; B)'</span>, <span class="Constant">0.2</span>]} ],
<span id="L777" class="LineNr"> 777 </span>    [{[<span class="Constant">'V_A_[]-&gt;_B'</span>,  <span class="Constant">true</span>]},  {[<span class="Constant">'P(A []-&gt; B)'</span>, <span class="Constant">0.8</span>]} ],
<span id="L778" class="LineNr"> 778 </span>    [{[<span class="Constant">'V_~A_[]-&gt;_B'</span>, <span class="Constant">false</span>]}, {[<span class="Constant">'P(~A []-&gt; B)'</span>, <span class="Constant">0.2</span>]}],
<span id="L779" class="LineNr"> 779 </span>    [{[<span class="Constant">'V_~A_[]-&gt;_B'</span>,  <span class="Constant">true</span>]}, {[<span class="Constant">'P(~A []-&gt; B)'</span>, <span class="Constant">0.8</span>]}],
<span id="L780" class="LineNr"> 780 </span>    [{[<span class="Constant">'V_O'</span>, <span class="Constant">false</span>]},         {[<span class="Constant">'O'</span>, <span class="Constant">false</span>]}         ],
<span id="L781" class="LineNr"> 781 </span>    [{[<span class="Constant">'V_O'</span>,  <span class="Constant">true</span>]},         {[<span class="Constant">'O'</span>,  <span class="Constant">true</span>]}         ],
<span id="L782" class="LineNr"> 782 </span>    [{[<span class="Constant">'V_U'</span>, <span class="Constant">false</span>]},         {[<span class="Constant">'U(B)'</span>, <span class="Constant">false</span>]}      ],
<span id="L783" class="LineNr"> 783 </span>    [{[<span class="Constant">'V_U'</span>,  <span class="Constant">true</span>]},         {[<span class="Constant">'U(B)'</span>,  <span class="Constant">true</span>]}      ]
<span id="L784" class="LineNr"> 784 </span>  };
<span id="L785" class="LineNr"> 785 </span>  <span class="Identifier">print</span>(<span class="Constant">'cached lf'</span>);
<span id="L786" class="LineNr"> 786 </span>  d.cached_f <span class="Statement">:=</span> d.<a class="Identifier code-proc-link" href="#da-439">plf_to_pf</a>(b, d.cached_lf);
<span id="L787" class="LineNr"> 787 </span>  <span class="Identifier">print</span>(<span class="Constant">'cached f'</span>);
<span id="L788" class="LineNr"> 788 </span>  b_cm <span class="Statement">:=</span> b.<a class="Identifier code-proc-link" href="#cmm-38">cm</a>();
<span id="L789" class="LineNr"> 789 </span>  <span class="Identifier">print</span>(<span class="Constant">'b cm'</span>);
<span id="L790" class="LineNr"> 790 </span>  b_cm_poss_states <span class="Statement">:=</span> b_cm.<a class="Identifier code-proc-link" href="#da-289">poss_states</a>();
<span id="L791" class="LineNr"> 791 </span>  <span class="Identifier">print</span>(<span class="Type">#</span>b_cm_poss_states);
<span id="L792" class="LineNr"> 792 </span>  o_t2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>({[<span class="Constant">'V_O_t2'</span>, <span class="Constant">true</span>]}, b_cm_poss_states);
<span id="L793" class="LineNr"> 793 </span>  <span class="Identifier">print</span>(<span class="Constant">'o_t2'</span>);
<span id="L794" class="LineNr"> 794 </span>  o_t3 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>({[<span class="Constant">'V_O_t3'</span>, <span class="Constant">true</span>]}, b_cm_poss_states);
<span id="L795" class="LineNr"> 795 </span>  no_t2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>({[<span class="Constant">'V_O_t2'</span>, <span class="Constant">false</span>]}, b_cm_poss_states);
<span id="L796" class="LineNr"> 796 </span>  no_t3 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-356">compat_compl_sts</a>({[<span class="Constant">'V_O_t3'</span>, <span class="Constant">false</span>]}, b_cm_poss_states);
<span id="L797" class="LineNr"> 797 </span>  <span class="Identifier">print</span>(<span class="Constant">'no_t3'</span>);
<span id="L798" class="LineNr"> 798 </span>  d.cached_ref <span class="Statement">:=</span> {
<span id="L799" class="LineNr"> 799 </span>    [{[<span class="Constant">'V_A_t1'</span>, <span class="Constant">true</span> ]}, o_t2],
<span id="L800" class="LineNr"> 800 </span>    [{[<span class="Constant">'V_A_t1'</span>, <span class="Constant">false</span>]}, o_t2],
<span id="L801" class="LineNr"> 801 </span>
<span id="L802" class="LineNr"> 802 </span>    [{[<span class="Constant">'V_~A_t1'</span>, <span class="Constant">true</span> ]}, no_t2],
<span id="L803" class="LineNr"> 803 </span>    [{[<span class="Constant">'V_~A_t1'</span>, <span class="Constant">false</span>]}, no_t2],
<span id="L804" class="LineNr"> 804 </span>
<span id="L805" class="LineNr"> 805 </span>    [{[<span class="Constant">'V_A_t2'</span>, <span class="Constant">true</span> ]}, o_t3],
<span id="L806" class="LineNr"> 806 </span>    [{[<span class="Constant">'V_A_t2'</span>, <span class="Constant">false</span>]}, o_t3],
<span id="L807" class="LineNr"> 807 </span>
<span id="L808" class="LineNr"> 808 </span>    [{[<span class="Constant">'V_~A_t2'</span>, <span class="Constant">true</span> ]}, no_t3],
<span id="L809" class="LineNr"> 809 </span>    [{[<span class="Constant">'V_~A_t2'</span>, <span class="Constant">false</span>]}, no_t3]
<span id="L810" class="LineNr"> 810 </span>
<span id="L811" class="LineNr"> 811 </span>  };
<span id="L812" class="LineNr"> 812 </span>  <span class="Comment">// print(d.instr_irrat(b, b));</span>
<span id="L813" class="LineNr"> 813 </span>  <span class="Comment">// assert(d.instr_irrat() == ,</span>
<span id="L814" class="LineNr"> 814 </span>  <span class="Comment">//       "Error: instr_irrat is incorrect.");</span>
<span id="L815" class="LineNr"> 815 </span>  <span class="Identifier">print</span>(<span class="Constant">'[.?] instr_irrat'</span>);
<span id="L816" class="LineNr"> 816 </span>};
<span id="L817" class="LineNr"> 817 </span><span class="Comment">// test_instr_irrat();</span>
<span id="L818" class="LineNr"> 818 </span>
<span id="L819" class="LineNr"><a href="#da-883" data-file="decision_algorithm" title="max_p_dist" class="back_to_proc">&#8629;</a> 819 </span><span class="Identifier">test_max_p_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L820" class="LineNr"> 820 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L821" class="LineNr"> 821 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>] };
<span id="L822" class="LineNr"> 822 </span>  thirds <span class="Statement">:=</span> { <span class="Constant">0</span>, <span class="Constant">0.33</span>, <span class="Constant">0.66</span>, <span class="Constant">1</span> };
<span id="L823" class="LineNr"> 823 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, thirds], [<span class="Constant">'P(B)'</span>, thirds] };
<span id="L824" class="LineNr"> 824 </span>  b <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L825" class="LineNr"> 825 </span>  b.v <span class="Statement">:=</span> { <span class="Constant">'V_A'</span>, <span class="Constant">'V_B'</span> };
<span id="L826" class="LineNr"> 826 </span>  four <span class="Statement">:=</span> { <span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span>,<span class="Constant">4</span> };
<span id="L827" class="LineNr"> 827 </span>  b.r <span class="Statement">:=</span> { [<span class="Constant">'V_A'</span>, four], [<span class="Constant">'V_B'</span>, four] };
<span id="L828" class="LineNr"> 828 </span>  d.cached_f <span class="Statement">:=</span> {
<span id="L829" class="LineNr"> 829 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">1</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">0</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">0</span>]}],
<span id="L830" class="LineNr"> 830 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">1</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">2</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">0</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.33</span>]}],
<span id="L831" class="LineNr"> 831 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">1</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">3</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">0</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.66</span>]}],
<span id="L832" class="LineNr"> 832 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">1</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">4</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">0</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">1</span>]}],
<span id="L833" class="LineNr"> 833 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">2</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.33</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">0</span>]}],
<span id="L834" class="LineNr"> 834 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">2</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">2</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.33</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.33</span>]}],
<span id="L835" class="LineNr"> 835 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">2</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">3</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.33</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.66</span>]}],
<span id="L836" class="LineNr"> 836 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">2</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">4</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.33</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">1</span>]}],
<span id="L837" class="LineNr"> 837 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">3</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.66</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">0</span>]}],
<span id="L838" class="LineNr"> 838 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">3</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">2</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.66</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.33</span>]}],
<span id="L839" class="LineNr"> 839 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">3</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">3</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.66</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.66</span>]}],
<span id="L840" class="LineNr"> 840 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">3</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">4</span>]}, {[<span class="Constant">'P(A)'</span>, <span class="Constant">0.66</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">1</span>]}],
<span id="L841" class="LineNr"> 841 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">4</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">1</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">1</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">0</span>]}],
<span id="L842" class="LineNr"> 842 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">4</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">2</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">1</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.33</span>]}],
<span id="L843" class="LineNr"> 843 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">4</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">3</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">1</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.66</span>]}],
<span id="L844" class="LineNr"> 844 </span>    [{[<span class="Constant">'V_A'</span>, <span class="Constant">4</span>], [<span class="Constant">'V_B'</span>, <span class="Constant">4</span>]}, {[<span class="Constant">'P(A)'</span>,    <span class="Constant">1</span>], [<span class="Constant">'P(B)'</span>,    <span class="Constant">1</span>]}]
<span id="L845" class="LineNr"> 845 </span>  };
<span id="L846" class="LineNr"> 846 </span>  b.a <span class="Statement">:=</span> [{[<span class="Constant">'V_A_t1'</span>, <span class="Constant">2</span>], [<span class="Constant">'V_B_t1'</span>, <span class="Constant">3</span>]}];
<span id="L847" class="LineNr"> 847 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-883">max_p_dist</a>(b, <span class="Constant">1</span>) <span class="Type">==</span> <span class="Constant">1.33</span>,
<span id="L848" class="LineNr"> 848 </span>         <span class="Constant">"Error: max_p_dist is incorrect."</span>);
<span id="L849" class="LineNr"> 849 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] max_p_dist'</span>);
<span id="L850" class="LineNr"> 850 </span>};
<span id="L851" class="LineNr"> 851 </span><span class="Identifier">test_max_p_dist</span>();
<span id="L852" class="LineNr"> 852 </span>
<span id="L853" class="LineNr"><a href="#da-895" data-file="decision_algorithm" title="poss_cms" class="back_to_proc">&#8629;</a> 853 </span><span class="Identifier">test_poss_cms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L854" class="LineNr"> 854 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L855" class="LineNr"> 855 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>], [<span class="Constant">'C'</span>, <span class="Constant">'P(C)'</span>] };
<span id="L856" class="LineNr"> 856 </span>  d.r <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> <span class="Identifier">range</span>(d.p) };
<span id="L857" class="LineNr"> 857 </span>  <span class="Statement">assert</span>(<span class="Type">exists</span>(cm <span class="Type">in</span> d.<a class="Identifier code-proc-link" href="#da-895">poss_cms</a>() <span class="Type">|</span>
<span id="L858" class="LineNr"> 858 </span>           cm.f <span class="Type">==</span> {
<span id="L859" class="LineNr"> 859 </span>             [<span class="Constant">"P(A)"</span>, { [{[<span class="Constant">"P(B)"</span>, <span class="Constant">false</span>]},  <span class="Constant">true</span>],
<span id="L860" class="LineNr"> 860 </span>                        [{[<span class="Constant">"P(B)"</span>,  <span class="Constant">true</span>]}, <span class="Constant">false</span>] }],
<span id="L861" class="LineNr"> 861 </span>             [<span class="Constant">"P(B)"</span>, { [{[<span class="Constant">"P(C)"</span>, <span class="Constant">false</span>]}, <span class="Constant">false</span>],
<span id="L862" class="LineNr"> 862 </span>                        [{[<span class="Constant">"P(C)"</span>,  <span class="Constant">true</span>]},  <span class="Constant">true</span>] }]
<span id="L863" class="LineNr"> 863 </span>           }) <span class="Type">&amp;&amp;</span>
<span id="L864" class="LineNr"> 864 </span>         <span class="Type">exists</span>(cm <span class="Type">in</span> d.<a class="Identifier code-proc-link" href="#da-895">poss_cms</a>() <span class="Type">|</span>
<span id="L865" class="LineNr"> 865 </span>           cm.f <span class="Type">==</span> {
<span id="L866" class="LineNr"> 866 </span>             [<span class="Constant">"P(A)"</span>, { [{[<span class="Constant">"P(B)"</span>, <span class="Constant">false</span>]}, <span class="Constant">false</span>],
<span id="L867" class="LineNr"> 867 </span>                        [{[<span class="Constant">"P(B)"</span>,  <span class="Constant">true</span>]}, <span class="Constant">false</span>]} ],
<span id="L868" class="LineNr"> 868 </span>             [<span class="Constant">"P(C)"</span>, { [{[<span class="Constant">"P(A)"</span>, <span class="Constant">false</span>]},  <span class="Constant">true</span>],
<span id="L869" class="LineNr"> 869 </span>                        [{[<span class="Constant">"P(A)"</span>,  <span class="Constant">true</span>]},  <span class="Constant">true</span>] }]
<span id="L870" class="LineNr"> 870 </span>           }),
<span id="L871" class="LineNr"> 871 </span>         <span class="Constant">"Error: poss_cms is incorrect."</span>);
<span id="L872" class="LineNr"> 872 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_cms'</span>);
<span id="L873" class="LineNr"> 873 </span>};
<span id="L874" class="LineNr"> 874 </span><span class="Identifier">test_poss_cms</span>();
<span id="L875" class="LineNr"><a href="#da-903" data-file="decision_algorithm" title="poss_cms_from_l" class="back_to_proc">&#8629;</a> 875 </span><span class="Identifier">test_poss_cms_from_l</span>      <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-853">test_poss_cms</a>(); };
<span id="L876" class="LineNr"><a href="#da-916" data-file="decision_algorithm" title="poss_cms_from_p_pars" class="back_to_proc">&#8629;</a> 876 </span><span class="Identifier">test_poss_cms_from_p_pars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-853">test_poss_cms</a>(); };
<span id="L877" class="LineNr"> 877 </span>
<span id="L878" class="LineNr"><a href="#da-2144" data-file="decision_algorithm" title="e_func" class="back_to_proc">&#8629;</a> 878 </span><span class="Identifier">test_e_func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L879" class="LineNr"> 879 </span>  d <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-713">d3</a>();
<span id="L880" class="LineNr"> 880 </span>  ds <span class="Statement">:=</span> { [<span class="Constant">'U(A)'</span>, <span class="Constant">5</span>], [<span class="Constant">'E1(B)'</span>, <span class="Constant">3</span>], [<span class="Constant">'E2(C)'</span>, <span class="Constant">8</span>] };
<span id="L881" class="LineNr"> 881 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2144">e_func</a>(ds, <span class="Constant">0</span>) <span class="Type">==</span> { [<span class="Constant">'U(A)'</span>,  <span class="Constant">5</span>] } <span class="Type">&amp;&amp;</span>
<span id="L882" class="LineNr"> 882 </span>         d.<span class="Identifier">e_func</span>(ds, <span class="Constant">1</span>) <span class="Type">==</span> { [<span class="Constant">'E1(B)'</span>, <span class="Constant">3</span>] } <span class="Type">&amp;&amp;</span>
<span id="L883" class="LineNr"> 883 </span>         d.<span class="Identifier">e_func</span>(ds, <span class="Constant">2</span>) <span class="Type">==</span> { [<span class="Constant">'E2(C)'</span>, <span class="Constant">8</span>] },
<span id="L884" class="LineNr"> 884 </span>         <span class="Constant">"Error: e_func is incorrect."</span>);
<span id="L885" class="LineNr"> 885 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] e_func'</span>);
<span id="L886" class="LineNr"> 886 </span>};
<span id="L887" class="LineNr"> 887 </span><span class="Identifier">test_e_func</span>();
<span id="L888" class="LineNr"> 888 </span>
<span id="L889" class="LineNr"><a href="#da-2152" data-file="decision_algorithm" title="ue" class="back_to_proc">&#8629;</a> 889 </span><span class="Identifier">test_ue</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L890" class="LineNr"> 890 </span>  d <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-713">d3</a>();
<span id="L891" class="LineNr"> 891 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2152">ue</a>(<span class="Constant">0</span>) <span class="Type">==</span> d.u <span class="Type">&amp;&amp;</span> d.<a class="Identifier code-proc-link" href="#da-2152">ue</a>(<span class="Constant">1</span>) <span class="Type">==</span> d.n[<span class="Constant">1</span>][<span class="Constant">'e'</span>] <span class="Type">&amp;&amp;</span> d.<a class="Identifier code-proc-link" href="#da-2152">ue</a>(<span class="Constant">2</span>) <span class="Type">==</span> d.n[<span class="Constant">2</span>][<span class="Constant">'e'</span>],
<span id="L892" class="LineNr"> 892 </span>         <span class="Constant">"Error: ue is incorrect."</span>);
<span id="L893" class="LineNr"> 893 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] ue'</span>);
<span id="L894" class="LineNr"> 894 </span>};
<span id="L895" class="LineNr"> 895 </span><span class="Identifier">test_ue</span>();
<span id="L896" class="LineNr"> 896 </span>
<span id="L897" class="LineNr"><a href="#da-2160" data-file="decision_algorithm" title="ue_base_exprs" class="back_to_proc">&#8629;</a> 897 </span><span class="Identifier">test_ue_base_exprs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L898" class="LineNr"> 898 </span>  d <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tda-713">d3</a>();
<span id="L899" class="LineNr"> 899 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2160">ue_base_exprs</a>(<span class="Constant">0</span>) <span class="Type">==</span> { <span class="Constant">'A'</span> } <span class="Type">&amp;&amp;</span>
<span id="L900" class="LineNr"> 900 </span>         d.<span class="Identifier">ue_base_exprs</span>(<span class="Constant">1</span>) <span class="Type">==</span> { <span class="Constant">'B'</span> } <span class="Type">&amp;&amp;</span>
<span id="L901" class="LineNr"> 901 </span>         d.<span class="Identifier">ue_base_exprs</span>(<span class="Constant">2</span>) <span class="Type">==</span> { <span class="Constant">'C'</span> },
<span id="L902" class="LineNr"> 902 </span>         <span class="Constant">"Error: ue_base_exprs is incorrect."</span>);
<span id="L903" class="LineNr"> 903 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] ue_base_exprs'</span>);
<span id="L904" class="LineNr"> 904 </span>};
<span id="L905" class="LineNr"> 905 </span><span class="Identifier">test_ue_base_exprs</span>();
<span id="L906" class="LineNr"> 906 </span>
<span id="L907" class="LineNr"> 907 </span><span class="Comment">/*</span>
<span id="L908" class="LineNr"> 908 </span><span class="Comment">test_state_space := procedure() {</span>
<span id="L909" class="LineNr"> 909 </span><span class="Comment">  d := decision_algorithm.new();</span>
<span id="L910" class="LineNr"> 910 </span><span class="Comment">  d.p := { ['A', 'P(A)'], ['B', 'P(B)'] };</span>
<span id="L911" class="LineNr"> 911 </span><span class="Comment">  assert(d.state_space(range(d.p)) == { </span>
<span id="L912" class="LineNr"> 912 </span><span class="Comment">           {Not('A'), Not('B')},</span>
<span id="L913" class="LineNr"> 913 </span><span class="Comment">           {Not('A'),     'B' },</span>
<span id="L914" class="LineNr"> 914 </span><span class="Comment">           {    'A' , Not('B')},</span>
<span id="L915" class="LineNr"> 915 </span><span class="Comment">           {    'A' ,     'B' }</span>
<span id="L916" class="LineNr"> 916 </span><span class="Comment">         },</span>
<span id="L917" class="LineNr"> 917 </span><span class="Comment">         "Error: state_space is incorrect.");</span>
<span id="L918" class="LineNr"> 918 </span><span class="Comment">  print('[ok] state_space');</span>
<span id="L919" class="LineNr"> 919 </span><span class="Comment">  assert(d.event_space(range(d.p)) == d.state_space(range(d.p)) + {</span>
<span id="L920" class="LineNr"> 920 </span><span class="Comment">           { Not('A') }, { 'A' }, { Not('B') }, { 'B' }, {}</span>
<span id="L921" class="LineNr"> 921 </span><span class="Comment">         },</span>
<span id="L922" class="LineNr"> 922 </span><span class="Comment">         "Error: event_space is incorrect.");</span>
<span id="L923" class="LineNr"> 923 </span><span class="Comment">  print('[ok] event_space');</span>
<span id="L924" class="LineNr"> 924 </span><span class="Comment">  // print(d.expr_space(d.state_space(range(d.p))));</span>
<span id="L925" class="LineNr"> 925 </span><span class="Comment">  assert(d.expr_space( d.state_space(range(d.p)) ) == {</span>
<span id="L926" class="LineNr"> 926 </span><span class="Comment">           And("A",      "B"), And(    "A" , Not("B")), </span>
<span id="L927" class="LineNr"> 927 </span><span class="Comment">           And("B", Not("A")), And(Not("A"), Not("B"))</span>
<span id="L928" class="LineNr"> 928 </span><span class="Comment">         },</span>
<span id="L929" class="LineNr"> 929 </span><span class="Comment">         "Error: expr_space is incorrect.");</span>
<span id="L930" class="LineNr"> 930 </span><span class="Comment">  print('[ok] expr_space');</span>
<span id="L931" class="LineNr"> 931 </span>
<span id="L932" class="LineNr"> 932 </span><span class="Comment">  d.p[And("A", "B")] := 'P(A^B)';</span>
<span id="L933" class="LineNr"> 933 </span><span class="Comment">  d.p[And("A", Not("B"))] := 'P(A^~B)';</span>
<span id="L934" class="LineNr"> 934 </span><span class="Comment">  d.p[And("B", Not("A"))] := 'P(B^~A)';</span>
<span id="L935" class="LineNr"> 935 </span><span class="Comment">  d.p[And(Not("A"), Not("B"))] := 'P(~A^~B)';</span>
<span id="L936" class="LineNr"> 936 </span><span class="Comment">  d.r := { ['P(A^B)', {0,1}], ['P(A^~B)', {0,1}], </span>
<span id="L937" class="LineNr"> 937 </span><span class="Comment">           ['P(B^~A)', {0,1}], ['P(~A^~B)', {0,1}] };</span>
<span id="L938" class="LineNr"> 938 </span><span class="Comment">  assert({["P(A^B)", 1], ["P(A^~B)", 0], ["P(B^~A)", 0], ["P(~A^~B)", 0]}</span>
<span id="L939" class="LineNr"> 939 </span><span class="Comment">           in d.poss_p_vs({'P(A)', 'P(B)'}),</span>
<span id="L940" class="LineNr"> 940 </span><span class="Comment">         "Error: poss_p_vs is incorrect");</span>
<span id="L941" class="LineNr"> 941 </span><span class="Comment">  print('[ok] poss_p_vs');</span>
<span id="L942" class="LineNr"> 942 </span><span class="Comment">};</span>
<span id="L943" class="LineNr"> 943 </span><span class="Comment">test_state_space();</span>
<span id="L944" class="LineNr"> 944 </span><span class="Comment">test_event_space := procedure() { test_state_space(); };</span>
<span id="L945" class="LineNr"> 945 </span><span class="Comment">test_expr_space := procedure() { test_expr_space(); };</span>
<span id="L946" class="LineNr"> 946 </span><span class="Comment">test_poss_p_vs := procedure() { test_poss_p_vs(); };</span>
<span id="L947" class="LineNr"> 947 </span><span class="Comment">*/</span>
<span id="L948" class="LineNr"> 948 </span>
<span id="L949" class="LineNr"> 949 </span><span class="Comment">// deprecated?</span>
<span id="L950" class="LineNr"> 950 </span><span class="Comment">/*</span>
<span id="L951" class="LineNr"> 951 </span><span class="Comment">test_p_of_vs := procedure() {</span>
<span id="L952" class="LineNr"> 952 </span><span class="Comment">  d := decision_algorithm.new();</span>
<span id="L953" class="LineNr"> 953 </span><span class="Comment">  d.p := { ['A', 'P(A)'], ['B', 'P(B)'], ['C', 'P(C)'] };</span>
<span id="L954" class="LineNr"> 954 </span><span class="Comment">  cm := causal_model(u, v, r, f, om);</span>
<span id="L955" class="LineNr"> 955 </span><span class="Comment">  cm.u := { 'P(A)', 'P(B)' };</span>
<span id="L956" class="LineNr"> 956 </span><span class="Comment">  cm.v := { 'P(C)' };</span>
<span id="L957" class="LineNr"> 957 </span><span class="Comment">  cm.r := { [var, tf()] : var in cm.u + cm.v };</span>
<span id="L958" class="LineNr"> 958 </span><span class="Comment">  cm.f := { </span>
<span id="L959" class="LineNr"> 959 </span><span class="Comment">    ['P(C)', { [ {['P(A)', false], ['P(B)', false]}, false],</span>
<span id="L960" class="LineNr"> 960 </span><span class="Comment">               [ {['P(A)', false], ['P(B)',  true]},  true],</span>
<span id="L961" class="LineNr"> 961 </span><span class="Comment">               [ {['P(A)',  true], ['P(B)', false]},  true],</span>
<span id="L962" class="LineNr"> 962 </span><span class="Comment">               [ {['P(A)',  true], ['P(B)',  true]},  true]</span>
<span id="L963" class="LineNr"> 963 </span><span class="Comment">             }]</span>
<span id="L964" class="LineNr"> 964 </span><span class="Comment">  };</span>
<span id="L965" class="LineNr"> 965 </span><span class="Comment">  assert(d.p_of_vs(cm, { ['P(A)', 0.33], ['P(B)', 0.5] }) == ,</span>
<span id="L966" class="LineNr"> 966 </span><span class="Comment">         "Error: p_of_vs is incorrect.");</span>
<span id="L967" class="LineNr"> 967 </span><span class="Comment">  print('[ok] p_of_vs');</span>
<span id="L968" class="LineNr"> 968 </span><span class="Comment">};</span>
<span id="L969" class="LineNr"> 969 </span><span class="Comment">test_p_of_vs();</span>
<span id="L970" class="LineNr"> 970 </span><span class="Comment">*/</span>
<span id="L971" class="LineNr"> 971 </span>
<span id="L972" class="LineNr"><a href="#da-930" data-file="decision_algorithm" title="coh_pcms" class="back_to_proc">&#8629;</a> 972 </span><span class="Identifier">test_coh_pcms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L973" class="LineNr"> 973 </span>  cm <span class="Statement">:=</span> causal_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L974" class="LineNr"> 974 </span>  cm.u <span class="Statement">:=</span> { <span class="Constant">'A'</span> };
<span id="L975" class="LineNr"> 975 </span>  cm.v <span class="Statement">:=</span> { <span class="Constant">'B'</span> };
<span id="L976" class="LineNr"> 976 </span>  cm.r <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'B'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L977" class="LineNr"> 977 </span>  cm.f <span class="Statement">:=</span> { [<span class="Constant">'B'</span>, { [{ [<span class="Constant">'A'</span>, <span class="Constant">false</span>] },  <span class="Constant">true</span>],
<span id="L978" class="LineNr"> 978 </span>                    [{ [<span class="Constant">'A'</span>,  <span class="Constant">true</span>] }, <span class="Constant">false</span>] }] };
<span id="L979" class="LineNr"> 979 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L980" class="LineNr"> 980 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>] };
<span id="L981" class="LineNr"> 981 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, { <span class="Constant">0</span>, <span class="Constant">1</span> }] };
<span id="L982" class="LineNr"> 982 </span><span class="Comment">//  print(d.coh_pcms(cm));</span>
<span id="L983" class="LineNr"> 983 </span><span class="Comment">//  assert(d.coh_pcms(cm) == ,</span>
<span id="L984" class="LineNr"> 984 </span><span class="Comment">//         "Error: coh_pcms is incorrect.");</span>
<span id="L985" class="LineNr"> 985 </span>  <span class="Identifier">print</span>(<span class="Constant">'[.?] coh_pcms'</span>);
<span id="L986" class="LineNr"> 986 </span>};
<span id="L987" class="LineNr"> 987 </span><span class="Comment">// test_coh_pcms();</span>
<span id="L988" class="LineNr"> 988 </span>
<span id="L989" class="LineNr"> 989 </span><span class="Comment">/* Template</span>
<span id="L990" class="LineNr"> 990 </span><span class="Comment">test_ := procedure() {</span>
<span id="L991" class="LineNr"> 991 </span><span class="Comment">  d := decision_algorithm.new();</span>
<span id="L992" class="LineNr"> 992 </span><span class="Comment">  assert(d.() == ,</span>
<span id="L993" class="LineNr"> 993 </span><span class="Comment">         "Error:  is incorrect.");</span>
<span id="L994" class="LineNr"> 994 </span><span class="Comment">  print('[ok] ');</span>
<span id="L995" class="LineNr"> 995 </span><span class="Comment">};</span>
<span id="L996" class="LineNr"> 996 </span><span class="Comment">test_();</span>
<span id="L997" class="LineNr"> 997 </span><span class="Comment">*/</span>
<span id="L998" class="LineNr"> 998 </span>
<span id="L999" class="LineNr"> 999 </span><span class="Identifier">print</span>(<span class="Constant">' '</span>);
<span id="L1000" class="LineNr">1000 </span>
<span id="L1001" class="LineNr"><a href="#da-1022" data-file="decision_algorithm" title="expr_to_p_funcs" class="back_to_proc">&#8629;</a>1001 </span><span class="Identifier">test_expr_to_p_funcs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1002" class="LineNr">1002 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1003" class="LineNr">1003 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>] };
<span id="L1004" class="LineNr">1004 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1022">expr_to_p_funcs</a>(<span class="Identifier">Implies</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), {<span class="Constant">'A'</span>, <span class="Constant">'B'</span> }) <span class="Type">==</span> {
<span id="L1005" class="LineNr">1005 </span>           {[<span class="Constant">"P(A)"</span>, <span class="Constant">false</span>], [<span class="Constant">"P(B)"</span>, <span class="Constant">false</span>]},
<span id="L1006" class="LineNr">1006 </span>           {[<span class="Constant">"P(A)"</span>, <span class="Constant">false</span>], [<span class="Constant">"P(B)"</span>,  <span class="Constant">true</span>]},
<span id="L1007" class="LineNr">1007 </span>           {[<span class="Constant">"P(A)"</span>,  <span class="Constant">true</span>], [<span class="Constant">"P(B)"</span>,  <span class="Constant">true</span>]}
<span id="L1008" class="LineNr">1008 </span>         }, <span class="Constant">"Error: expr_to_p_funcs is incorrect."</span>);
<span id="L1009" class="LineNr">1009 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] expr_to_p_funcs'</span>);
<span id="L1010" class="LineNr">1010 </span>
<span id="L1011" class="LineNr">1011 </span>  d.p[<span class="Identifier">Implies</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>)] <span class="Statement">:=</span> <span class="Constant">'P(A-&gt;B)'</span>;
<span id="L1012" class="LineNr">1012 </span>  d.p[<span class="Identifier">Not</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Identifier">Not</span>(<span class="Constant">'B'</span>)))] <span class="Statement">:=</span> <span class="Constant">'P(~(A^~B))'</span>;
<span id="L1013" class="LineNr">1013 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1108">equiv_p_expr</a>(d.p, d.cp, <span class="Constant">'P(A-&gt;B)'</span>, <span class="Constant">'P(~(A^~B))'</span>) <span class="Type">==</span> <span class="Constant">true</span>,
<span id="L1014" class="LineNr">1014 </span>         <span class="Constant">"Error: equiv_p_expr is incorrect"</span>);
<span id="L1015" class="LineNr">1015 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] equiv_p_expr true'</span>);
<span id="L1016" class="LineNr">1016 </span>};
<span id="L1017" class="LineNr">1017 </span><span class="Identifier">test_expr_to_p_funcs</span>();
<span id="L1018" class="LineNr">1018 </span>
<span id="L1019" class="LineNr"><a href="#da-1091" data-file="decision_algorithm" title="sum_p" class="back_to_proc">&#8629;</a>1019 </span><span class="Identifier">test_sum_p</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1020" class="LineNr">1020 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1021" class="LineNr">1021 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>], [<span class="Constant">'C'</span>, <span class="Constant">'P(C)'</span>] };
<span id="L1022" class="LineNr">1022 </span>  p1 <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">0.6</span>], [<span class="Constant">'P(C)'</span>, <span class="Constant">0.3</span>] };
<span id="L1023" class="LineNr">1023 </span>  p2 <span class="Statement">:=</span> { [<span class="Constant">'P(B)'</span>, <span class="Constant">0.2</span>], [<span class="Constant">'P(C)'</span>, <span class="Constant">0.5</span>] };
<span id="L1024" class="LineNr">1024 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1091">sum_p</a>(p1, p2) <span class="Type">==</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">0.6</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.2</span>], [<span class="Constant">'P(C)'</span>, <span class="Constant">0.8</span>] },
<span id="L1025" class="LineNr">1025 </span>         <span class="Constant">"Error: sum_p is incorrect."</span>);
<span id="L1026" class="LineNr">1026 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] sum_p'</span>);
<span id="L1027" class="LineNr">1027 </span>};
<span id="L1028" class="LineNr">1028 </span><span class="Identifier">test_sum_p</span>();
<span id="L1029" class="LineNr">1029 </span>
<span id="L1030" class="LineNr"><a href="#da-1083" data-file="decision_algorithm" title="add_p_distr" class="back_to_proc">&#8629;</a>1030 </span><span class="Identifier">test_add_p_distr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1031" class="LineNr">1031 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1032" class="LineNr">1032 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>], [<span class="Constant">'C'</span>, <span class="Constant">'P(C)'</span>] };
<span id="L1033" class="LineNr">1033 </span>  d.cp <span class="Statement">:=</span> { [[<span class="Constant">'C'</span>, <span class="Constant">'A'</span>], <span class="Constant">'P(C|A)'</span>], [[<span class="Constant">'C'</span>, <span class="Constant">'B'</span>], <span class="Constant">'P(C|B)'</span>] };
<span id="L1034" class="LineNr">1034 </span>  p_cp1 <span class="Statement">:=</span> [{ [<span class="Constant">'P(A)'</span>, <span class="Constant">0.2</span>] }, { [<span class="Constant">'P(C|A)'</span>, <span class="Constant">0.3</span>], [<span class="Constant">'P(C|B)'</span>, <span class="Constant">0.4</span>] }];
<span id="L1035" class="LineNr">1035 </span>  p_cp2 <span class="Statement">:=</span> [{ [<span class="Constant">'P(A)'</span>, <span class="Constant">0.4</span>] }, { [<span class="Constant">'P(C|A)'</span>, <span class="Constant">0.1</span>], [<span class="Constant">'P(C|B)'</span>, <span class="Constant">0.3</span>] }];
<span id="L1036" class="LineNr">1036 </span>  p_cp <span class="Statement">:=</span> d.<a class="Identifier code-proc-link" href="#da-1083">add_p_distr</a>(p_cp1, p_cp2);
<span id="L1037" class="LineNr">1037 </span>  <span class="Statement">assert</span>((p_cp[<span class="Constant">2</span>])[<span class="Constant">'P(C|A)'</span>] <span class="Type">==</span> <span class="Constant">0.4</span> <span class="Type">&amp;&amp;</span> (p_cp[<span class="Constant">2</span>])[<span class="Constant">'P(C|B)'</span>] <span class="Type">==</span> <span class="Constant">0.7</span> <span class="Type">&amp;&amp;</span>
<span id="L1038" class="LineNr">1038 </span>         (p_cp[<span class="Constant">1</span>])[<span class="Constant">'P(A)'</span>] <span class="Type">-</span> <span class="Constant">0.6</span> <span class="Type">&lt;</span> <span class="Constant">0.01</span>,
<span id="L1039" class="LineNr">1039 </span>         <span class="Constant">"Error: add_p_distr is incorrect."</span>);
<span id="L1040" class="LineNr">1040 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] add_p_distr'</span>);
<span id="L1041" class="LineNr">1041 </span>};
<span id="L1042" class="LineNr">1042 </span><span class="Identifier">test_add_p_distr</span>();
<span id="L1043" class="LineNr">1043 </span>
<span id="L1044" class="LineNr"><a href="#da-1275" data-file="decision_algorithm" title="prob_distance" class="back_to_proc">&#8629;</a>1044 </span><span class="Identifier">test_prob_distance</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1045" class="LineNr">1045 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1046" class="LineNr">1046 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>] };
<span id="L1047" class="LineNr">1047 </span>  d.cp <span class="Statement">:=</span> { [[<span class="Constant">'B'</span>, <span class="Constant">'A'</span>], <span class="Constant">'P(B|A)'</span>] };
<span id="L1048" class="LineNr">1048 </span>  pp1 <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">0.4</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.5</span>], [<span class="Constant">'P(B|A)'</span>, <span class="Constant">0.6</span>] };
<span id="L1049" class="LineNr">1049 </span>  pp2 <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">0.1</span>], [<span class="Constant">'P(B)'</span>, <span class="Constant">0.9</span>], [<span class="Constant">'P(B|A)'</span>, <span class="Constant">0.2</span>] };
<span id="L1050" class="LineNr">1050 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1275">prob_distance</a>(d.p, d.cp, pp1, pp2) <span class="Type">==</span> <span class="Constant">1.1</span>,
<span id="L1051" class="LineNr">1051 </span>         <span class="Constant">"Error: prob_distance is incorrect."</span>);
<span id="L1052" class="LineNr">1052 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] prob_distance'</span>);
<span id="L1053" class="LineNr">1053 </span>};
<span id="L1054" class="LineNr">1054 </span><span class="Identifier">test_prob_distance</span>();
<span id="L1055" class="LineNr">1055 </span>
<span id="L1056" class="LineNr"><a href="#da-1324" data-file="decision_algorithm" title="poss_io_states" class="back_to_proc">&#8629;</a>1056 </span><span class="Identifier">test_poss_io_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1057" class="LineNr">1057 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1058" class="LineNr">1058 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'P(I)'</span> };
<span id="L1059" class="LineNr">1059 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L1060" class="LineNr">1060 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(I)'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}], [<span class="Constant">'O'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()]};
<span id="L1061" class="LineNr">1061 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1324">poss_io_states</a>() <span class="Type">==</span> {
<span id="L1062" class="LineNr">1062 </span>          { [<span class="Constant">'P(I)'</span>, <span class="Constant">0</span>], [<span class="Constant">'O'</span>, <span class="Constant">false</span>] },
<span id="L1063" class="LineNr">1063 </span>          { [<span class="Constant">'P(I)'</span>, <span class="Constant">0</span>], [<span class="Constant">'O'</span>,  <span class="Constant">true</span>] },
<span id="L1064" class="LineNr">1064 </span>          { [<span class="Constant">'P(I)'</span>, <span class="Constant">1</span>], [<span class="Constant">'O'</span>, <span class="Constant">false</span>] },
<span id="L1065" class="LineNr">1065 </span>          { [<span class="Constant">'P(I)'</span>, <span class="Constant">1</span>], [<span class="Constant">'O'</span>,  <span class="Constant">true</span>] }
<span id="L1066" class="LineNr">1066 </span>         },
<span id="L1067" class="LineNr">1067 </span>         <span class="Constant">"Error: poss_io_states is incorrect."</span>);
<span id="L1068" class="LineNr">1068 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_io_states'</span>);
<span id="L1069" class="LineNr">1069 </span>};
<span id="L1070" class="LineNr">1070 </span><span class="Identifier">test_poss_io_states</span>();
<span id="L1071" class="LineNr">1071 </span>
<span id="L1072" class="LineNr"><a href="#da-1332" data-file="decision_algorithm" title="poss_m_states" class="back_to_proc">&#8629;</a>1072 </span><span class="Identifier">test_poss_m_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1073" class="LineNr">1073 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1074" class="LineNr">1074 </span>  d.m <span class="Statement">:=</span> { <span class="Constant">'M1'</span>, <span class="Constant">'M2'</span> };
<span id="L1075" class="LineNr">1075 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'M1'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'M2'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L1076" class="LineNr">1076 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1332">poss_m_states</a>() <span class="Type">==</span> {
<span id="L1077" class="LineNr">1077 </span>           { [<span class="Constant">'M1'</span>, <span class="Constant">false</span>], [<span class="Constant">'M2'</span>, <span class="Constant">false</span>] },
<span id="L1078" class="LineNr">1078 </span>           { [<span class="Constant">'M1'</span>, <span class="Constant">false</span>], [<span class="Constant">'M2'</span>,  <span class="Constant">true</span>] },
<span id="L1079" class="LineNr">1079 </span>           { [<span class="Constant">'M1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'M2'</span>, <span class="Constant">false</span>] },
<span id="L1080" class="LineNr">1080 </span>           { [<span class="Constant">'M1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'M2'</span>,  <span class="Constant">true</span>] }
<span id="L1081" class="LineNr">1081 </span>         },
<span id="L1082" class="LineNr">1082 </span>         <span class="Constant">"Error: poss_m_states is incorrect."</span>);
<span id="L1083" class="LineNr">1083 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_m_states'</span>);
<span id="L1084" class="LineNr">1084 </span>};
<span id="L1085" class="LineNr">1085 </span><span class="Identifier">test_poss_m_states</span>();
<span id="L1086" class="LineNr">1086 </span>
<span id="L1087" class="LineNr"><a href="#da-1352" data-file="decision_algorithm" title="poss_o_states" class="back_to_proc">&#8629;</a>1087 </span><span class="Identifier">test_poss_o_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1088" class="LineNr">1088 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1089" class="LineNr">1089 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O1'</span>, <span class="Constant">'O2'</span> };
<span id="L1090" class="LineNr">1090 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'O1'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'O2'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L1091" class="LineNr">1091 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1352">poss_o_states</a>() <span class="Type">==</span> {
<span id="L1092" class="LineNr">1092 </span>           { [<span class="Constant">'O1'</span>, <span class="Constant">false</span>], [<span class="Constant">'O2'</span>, <span class="Constant">false</span>] },
<span id="L1093" class="LineNr">1093 </span>           { [<span class="Constant">'O1'</span>, <span class="Constant">false</span>], [<span class="Constant">'O2'</span>,  <span class="Constant">true</span>] },
<span id="L1094" class="LineNr">1094 </span>           { [<span class="Constant">'O1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'O2'</span>, <span class="Constant">false</span>] },
<span id="L1095" class="LineNr">1095 </span>           { [<span class="Constant">'O1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'O2'</span>,  <span class="Constant">true</span>] }
<span id="L1096" class="LineNr">1096 </span>         },
<span id="L1097" class="LineNr">1097 </span>         <span class="Constant">"Error: poss_o_states is incorrect."</span>);
<span id="L1098" class="LineNr">1098 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_o_states'</span>);
<span id="L1099" class="LineNr">1099 </span>};
<span id="L1100" class="LineNr">1100 </span><span class="Identifier">test_poss_o_states</span>();
<span id="L1101" class="LineNr">1101 </span>
<span id="L1102" class="LineNr"><a href="#da-1572" data-file="decision_algorithm" title="possible_fms" class="back_to_proc">&#8629;</a>1102 </span><span class="Identifier">test_possible_fms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1103" class="LineNr">1103 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1104" class="LineNr">1104 </span>  d.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L1105" class="LineNr">1105 </span>  d.m <span class="Statement">:=</span> { <span class="Constant">'M_1'</span>, <span class="Constant">'M_2'</span> };
<span id="L1106" class="LineNr">1106 </span>  d.m2 <span class="Statement">:=</span> { <span class="Constant">'M2_1'</span>, <span class="Constant">'M2_2'</span> };
<span id="L1107" class="LineNr">1107 </span>  d.r <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> d.o <span class="Type">+</span> d.m <span class="Type">+</span> d.m2 };
<span id="L1108" class="LineNr">1108 </span>  <span class="Comment">// d.r := { [var, tf()] : var in d.o + d.m };</span>
<span id="L1109" class="LineNr">1109 </span>  ds <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1110" class="LineNr">1110 </span>  ds.o <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L1111" class="LineNr">1111 </span>  ds.m <span class="Statement">:=</span> { <span class="Constant">'ds.M_1'</span>, <span class="Constant">'ds.M_2'</span> };
<span id="L1112" class="LineNr">1112 </span>  ds.m2 <span class="Statement">:=</span> { <span class="Constant">'ds.M2_1'</span>, <span class="Constant">'ds.M2_2'</span> };
<span id="L1113" class="LineNr">1113 </span>  ds.r <span class="Statement">:=</span> { [var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> var <span class="Type">in</span> ds.o <span class="Type">+</span> ds.m <span class="Type">+</span> ds.m2 };
<span id="L1114" class="LineNr">1114 </span>  <span class="Comment">// ds.r := { [var, tf()] : var in ds.o + ds.m };</span>
<span id="L1115" class="LineNr">1115 </span>  p_fms <span class="Statement">:=</span> [fm <span class="Type">:</span> fm <span class="Type">in</span> d.<a class="Identifier code-proc-link" href="#da-1572">possible_fms</a>(ds)];
<span id="L1116" class="LineNr">1116 </span>  <span class="Identifier">print</span>(p_fms);
<span id="L1117" class="LineNr">1117 </span>  <span class="Comment">// print('[.?] possible_fms');</span>
<span id="L1118" class="LineNr">1118 </span>};
<span id="L1119" class="LineNr">1119 </span><span class="Comment">// test_possible_fms();</span>
<span id="L1120" class="LineNr"><a href="#da-1592" data-file="decision_algorithm" title="apply_fm_m" class="back_to_proc">&#8629;</a>1120 </span><span class="Identifier">test_apply_fm_m</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-1102">test_possible_fms</a>(); };
<span id="L1121" class="LineNr"><a href="#da-1597" data-file="decision_algorithm" title="fm_commutes" class="back_to_proc">&#8629;</a>1121 </span><span class="Identifier">test_fm_commutes</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-1102">test_possible_fms</a>(); };
<span id="L1122" class="LineNr">1122 </span>
<span id="L1123" class="LineNr"><a href="#da-1251" data-file="decision_algorithm" title="force_list" class="back_to_proc">&#8629;</a><a href="#da-1170" data-file="decision_algorithm" title="force_list" class="back_to_proc">&#8629;</a>1123 </span><span class="Identifier">test_force_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1124" class="LineNr">1124 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1125" class="LineNr">1125 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>] };
<span id="L1126" class="LineNr">1126 </span>  d.cp <span class="Statement">:=</span> { [[<span class="Constant">'B'</span>, <span class="Constant">'A'</span>], <span class="Constant">'P(B|A)'</span>] };
<span id="L1127" class="LineNr">1127 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1170">force_list</a>(<span class="Constant">'P(A)'</span>  ) <span class="Type">==</span> [<span class="Constant">'A'</span>,  <span class="Constant">om</span>] <span class="Type">&amp;&amp;</span>
<span id="L1128" class="LineNr">1128 </span>         d.<span class="Identifier">force_list</span>(<span class="Constant">'P(B|A)'</span>) <span class="Type">==</span> [<span class="Constant">'B'</span>, <span class="Constant">'A'</span>],
<span id="L1129" class="LineNr">1129 </span>         <span class="Constant">"Error: force_list  is incorrect."</span>);
<span id="L1130" class="LineNr">1130 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] force_list '</span>);
<span id="L1131" class="LineNr">1131 </span>};
<span id="L1132" class="LineNr">1132 </span><span class="Identifier">test_force_list</span>();
<span id="L1133" class="LineNr">1133 </span>
<span id="L1134" class="LineNr"><a href="#da-1949" data-file="decision_algorithm" title="p_i_sim" class="back_to_proc">&#8629;</a>1134 </span><span class="Identifier">test_p_i_sim</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1135" class="LineNr">1135 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1136" class="LineNr">1136 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>] };
<span id="L1137" class="LineNr">1137 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, {<span class="Constant">0</span>, <span class="Constant">0.25</span>, <span class="Constant">0.75</span>, <span class="Constant">1</span>}] };
<span id="L1138" class="LineNr">1138 </span>  ds1 <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">0.25</span>] };
<span id="L1139" class="LineNr">1139 </span>  ds2 <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, <span class="Constant">0</span>] };
<span id="L1140" class="LineNr">1140 </span>  <span class="Statement">assert</span>(<span class="Identifier">abs</span>(d.<a class="Identifier code-proc-link" href="#da-1949">p_i_sim</a>(ds1, ds2, <span class="Constant">'P(A)'</span>) <span class="Type">-</span> <span class="Constant">2</span> <span class="Type">/</span> <span class="Constant">3</span>) <span class="Type">&lt;</span> <span class="Constant">0.01</span>,
<span id="L1141" class="LineNr">1141 </span>         <span class="Constant">"Error: p_i_sim is incorrect."</span>);
<span id="L1142" class="LineNr">1142 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] p_i_sim'</span>);
<span id="L1143" class="LineNr">1143 </span>};
<span id="L1144" class="LineNr">1144 </span><span class="Identifier">test_p_i_sim</span>();
<span id="L1145" class="LineNr">1145 </span>
<span id="L1146" class="LineNr"><a href="#da-1989" data-file="decision_algorithm" title="id_expr" class="back_to_proc">&#8629;</a>1146 </span><span class="Identifier">test_id_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1147" class="LineNr">1147 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1148" class="LineNr">1148 </span>  d.i <span class="Statement">:=</span> {<span class="Constant">'P(I)'</span>};
<span id="L1149" class="LineNr">1149 </span>  d.p <span class="Statement">:=</span> {[<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'I'</span>, <span class="Constant">'P(I)'</span>] };
<span id="L1150" class="LineNr">1150 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-1989">id_expr</a>(<span class="Constant">'A'</span>) <span class="Type">==</span> <span class="Constant">'A'</span> <span class="Type">&amp;&amp;</span>
<span id="L1151" class="LineNr">1151 </span>         d.<span class="Identifier">id_expr</span>(<span class="Constant">'I'</span>) <span class="Type">==</span> <span class="Identifier">At_t</span>(<span class="Constant">'I'</span>, <span class="Type">-</span><span class="Constant">1</span>) <span class="Type">&amp;&amp;</span>
<span id="L1152" class="LineNr">1152 </span>         d.<span class="Identifier">id_expr</span>(<span class="Identifier">At_t</span>(<span class="Constant">'I'</span>, <span class="Type">-</span><span class="Constant">1</span>)) <span class="Type">==</span> <span class="Identifier">At_t</span>(<span class="Constant">'I'</span>, <span class="Type">-</span><span class="Constant">2</span>),
<span id="L1153" class="LineNr">1153 </span>         <span class="Constant">"Error: id_expr is incorrect."</span>);
<span id="L1154" class="LineNr">1154 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] id_expr'</span>);
<span id="L1155" class="LineNr">1155 </span>
<span id="L1156" class="LineNr">1156 </span>  d.p <span class="Statement">:=</span> d.p <span class="Type">+</span> { [<span class="Identifier">At_t</span>(<span class="Constant">'I'</span>, <span class="Type">-</span><span class="Constant">1</span>), <span class="Constant">'P(I_-1)'</span>],
<span id="L1157" class="LineNr">1157 </span>                 [<span class="Identifier">At_t</span>(<span class="Constant">'I'</span>, <span class="Type">-</span><span class="Constant">2</span>), <span class="Constant">'P(I_-2)'</span>] };
<span id="L1158" class="LineNr">1158 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2005">id_var</a>(<span class="Constant">'P(I)'</span>)    <span class="Type">==</span> <span class="Constant">'P(I_-1)'</span> <span class="Type">&amp;&amp;</span>
<span id="L1159" class="LineNr">1159 </span>         d.<span class="Identifier">id_var</span>(<span class="Constant">'P(I_-1)'</span>) <span class="Type">==</span> <span class="Constant">'P(I_-2)'</span>,
<span id="L1160" class="LineNr">1160 </span>         <span class="Constant">"Error: id_var is incorrect."</span>);
<span id="L1161" class="LineNr">1161 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] id_var'</span>);
<span id="L1162" class="LineNr">1162 </span>};
<span id="L1163" class="LineNr">1163 </span><span class="Identifier">test_id_expr</span>();
<span id="L1164" class="LineNr"><a href="#da-2005" data-file="decision_algorithm" title="id_var" class="back_to_proc">&#8629;</a>1164 </span><span class="Identifier">test_id_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tda-1146">test_id_expr</a>(); };
<span id="L1165" class="LineNr">1165 </span>
<span id="L1166" class="LineNr"><a href="#da-2009" data-file="decision_algorithm" title="poss_i_events" class="back_to_proc">&#8629;</a>1166 </span><span class="Identifier">test_poss_i_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1167" class="LineNr">1167 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1168" class="LineNr">1168 </span>  d.i <span class="Statement">:=</span> { <span class="Constant">'P(I)'</span>, <span class="Constant">'P(I2)'</span> };
<span id="L1169" class="LineNr">1169 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(I)'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}], [<span class="Constant">'P(I2)'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}] };
<span id="L1170" class="LineNr">1170 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2009">poss_i_events</a>() <span class="Type">==</span> {
<span id="L1171" class="LineNr">1171 </span>           {[<span class="Constant">"P(I)"</span>, <span class="Constant">0</span>]}, {[<span class="Constant">"P(I)"</span>, <span class="Constant">1</span>]},
<span id="L1172" class="LineNr">1172 </span>           {[<span class="Constant">"P(I2)"</span>, <span class="Constant">0</span>]}, {[<span class="Constant">"P(I2)"</span>, <span class="Constant">1</span>]},
<span id="L1173" class="LineNr">1173 </span>           {[<span class="Constant">"P(I)"</span>, <span class="Constant">0</span>], [<span class="Constant">"P(I2)"</span>, <span class="Constant">0</span>]},
<span id="L1174" class="LineNr">1174 </span>           {[<span class="Constant">"P(I)"</span>, <span class="Constant">0</span>], [<span class="Constant">"P(I2)"</span>, <span class="Constant">1</span>]},
<span id="L1175" class="LineNr">1175 </span>           {[<span class="Constant">"P(I)"</span>, <span class="Constant">1</span>], [<span class="Constant">"P(I2)"</span>, <span class="Constant">0</span>]},
<span id="L1176" class="LineNr">1176 </span>           {[<span class="Constant">"P(I)"</span>, <span class="Constant">1</span>], [<span class="Constant">"P(I2)"</span>, <span class="Constant">1</span>]}
<span id="L1177" class="LineNr">1177 </span>         }, <span class="Constant">"Error: poss_i_events is incorrect."</span>);
<span id="L1178" class="LineNr">1178 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_i_events'</span>);
<span id="L1179" class="LineNr">1179 </span>};
<span id="L1180" class="LineNr">1180 </span><span class="Identifier">test_poss_i_events</span>();
<span id="L1181" class="LineNr">1181 </span>
<span id="L1182" class="LineNr"><a href="#da-2013" data-file="decision_algorithm" title="e_vars" class="back_to_proc">&#8629;</a>1182 </span><span class="Identifier">test_e_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1183" class="LineNr">1183 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1184" class="LineNr">1184 </span>  d.n <span class="Statement">:=</span> [{ [<span class="Constant">'e'</span>, {[<span class="Constant">'A'</span>,<span class="Constant">'E_n1(A)'</span>]}], [<span class="Constant">'m2'</span>, {<span class="Constant">'M2_n1'</span>}], [<span class="Constant">'o'</span>, {<span class="Constant">'O_n1'</span>}] },
<span id="L1185" class="LineNr">1185 </span>          { [<span class="Constant">'e'</span>, {[<span class="Constant">'B'</span>,<span class="Constant">'E_n2(B)'</span>]}], [<span class="Constant">'m2'</span>, {<span class="Constant">'M2_n2'</span>}], [<span class="Constant">'o'</span>, {<span class="Constant">'O_n2'</span>}] } ];
<span id="L1186" class="LineNr">1186 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2013">e_vars</a>() <span class="Type">==</span> { <span class="Constant">'E_n1(A)'</span>, <span class="Constant">'E_n2(B)'</span> },
<span id="L1187" class="LineNr">1187 </span>         <span class="Constant">"Error: e_vars  is incorrect."</span>);
<span id="L1188" class="LineNr">1188 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] e_vars '</span>);
<span id="L1189" class="LineNr">1189 </span>};
<span id="L1190" class="LineNr">1190 </span><span class="Identifier">test_e_vars</span>();
<span id="L1191" class="LineNr">1191 </span>
<span id="L1192" class="LineNr"><a href="#da-2017" data-file="decision_algorithm" title="poss_ue_events" class="back_to_proc">&#8629;</a>1192 </span><span class="Identifier">test_poss_ue_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1193" class="LineNr">1193 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1194" class="LineNr">1194 </span>  d.n <span class="Statement">:=</span> [{ [<span class="Constant">'e'</span>, {[<span class="Constant">'A'</span>,<span class="Constant">'E'</span>]}], [<span class="Constant">'m2'</span>, {<span class="Constant">'M2'</span>}], [<span class="Constant">'o'</span>, {<span class="Constant">'O'</span>}] }];
<span id="L1195" class="LineNr">1195 </span>  d.u <span class="Statement">:=</span> { [<span class="Constant">'B'</span>, <span class="Constant">'U'</span>] };
<span id="L1196" class="LineNr">1196 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'E'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}], [<span class="Constant">'U'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}] };
<span id="L1197" class="LineNr">1197 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2017">poss_ue_events</a>() <span class="Type">==</span> {
<span id="L1198" class="LineNr">1198 </span>           {[<span class="Constant">"E"</span>, <span class="Constant">0</span>]}, {[<span class="Constant">"E"</span>, <span class="Constant">0</span>], [<span class="Constant">"U"</span>, <span class="Constant">0</span>]}, {[<span class="Constant">"E"</span>, <span class="Constant">0</span>], [<span class="Constant">"U"</span>, <span class="Constant">1</span>]}, {[<span class="Constant">"E"</span>, <span class="Constant">1</span>]},
<span id="L1199" class="LineNr">1199 </span>           {[<span class="Constant">"E"</span>, <span class="Constant">1</span>], [<span class="Constant">"U"</span>, <span class="Constant">0</span>]}, {[<span class="Constant">"E"</span>, <span class="Constant">1</span>], [<span class="Constant">"U"</span>, <span class="Constant">1</span>]}, {[<span class="Constant">"U"</span>, <span class="Constant">0</span>]}, {[<span class="Constant">"U"</span>, <span class="Constant">1</span>]}
<span id="L1200" class="LineNr">1200 </span>         }, <span class="Constant">"Error: poss_ue_events is incorrect."</span>);
<span id="L1201" class="LineNr">1201 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_ue_events'</span>);
<span id="L1202" class="LineNr">1202 </span>};
<span id="L1203" class="LineNr">1203 </span><span class="Identifier">test_poss_ue_events</span>();
<span id="L1204" class="LineNr">1204 </span>
<span id="L1205" class="LineNr"><a href="#da-2022" data-file="decision_algorithm" title="poss_p_i_events" class="back_to_proc">&#8629;</a>1205 </span><span class="Identifier">test_poss_p_i_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1206" class="LineNr">1206 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1207" class="LineNr">1207 </span>  d.p <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'P(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'P(B)'</span>] };
<span id="L1208" class="LineNr">1208 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'P(A)'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}], [<span class="Constant">'P(B)'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}] };
<span id="L1209" class="LineNr">1209 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2022">poss_p_i_events</a>() <span class="Type">==</span> { [<span class="Constant">"P(A)"</span>, <span class="Constant">0</span>], [<span class="Constant">"P(A)"</span>, <span class="Constant">1</span>], [<span class="Constant">"P(B)"</span>, <span class="Constant">0</span>], [<span class="Constant">"P(B)"</span>, <span class="Constant">1</span>] },
<span id="L1210" class="LineNr">1210 </span>         <span class="Constant">"Error: poss_p_i_events is incorrect."</span>);
<span id="L1211" class="LineNr">1211 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_p_i_events'</span>);
<span id="L1212" class="LineNr">1212 </span>};
<span id="L1213" class="LineNr">1213 </span><span class="Identifier">test_poss_p_i_events</span>();
<span id="L1214" class="LineNr">1214 </span>
<span id="L1215" class="LineNr"><a href="#da-2031" data-file="decision_algorithm" title="poss_rx_states" class="back_to_proc">&#8629;</a>1215 </span><span class="Identifier">test_poss_rx_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1216" class="LineNr">1216 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1217" class="LineNr">1217 </span>  d.n <span class="Statement">:=</span> [{ [<span class="Constant">'o'</span>, {<span class="Constant">'O_n1'</span>}] }, { [<span class="Constant">'o'</span>, {<span class="Constant">'O_n2'</span>}] }];
<span id="L1218" class="LineNr">1218 </span>  d.r <span class="Statement">:=</span> { [<span class="Constant">'O_n1'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'O_n2'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L1219" class="LineNr">1219 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2031">poss_rx_states</a>() <span class="Type">==</span> {
<span id="L1220" class="LineNr">1220 </span>           {[<span class="Constant">"O_n1"</span>, <span class="Constant">false</span>], [<span class="Constant">"O_n2"</span>, <span class="Constant">false</span>]},
<span id="L1221" class="LineNr">1221 </span>           {[<span class="Constant">"O_n1"</span>, <span class="Constant">false</span>], [<span class="Constant">"O_n2"</span>,  <span class="Constant">true</span>]},
<span id="L1222" class="LineNr">1222 </span>           {[<span class="Constant">"O_n1"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O_n2"</span>, <span class="Constant">false</span>]},
<span id="L1223" class="LineNr">1223 </span>           {[<span class="Constant">"O_n1"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O_n2"</span>,  <span class="Constant">true</span>]}
<span id="L1224" class="LineNr">1224 </span>         }, <span class="Constant">"Error: poss_rx_states is incorrect."</span>);
<span id="L1225" class="LineNr">1225 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_rx_states'</span>);
<span id="L1226" class="LineNr">1226 </span>};
<span id="L1227" class="LineNr">1227 </span><span class="Identifier">test_poss_rx_states</span>();
<span id="L1228" class="LineNr">1228 </span>
<span id="L1229" class="LineNr"><a href="#da-2037" data-file="decision_algorithm" title="poss_rxs" class="back_to_proc">&#8629;</a>1229 </span><span class="Identifier">test_poss_rxs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1230" class="LineNr">1230 </span>  d <span class="Statement">:=</span> decision_algorithm.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L1231" class="LineNr">1231 </span>  d.n <span class="Statement">:=</span> [{ [<span class="Constant">'o'</span>, {<span class="Constant">'O_n1_1'</span>, <span class="Constant">'O_n1_2'</span>}] }, { [<span class="Constant">'o'</span>, {<span class="Constant">'O_n2'</span>}] } ];
<span id="L1232" class="LineNr">1232 </span>  d.r <span class="Statement">:=</span> { [no_var, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] <span class="Type">:</span> no_var <span class="Type">in</span> {<span class="Constant">'O_n1_1'</span>, <span class="Constant">'O_n1_2'</span>, <span class="Constant">'O_n2'</span>} };
<span id="L1233" class="LineNr">1233 </span>  <span class="Statement">assert</span>(d.<a class="Identifier code-proc-link" href="#da-2037">poss_rxs</a>() <span class="Type">==</span> {
<span id="L1234" class="LineNr">1234 </span>           {[<span class="Constant">"O_n1_1"</span>, <span class="Constant">false</span>], [<span class="Constant">"O_n1_2"</span>, <span class="Constant">false</span>]},
<span id="L1235" class="LineNr">1235 </span>           {[<span class="Constant">"O_n1_1"</span>, <span class="Constant">false</span>], [<span class="Constant">"O_n1_2"</span>,  <span class="Constant">true</span>]},
<span id="L1236" class="LineNr">1236 </span>           {[<span class="Constant">"O_n1_1"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O_n1_2"</span>, <span class="Constant">false</span>]},
<span id="L1237" class="LineNr">1237 </span>           {[<span class="Constant">"O_n1_1"</span>,  <span class="Constant">true</span>], [<span class="Constant">"O_n1_2"</span>,  <span class="Constant">true</span>]},
<span id="L1238" class="LineNr">1238 </span>           {[<span class="Constant">"O_n2"</span>, <span class="Constant">false</span>]},
<span id="L1239" class="LineNr">1239 </span>           {[<span class="Constant">"O_n2"</span>,  <span class="Constant">true</span>]}
<span id="L1240" class="LineNr">1240 </span>         }, <span class="Constant">"Error: poss_rxs is incorrect."</span>);
<span id="L1241" class="LineNr">1241 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_rxs'</span>);
<span id="L1242" class="LineNr">1242 </span>};
<span id="L1243" class="LineNr">1243 </span><span class="Identifier">test_poss_rxs</span>();
<span id="L1244" class="LineNr">1244 </span>
<span id="L1245" class="LineNr">1245 </span><span class="Comment">/*</span>
<span id="L1246" class="LineNr">1246 </span><span class="Comment">test_n_disj := procedure() {</span>
<span id="L1247" class="LineNr">1247 </span><span class="Comment">  d := decision_algorithm.new();</span>
<span id="L1248" class="LineNr">1248 </span><span class="Comment">  b := causal_markov_model.new();</span>
<span id="L1249" class="LineNr">1249 </span><span class="Comment">  b.u := { 'U1' };</span>
<span id="L1250" class="LineNr">1250 </span><span class="Comment">  b.r := { ['U1', tf()] };</span>
<span id="L1251" class="LineNr">1251 </span><span class="Comment">  be := { ['U1', true] };</span>
<span id="L1252" class="LineNr">1252 </span><span class="Comment">  not_be := { ['U1', false] };</span>
<span id="L1253" class="LineNr">1253 </span><span class="Comment">  w := b;</span>
<span id="L1254" class="LineNr">1254 </span><span class="Comment">  d.cached_ref := { [be, { be, not_be }] };</span>
<span id="L1255" class="LineNr">1255 </span><span class="Comment">  assert(d.n_disj(w, b, be) == 2,</span>
<span id="L1256" class="LineNr">1256 </span><span class="Comment">         "Error: n_disj is incorrect.");</span>
<span id="L1257" class="LineNr">1257 </span><span class="Comment">  print('[ok] n_disj');</span>
<span id="L1258" class="LineNr">1258 </span>
<span id="L1259" class="LineNr">1259 </span><span class="Comment">  assert(d.n_ev_disj(w, b, not_be, be) == 1,</span>
<span id="L1260" class="LineNr">1260 </span><span class="Comment">         "Error: n_ev_disj is incorrect.");</span>
<span id="L1261" class="LineNr">1261 </span><span class="Comment">  print('[ok] n_ev_disj');</span>
<span id="L1262" class="LineNr">1262 </span>
<span id="L1263" class="LineNr">1263 </span><span class="Comment">  assert(d.spec(w, b, not_be, be) == 1/2,</span>
<span id="L1264" class="LineNr">1264 </span><span class="Comment">         "Error: spec is incorrect.");</span>
<span id="L1265" class="LineNr">1265 </span><span class="Comment">  print('[ok] spec');</span>
<span id="L1266" class="LineNr">1266 </span><span class="Comment">};</span>
<span id="L1267" class="LineNr">1267 </span><span class="Comment">test_n_disj();</span>
<span id="L1268" class="LineNr">1268 </span><span class="Comment">test_n_ev_disj := procedure() { test_n_disj(); };</span>
<span id="L1269" class="LineNr">1269 </span><span class="Comment">test_spec := procedure() { test_spec(); };</span>
<span id="L1270" class="LineNr">1270 </span><span class="Comment">*/</span>
<span id="L1271" class="LineNr">1271 </span>
<span id="L1272" class="LineNr"><a href="#da-2325" data-file="decision_algorithm" title="ltr_up_to" class="back_to_proc">&#8629;</a>1272 </span><span class="Identifier">test_ltr_up_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1273" class="LineNr">1273 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'A'</span>, <span class="Constant">3</span>) <span class="Type">==</span> { <span class="Constant">'A_1'</span>, <span class="Constant">'A_2'</span>, <span class="Constant">'A_3'</span> },
<span id="L1274" class="LineNr">1274 </span>         <span class="Constant">"Error: ltr_up_to is incorrect."</span>);
<span id="L1275" class="LineNr">1275 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] ltr_up_to'</span>);
<span id="L1276" class="LineNr">1276 </span>};
<span id="L1277" class="LineNr">1277 </span><span class="Identifier">test_ltr_up_to</span>();
<span id="L1278" class="LineNr">1278 </span>
<span id="L1279" class="LineNr"><a href="#da-2329" data-file="decision_algorithm" title="vars_up_to" class="back_to_proc">&#8629;</a>1279 </span><span class="Identifier">test_vars_up_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1280" class="LineNr">1280 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2329">vars_up_to</a>({ <span class="Constant">'A'</span>, <span class="Constant">'B'</span> }, <span class="Constant">2</span>) <span class="Type">==</span>
<span id="L1281" class="LineNr">1281 </span>           { <span class="Constant">'A_1'</span>, <span class="Constant">'A_2'</span>, <span class="Constant">'B_1'</span>, <span class="Constant">'B_2'</span> },
<span id="L1282" class="LineNr">1282 </span>         <span class="Constant">"Error: vars_up_to is incorrect."</span>);
<span id="L1283" class="LineNr">1283 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] vars_up_to'</span>);
<span id="L1284" class="LineNr">1284 </span>};
<span id="L1285" class="LineNr">1285 </span><span class="Identifier">test_vars_up_to</span>();
<span id="L1286" class="LineNr">1286 </span>
<span id="L1287" class="LineNr"><a href="#da-2350" data-file="decision_algorithm" title="expr_to_ltr_var" class="back_to_proc">&#8629;</a>1287 </span><span class="Identifier">test_expr_to_ltr_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1288" class="LineNr">1288 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2350">expr_to_ltr_var</a>(<span class="Identifier">Implies</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'U'</span>) <span class="Type">==</span> <span class="Constant">'U(Implies(A, B))'</span>,
<span id="L1289" class="LineNr">1289 </span>         <span class="Constant">"Error: expr_to_ltr_var is incorrect."</span>);
<span id="L1290" class="LineNr">1290 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] expr_to_ltr_var'</span>);
<span id="L1291" class="LineNr">1291 </span>};
<span id="L1292" class="LineNr">1292 </span><span class="Identifier">test_expr_to_ltr_var</span>();
<span id="L1293" class="LineNr">1293 </span>
<span id="L1294" class="LineNr"><a href="#da-2392" data-file="decision_algorithm" title="poss_r_z" class="back_to_proc">&#8629;</a>1294 </span><span class="Identifier">test_poss_r_z</span>  <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1295" class="LineNr">1295 </span>  poss_z_vals <span class="Statement">:=</span> { { j <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>x] } <span class="Type">:</span> x <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Constant">3</span>] };
<span id="L1296" class="LineNr">1296 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2392">poss_r_z</a>(poss_z_vals, <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2325">ltr_up_to</a>(<span class="Constant">'A'</span>, <span class="Constant">2</span>)) <span class="Type">==</span> {
<span id="L1297" class="LineNr">1297 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>}],       [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>}]},
<span id="L1298" class="LineNr">1298 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>}],       [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>}]},
<span id="L1299" class="LineNr">1299 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>}],       [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}]},
<span id="L1300" class="LineNr">1300 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>}],    [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>}]},
<span id="L1301" class="LineNr">1301 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>}],    [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>}]},
<span id="L1302" class="LineNr">1302 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>}],    [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}]},
<span id="L1303" class="LineNr">1303 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}], [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>}]},
<span id="L1304" class="LineNr">1304 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}], [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>}]},
<span id="L1305" class="LineNr">1305 </span>           {[<span class="Constant">"A_1"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}], [<span class="Constant">"A_2"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}]}},
<span id="L1306" class="LineNr">1306 </span>         <span class="Constant">"Error: poss_r_z is incorrect."</span>);
<span id="L1307" class="LineNr">1307 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_r_z '</span>);
<span id="L1308" class="LineNr">1308 </span>};
<span id="L1309" class="LineNr">1309 </span><span class="Identifier">test_poss_r_z</span>();
<span id="L1310" class="LineNr">1310 </span>
<span id="L1311" class="LineNr"><a href="#da-2387" data-file="decision_algorithm" title="poss_r_ue" class="back_to_proc">&#8629;</a>1311 </span><span class="Identifier">test_poss_r_ue</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L1312" class="LineNr">1312 </span>  u <span class="Statement">:=</span> { [<span class="Constant">'A'</span>, <span class="Constant">'U(A)'</span>], [<span class="Constant">'B'</span>, <span class="Constant">'U(B)'</span>] };
<span id="L1313" class="LineNr">1313 </span>  poss_ue_vals <span class="Statement">:=</span> <span class="Identifier">pow</span>({ j <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Constant">2</span><span class="Type">**</span><span class="Constant">2</span>] }) <span class="Type">-</span> {{}};
<span id="L1314" class="LineNr">1314 </span>  <span class="Statement">assert</span>({ {[<span class="Constant">"U(A)"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">4</span>}], [<span class="Constant">"U(B)"</span>, {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">4</span>}]},
<span id="L1315" class="LineNr">1315 </span>           {[<span class="Constant">"U(A)"</span>, {<span class="Constant">2</span>, <span class="Constant">3</span>, <span class="Constant">4</span>}], [<span class="Constant">"U(B)"</span>, {<span class="Constant">2</span>, <span class="Constant">3</span>, <span class="Constant">4</span>}]}
<span id="L1316" class="LineNr">1316 </span>         } <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#da-2441">da</a>().<a class="Identifier code-proc-link" href="#da-2387">poss_r_ue</a>(poss_ue_vals, u),
<span id="L1317" class="LineNr">1317 </span>         <span class="Constant">"Error: poss_r_ue is incorrect."</span>);
<span id="L1318" class="LineNr">1318 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_r_ue'</span>);
<span id="L1319" class="LineNr">1319 </span>};
<span id="L1320" class="LineNr">1320 </span><span class="Identifier">test_poss_r_ue</span>();
</pre>
<pre class="vimCodeElement" id="causal_markov_model"><span id="L1" class="LineNr">  1 <a title="1.1" class="back_to_li" href="#t-1-1"><i class="fas fa-list-ol"></i></a><a title="1.1.1.2" class="back_to_li" href="#t-1-1-1-2"><i class="fas fa-list-ol"></i></a></span><span class="Type">class</span> <span class="Identifier">causal_markov_model</span>(n, u, v, r, f, a, cached_cm) {
<span id="L2" class="LineNr">  2 <a title="1.1.1.2.1" class="back_to_li" href="#t-1-1-1-2-1"><i class="fas fa-list-ol"></i></a></span>  n <span class="Statement">:=</span> n; <span class="Comment">// integer number of time slices</span>
<span id="L3" class="LineNr">  3 <a title="1.1.1.2.2" class="back_to_li" href="#t-1-1-1-2-2"><i class="fas fa-list-ol"></i></a></span>  u <span class="Statement">:=</span> u; <span class="Comment">// Set of exogenous variables</span>
<span id="L4" class="LineNr">  4 </span>          <span class="Comment">//   e.g. u := { 'O' };</span>
<span id="L5" class="LineNr">  5 <a title="1.1.1.2.3" class="back_to_li" href="#t-1-1-1-2-3"><i class="fas fa-list-ol"></i></a></span>  v <span class="Statement">:=</span> v; <span class="Comment">// Set of endogenous variables</span>
<span id="L6" class="LineNr">  6 </span>          <span class="Comment">//   e.g. v := { 'F', 'L', 'ML' };</span>
<span id="L7" class="LineNr">  7 <a title="1.1.1.2.4" class="back_to_li" href="#t-1-1-1-2-4"><i class="fas fa-list-ol"></i></a></span>  r <span class="Statement">:=</span> r; <span class="Comment">// Function assigning a range of values for each variable</span>
<span id="L8" class="LineNr">  8 </span>          <span class="Comment">//   e.g. r := { [x, { false, true }] : x in u + v };</span>
<span id="L9" class="LineNr">  9 </span>  <span class="Comment">/* Higher order function from y in v to a higher order function from a</span>
<span id="L10" class="LineNr"> 10 </span><span class="Comment">     function assigning values to exogenous and endogenous vars to a value </span>
<span id="L11" class="LineNr"> 11 </span><span class="Comment">     for y.</span>
<span id="L12" class="LineNr"> 12 </span><span class="Comment">       eg f := { [y, f_y], [z, f_z], ... }</span>
<span id="L13" class="LineNr"> 13 </span><span class="Comment">         f_y := { [f_y_1, true], [f_y_2, false], ... } </span>
<span id="L14" class="LineNr"> 14 </span><span class="Comment">          f_y_1 := { [y, false], [z, false], ... }       (row in truth table)</span>
<span id="L15" class="LineNr"> 15 </span><span class="Comment">     A variable (technically, its past time slice) can also be its own parent</span>
<span id="L16" class="LineNr"> 16 </span><span class="Comment">  */</span>
<span id="L17" class="LineNr"> 17 <a title="1.1.1.2.5" class="back_to_li" href="#t-1-1-1-2-5"><i class="fas fa-list-ol"></i></a></span>  f <span class="Statement">:=</span> f;
<span id="L18" class="LineNr"> 18 </span>
<span id="L19" class="LineNr"> 19 </span>  <span class="Comment">/* A list of actual states, one for each time slice. Each actual state is a </span>
<span id="L20" class="LineNr"> 20 </span><span class="Comment">     function assigning values to cm() vars of the given time.</span>
<span id="L21" class="LineNr"> 21 </span><span class="Comment">       e.g. [ {['y_t1',true],...}, {['y_t2',false],...}, ... ] */</span>
<span id="L22" class="LineNr"> 22 <a title="1.1.1.2.6" class="back_to_li" href="#t-1-1-1-2-6"><i class="fas fa-list-ol"></i></a></span>  a <span class="Statement">:=</span> a;
<span id="L23" class="LineNr"> 23 </span>
<span id="L24" class="LineNr"> 24 </span>  <span class="Identifier">uv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L25" class="LineNr"> 25 </span>    <span class="Statement">return</span> u <span class="Type">+</span> v;
<span id="L26" class="LineNr"> 26 </span>  };
<span id="L27" class="LineNr"> 27 </span>
<span id="L28" class="LineNr"> 28 </span>  <span class="Identifier">u_t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(t) {
<span id="L29" class="LineNr"> 29 </span>    <span class="Statement">return</span> { x <span class="Type">+</span> <span class="Constant">'_t'</span> <span class="Type">+</span> t <span class="Type">:</span> x <span class="Type">in</span> u };
<span id="L30" class="LineNr"> 30 </span>  };
<span id="L31" class="LineNr"> 31 </span>  <span class="Identifier">v_t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(t) {
<span id="L32" class="LineNr"> 32 </span>    <span class="Statement">return</span> { x <span class="Type">+</span> <span class="Constant">'_t'</span> <span class="Type">+</span> t <span class="Type">:</span> x <span class="Type">in</span> v };
<span id="L33" class="LineNr"> 33 </span>  };
<span id="L34" class="LineNr"> 34 </span>  <span class="Identifier">uv_t</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(t) {
<span id="L35" class="LineNr"> 35 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#cmm-28">u_t</a>(t) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#cmm-31">v_t</a>(t);
<span id="L36" class="LineNr"> 36 </span>  };
<span id="L37" class="LineNr"> 37 </span>
<span id="L38" class="LineNr"> 38 <a title="1.1.1" class="back_to_li" href="#t-1-1-1"><i class="fas fa-list-ol"></i></a><a title="1.1.1.3" class="back_to_li" href="#t-1-1-1-3"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">cm</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L39" class="LineNr"> 39 </span>    <span class="Statement">if</span> (cached_cm <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L40" class="LineNr"> 40 </span>      cached_cm <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#cmm-45">compute_cm</a>();
<span id="L41" class="LineNr"> 41 </span>    }
<span id="L42" class="LineNr"> 42 </span>    <span class="Statement">return</span> cached_cm;
<span id="L43" class="LineNr"> 43 </span>  };
<span id="L44" class="LineNr"> 44 </span>
<span id="L45" class="LineNr"> 45 </span>    <span class="Identifier">compute_cm</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L46" class="LineNr"> 46 </span>      <span class="Statement">return</span> <span class="Identifier">causal_model</span>(<a class="Identifier code-proc-link" href="#cmm-49">cm_u</a>(), <a class="Identifier code-proc-link" href="#cmm-58">cm_v</a>(), <a class="Identifier code-proc-link" href="#cmm-63">cm_r</a>(), <a class="Identifier code-proc-link" href="#cmm-67">cm_f</a>(), <span class="Constant">om</span>);
<span id="L47" class="LineNr"> 47 </span>    };
<span id="L48" class="LineNr"> 48 </span>
<span id="L49" class="LineNr"><a href="#tcmm-25" data-file="test_causal_markov_model" title="test_cm_u" class="checkmark">&#10004;</a> 49 <a title="1.1.1.3.2" class="back_to_li" href="#t-1-1-1-3-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">cm_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L50" class="LineNr"> 50 </span>      u_ts <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#cmm-28">u_t</a>(t) <span class="Type">:</span> t <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span>n] };
<span id="L51" class="LineNr"> 51 </span>      <span class="Statement">if</span> (u_ts <span class="Type">==</span> {}) {
<span id="L52" class="LineNr"> 52 </span>        u_ts <span class="Statement">:=</span> {{}};
<span id="L53" class="LineNr"> 53 </span>      }
<span id="L54" class="LineNr"> 54 </span>      <span class="Statement">return</span> <span class="Type">+/</span> u_ts <span class="Type">+</span> <a class="Identifier code-proc-link" href="#cmm-31">v_t</a>(<span class="Constant">1</span>);
<span id="L55" class="LineNr"> 55 </span>      <span class="Comment">// Includes the first v_t since there's no previous time parents</span>
<span id="L56" class="LineNr"> 56 </span>    };
<span id="L57" class="LineNr"> 57 </span>
<span id="L58" class="LineNr"><a href="#tcmm-32" data-file="test_causal_markov_model" title="test_cm_v" class="checkmark">&#10004;</a> 58 <a title="1.1.1.3.3" class="back_to_li" href="#t-1-1-1-3-3"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">cm_v</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L59" class="LineNr"> 59 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#cmm-31">v_t</a>(t) <span class="Type">:</span> t <span class="Type">in</span> [<span class="Constant">2</span><span class="Statement">..</span>n] };
<span id="L60" class="LineNr"> 60 </span>      <span class="Comment">// Starts at 2 because the first, parentless v_t is counted in cm_u</span>
<span id="L61" class="LineNr"> 61 </span>    };
<span id="L62" class="LineNr"> 62 </span>
<span id="L63" class="LineNr"><a href="#tcmm-39" data-file="test_causal_markov_model" title="test_cm_r" class="checkmark">&#10004;</a> 63 <a title="1.1.1.3.4" class="back_to_li" href="#t-1-1-1-3-4"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">cm_r</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L64" class="LineNr"> 64 </span>      <span class="Statement">return</span> { [x, r[<a class="Identifier code-proc-link" href="#l-393">orig_var</a>(x)]] <span class="Type">:</span> x <span class="Type">in</span> <a class="Identifier code-proc-link" href="#cmm-49">cm_u</a>() <span class="Type">+</span> <a class="Identifier code-proc-link" href="#cmm-58">cm_v</a>() };
<span id="L65" class="LineNr"> 65 </span>    };
<span id="L66" class="LineNr"> 66 </span>
<span id="L67" class="LineNr"><a href="#tcmm-47" data-file="test_causal_markov_model" title="test_cm_f" class="checkmark">&#10004;</a> 67 <a title="1.1.1.3.5.2" class="back_to_li" href="#t-1-1-1-3-5-2"><i class="fas fa-list-ol"></i></a></span>    <span class="Identifier">cm_f</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L68" class="LineNr"> 68 </span>      <span class="Statement">return</span> { [x, <a class="Identifier code-proc-link" href="#cmm-71">fix_time</a>(x, f[<a class="Identifier code-proc-link" href="#l-393">orig_var</a>(x)], <a class="Identifier code-proc-link" href="#l-397">var_time</a>(x) <span class="Type">-</span> <span class="Constant">1</span>)] <span class="Type">:</span> x <span class="Type">in</span> <a class="Identifier code-proc-link" href="#cmm-58">cm_v</a>() };
<span id="L69" class="LineNr"> 69 </span>    };
<span id="L70" class="LineNr"> 70 </span>
<span id="L71" class="LineNr"> 71 </span>      <span class="Identifier">fix_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(x, f_x, t) {
<span id="L72" class="LineNr"> 72 </span>        <span class="Comment">// Add time subscript to f_x</span>
<span id="L73" class="LineNr"> 73 </span>        f_prev_t <span class="Statement">:=</span> { [<a class="Identifier code-proc-link" href="#l-403">assign_time</a>(g, t), f_x[g]] <span class="Type">:</span> g <span class="Type">in</span> <span class="Identifier">domain</span>(f_x) };
<span id="L74" class="LineNr"> 74 </span>        <span class="Comment">// Extend from one timeslice to states over all vars but x</span>
<span id="L75" class="LineNr"> 75 </span>        ext_xs <span class="Statement">:=</span> (<a class="Identifier code-proc-link" href="#cmm-49">cm_u</a>() <span class="Type">+</span> <a class="Identifier code-proc-link" href="#cmm-58">cm_v</a>()) <span class="Type">-</span> <a class="Identifier code-proc-link" href="#cmm-34">uv_t</a>(t) <span class="Type">-</span> {x}; <span class="Comment">// extended vars</span>
<span id="L76" class="LineNr"> 76 </span>        poss_ext_states <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(ext_xs, <a class="Identifier code-proc-link" href="#cmm-63">cm_r</a>()); <span class="Comment">// extended states</span>
<span id="L77" class="LineNr"> 77 </span>        <span class="Comment">// Output remains f_prev_t[prev_t_st] since it's a markov model</span>
<span id="L78" class="LineNr"> 78 </span>        <span class="Statement">return</span> <span class="Type">+/</span> { { [prev_t_st <span class="Type">+</span> ext_state, f_prev_t[prev_t_st] ]
<span id="L79" class="LineNr"> 79 </span>                      <span class="Type">:</span> ext_state <span class="Type">in</span> poss_ext_states }
<span id="L80" class="LineNr"> 80 </span>                    <span class="Type">:</span> prev_t_st <span class="Type">in</span> <span class="Identifier">domain</span>(f_prev_t)
<span id="L81" class="LineNr"> 81 </span>                  };
<span id="L82" class="LineNr"> 82 </span>      };
<span id="L83" class="LineNr"> 83 </span>
<span id="L84" class="LineNr"><a href="#tcmm-58" data-file="test_causal_markov_model" title="test_poss_states" class="checkmark">&#10004;</a> 84 </span>  <span class="Identifier">poss_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L85" class="LineNr"> 85 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(u <span class="Type">+</span> v, r);
<span id="L86" class="LineNr"> 86 </span>  };
<span id="L87" class="LineNr"> 87 </span>
<span id="L88" class="LineNr"><a href="#tcmm-70" data-file="test_causal_markov_model" title="test_poss_events" class="checkmark">&#10004;</a> 88 </span>  <span class="Identifier">poss_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L89" class="LineNr"> 89 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Constant">2</span> <span class="Type">**</span> ps <span class="Type">:</span> ps <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-289">poss_states</a>() };
<span id="L90" class="LineNr"> 90 </span>  };
<span id="L91" class="LineNr"> 91 </span>
<span id="L92" class="LineNr"><a href="#tcmm-83" data-file="test_causal_markov_model" title="test_actual_events" class="checkmark">&#10004;</a> 92 </span>  <span class="Identifier">actual_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L93" class="LineNr"> 93 </span>    <span class="Statement">return</span> <span class="Identifier">pow</span>(<a class="Identifier code-proc-link" href="#cmm-96">actual_state</a>()) <span class="Type">-</span> {{}};
<span id="L94" class="LineNr"> 94 </span>  };
<span id="L95" class="LineNr"> 95 </span>
<span id="L96" class="LineNr"><a href="#tcmm-92" data-file="test_causal_markov_model" title="test_actual_state" class="checkmark">&#10004;</a> 96 </span>  <span class="Identifier">actual_state</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L97" class="LineNr"> 97 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { actual_state <span class="Type">:</span> actual_state <span class="Type">in</span> a };
<span id="L98" class="LineNr"> 98 </span>  };
<span id="L99" class="LineNr"> 99 </span>
<span id="L100" class="LineNr">100 </span>  <span class="Comment">/* Set of all actual synchronic events, </span>
<span id="L101" class="LineNr">101 </span><span class="Comment">     i.e. those taking place at a single time. */</span>
<span id="L102" class="LineNr"><a href="#tcmm-94" data-file="test_causal_markov_model" title="test_actual_sync_events" class="checkmark">&#10004;</a>102 </span>  <span class="Identifier">actual_sync_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L103" class="LineNr">103 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Identifier">pow</span>(actual_state) <span class="Type">:</span> actual_state <span class="Type">in</span> a } <span class="Type">-</span> {{}};
<span id="L104" class="LineNr">104 </span>  };
<span id="L105" class="LineNr">105 </span>
<span id="L106" class="LineNr">106 </span>  <span class="Comment">/* Use the causal model on the first two times */</span>
<span id="L107" class="LineNr">107 </span>  <span class="Comment">// g needs to be full state?</span>
<span id="L108" class="LineNr"><a href="#tcmm-106" data-file="test_causal_markov_model" title="test_response" class="checkmark">&#10004;</a>108 </span>  <span class="Identifier">response</span> <span class="Statement">:=</span>  <span class="Type">procedure</span>(ys, g) {
<span id="L109" class="LineNr">109 </span>    g1 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-403">assign_time</a>(g, <span class="Constant">1</span>);
<span id="L110" class="LineNr">110 </span>    ys2 <span class="Statement">:=</span> { y <span class="Type">+</span> <span class="Constant">'_t'</span> <span class="Type">+</span> <span class="Constant">2</span> <span class="Type">:</span> y <span class="Type">in</span> ys };
<span id="L111" class="LineNr">111 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-409">drop_time</a>(<a class="Identifier code-proc-link" href="#cmm-38">cm</a>().<a class="Identifier code-proc-link" href="#cmm-108">response</a>(ys2, g1));
<span id="L112" class="LineNr">112 </span>  };
<span id="L113" class="LineNr">113 </span>
<span id="L114" class="LineNr">114 </span>  <span class="Comment">/* Form the full state transition table and convert it to a string along with</span>
<span id="L115" class="LineNr">115 </span><span class="Comment">     the vars and ranges. */</span>
<span id="L116" class="LineNr"><a href="#tcmm-114" data-file="test_causal_markov_model" title="test_t_to_str" class="checkmark">&#10004;</a>116 <a title="1.2.1.3.1" class="back_to_li" href="#t-1-2-1-3-1"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">t_to_str</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L117" class="LineNr">117 </span>    tt <span class="Statement">:=</span> { [ps, <a class="Identifier code-proc-link" href="#cmm-108">response</a>(v, ps)] <span class="Type">:</span> ps <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-289">poss_states</a>() };
<span id="L118" class="LineNr">118 </span>    <span class="Statement">return</span> <span class="Identifier">str</span>([tt, n, u, v, r]);
<span id="L119" class="LineNr">119 </span>  };
<span id="L120" class="LineNr">120 </span>
<span id="L121" class="LineNr">121 </span>  <span class="Statement">static</span> {
<span id="L122" class="LineNr">122 </span>    <span class="Identifier">new</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L123" class="LineNr">123 </span>      <span class="Statement">return</span> <span class="Identifier">causal_markov_model</span>(<span class="Constant">0</span>, {}, {}, {}, {}, [], <span class="Constant">om</span>);
<span id="L124" class="LineNr">124 </span>    };
<span id="L125" class="LineNr">125 </span>  }
<span id="L126" class="LineNr">126 </span>}
</pre>
<pre class="vimCodeElement test_code" id="test_causal_markov_model"><span id="L1" class="LineNr">  1 </span><span class="Identifier">print</span>(<span class="Constant">"</span><span class="Special">\n</span><span class="Constant">Testing Causal Markov Model"</span>);
<span id="L2" class="LineNr">  2 </span><span class="Identifier">print</span>(  <span class="Constant">"==========================="</span>);
<span id="L3" class="LineNr">  3 </span>
<span id="L4" class="LineNr">  4 </span><span class="Identifier">cmm1</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L5" class="LineNr">  5 </span>  cmm <span class="Statement">:=</span> causal_markov_model.<a class="Identifier code-proc-link" href="#da-2432">new</a>();
<span id="L6" class="LineNr">  6 </span>  cmm.n <span class="Statement">:=</span> <span class="Constant">3</span>;
<span id="L7" class="LineNr">  7 </span>  cmm.u <span class="Statement">:=</span> { <span class="Constant">'U'</span> };
<span id="L8" class="LineNr">  8 </span>  cmm.v <span class="Statement">:=</span> { <span class="Constant">'V'</span> };
<span id="L9" class="LineNr">  9 </span>  cmm.r <span class="Statement">:=</span> { [<span class="Constant">'U'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'V'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] };
<span id="L10" class="LineNr"> 10 </span>  cmm.f <span class="Statement">:=</span> { <span class="Comment">// eg v_t2 = U_t1 xor V_t1</span>
<span id="L11" class="LineNr"> 11 </span>    [<span class="Constant">'V'</span>, { [{ [<span class="Constant">'U'</span>, <span class="Constant">false</span>], [<span class="Constant">'V'</span>, <span class="Constant">false</span>] }, <span class="Constant">false</span>],
<span id="L12" class="LineNr"> 12 </span>            [{ [<span class="Constant">'U'</span>, <span class="Constant">false</span>], [<span class="Constant">'V'</span>,  <span class="Constant">true</span>] },  <span class="Constant">true</span>],
<span id="L13" class="LineNr"> 13 </span>            [{ [<span class="Constant">'U'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V'</span>, <span class="Constant">false</span>] },  <span class="Constant">true</span>],
<span id="L14" class="LineNr"> 14 </span>            [{ [<span class="Constant">'U'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V'</span>,  <span class="Constant">true</span>] }, <span class="Constant">false</span>]
<span id="L15" class="LineNr"> 15 </span>          }]
<span id="L16" class="LineNr"> 16 </span>  };
<span id="L17" class="LineNr"> 17 </span>  cmm.a <span class="Statement">:=</span> {
<span id="L18" class="LineNr"> 18 </span>    {[<span class="Constant">'U_t1'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_t1'</span>, <span class="Constant">false</span>]},
<span id="L19" class="LineNr"> 19 </span>    {[<span class="Constant">'U_t2'</span>,  <span class="Constant">true</span>], [<span class="Constant">'V_t2'</span>,  <span class="Constant">true</span>]},
<span id="L20" class="LineNr"> 20 </span>    {[<span class="Constant">'U_t3'</span>, <span class="Constant">false</span>], [<span class="Constant">'V_t3'</span>,  <span class="Constant">true</span>]}
<span id="L21" class="LineNr"> 21 </span>  };
<span id="L22" class="LineNr"> 22 </span>  <span class="Statement">return</span> cmm;
<span id="L23" class="LineNr"> 23 </span>};
<span id="L24" class="LineNr"> 24 </span>
<span id="L25" class="LineNr"><a href="#cmm-49" data-file="causal_markov_model" title="cm_u" class="back_to_proc">&#8629;</a> 25 </span><span class="Identifier">test_cm_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L26" class="LineNr"> 26 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-49">cm_u</a>() <span class="Type">==</span> { <span class="Constant">'U_t1'</span>, <span class="Constant">'U_t2'</span>, <span class="Constant">'U_t3'</span>, <span class="Constant">'V_t1'</span> },
<span id="L27" class="LineNr"> 27 </span>         <span class="Constant">"Error: cm_u is incorrect."</span>);
<span id="L28" class="LineNr"> 28 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] cm_u'</span>);
<span id="L29" class="LineNr"> 29 </span>};
<span id="L30" class="LineNr"> 30 </span><span class="Identifier">test_cm_u</span>();
<span id="L31" class="LineNr"> 31 </span>
<span id="L32" class="LineNr"><a href="#cmm-58" data-file="causal_markov_model" title="cm_v" class="back_to_proc">&#8629;</a> 32 </span><span class="Identifier">test_cm_v</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L33" class="LineNr"> 33 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-58">cm_v</a>() <span class="Type">==</span> { <span class="Constant">'V_t2'</span>, <span class="Constant">'V_t3'</span> },
<span id="L34" class="LineNr"> 34 </span>         <span class="Constant">"Error: cm_v is incorrect."</span>);
<span id="L35" class="LineNr"> 35 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] cm_v'</span>);
<span id="L36" class="LineNr"> 36 </span>};
<span id="L37" class="LineNr"> 37 </span><span class="Identifier">test_cm_v</span>();
<span id="L38" class="LineNr"> 38 </span>
<span id="L39" class="LineNr"><a href="#cmm-63" data-file="causal_markov_model" title="cm_r" class="back_to_proc">&#8629;</a> 39 </span><span class="Identifier">test_cm_r</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L40" class="LineNr"> 40 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-63">cm_r</a>() <span class="Type">==</span> { [<span class="Constant">'U_t1'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'U_t2'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'U_t3'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()],
<span id="L41" class="LineNr"> 41 </span>                            [<span class="Constant">'V_t1'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'V_t2'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'V_t3'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] },
<span id="L42" class="LineNr"> 42 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L43" class="LineNr"> 43 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] cm_r'</span>);
<span id="L44" class="LineNr"> 44 </span>};
<span id="L45" class="LineNr"> 45 </span><span class="Identifier">test_cm_r</span>();
<span id="L46" class="LineNr"> 46 </span>
<span id="L47" class="LineNr"><a href="#cmm-67" data-file="causal_markov_model" title="cm_f" class="back_to_proc">&#8629;</a> 47 </span><span class="Identifier">test_cm_f</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L48" class="LineNr"> 48 </span>  <span class="Statement">assert</span>( { [ { [<span class="Constant">"U_t1"</span>, <span class="Constant">false</span>], [<span class="Constant">"U_t2"</span>, <span class="Constant">false</span>], [<span class="Constant">"U_t3"</span>, <span class="Constant">false</span>],
<span id="L49" class="LineNr"> 49 </span>                [<span class="Constant">"V_t1"</span>, <span class="Constant">false</span>],                  [<span class="Constant">"V_t3"</span>, <span class="Constant">false</span>]  }, <span class="Constant">false</span>],
<span id="L50" class="LineNr"> 50 </span>            [ { [<span class="Constant">"U_t1"</span>, <span class="Constant">false</span>], [<span class="Constant">"U_t2"</span>, <span class="Constant">false</span>], [<span class="Constant">"U_t3"</span>, <span class="Constant">false</span>],
<span id="L51" class="LineNr"> 51 </span>                [<span class="Constant">"V_t1"</span>, <span class="Constant">false</span>],                  [<span class="Constant">"V_t3"</span>,  <span class="Constant">true</span>]  }, <span class="Constant">false</span>]
<span id="L52" class="LineNr"> 52 </span>          } <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-67">cm_f</a>()[<span class="Constant">'V_t2'</span>],
<span id="L53" class="LineNr"> 53 </span>          <span class="Constant">"Error: cm_f is incorrect."</span>);
<span id="L54" class="LineNr"> 54 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] cm_f'</span>);
<span id="L55" class="LineNr"> 55 </span>};
<span id="L56" class="LineNr"> 56 </span><span class="Identifier">test_cm_f</span>();
<span id="L57" class="LineNr"> 57 </span>
<span id="L58" class="LineNr"><a href="#cmm-84" data-file="causal_markov_model" title="poss_states" class="back_to_proc">&#8629;</a> 58 </span><span class="Identifier">test_poss_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L59" class="LineNr"> 59 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#da-289">poss_states</a>() <span class="Type">==</span> {
<span id="L60" class="LineNr"> 60 </span>           { [<span class="Constant">"U"</span>, <span class="Constant">false</span>], [<span class="Constant">"V"</span>, <span class="Constant">false</span>] },
<span id="L61" class="LineNr"> 61 </span>           { [<span class="Constant">"U"</span>, <span class="Constant">false</span>], [<span class="Constant">"V"</span>,  <span class="Constant">true</span>] },
<span id="L62" class="LineNr"> 62 </span>           { [<span class="Constant">"U"</span>,  <span class="Constant">true</span>], [<span class="Constant">"V"</span>, <span class="Constant">false</span>] },
<span id="L63" class="LineNr"> 63 </span>           { [<span class="Constant">"U"</span>,  <span class="Constant">true</span>], [<span class="Constant">"V"</span>,  <span class="Constant">true</span>] }
<span id="L64" class="LineNr"> 64 </span>         },
<span id="L65" class="LineNr"> 65 </span>         <span class="Constant">"Error: poss_states is incorrect."</span>);
<span id="L66" class="LineNr"> 66 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_states'</span>);
<span id="L67" class="LineNr"> 67 </span>};
<span id="L68" class="LineNr"> 68 </span><span class="Identifier">test_poss_states</span>();
<span id="L69" class="LineNr"> 69 </span>
<span id="L70" class="LineNr"><a href="#cmm-88" data-file="causal_markov_model" title="poss_events" class="back_to_proc">&#8629;</a> 70 </span><span class="Identifier">test_poss_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L71" class="LineNr"> 71 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-88">poss_events</a>() <span class="Type">==</span> { {},
<span id="L72" class="LineNr"> 72 </span>           {[<span class="Constant">"U"</span>, <span class="Constant">false</span>]}, {[<span class="Constant">"U"</span>, <span class="Constant">true</span>]}, {[<span class="Constant">"V"</span>, <span class="Constant">false</span>]}, {[<span class="Constant">"V"</span>, <span class="Constant">true</span>]},
<span id="L73" class="LineNr"> 73 </span>           {[<span class="Constant">"U"</span>, <span class="Constant">false</span>], [<span class="Constant">"V"</span>, <span class="Constant">false</span>]},
<span id="L74" class="LineNr"> 74 </span>           {[<span class="Constant">"U"</span>, <span class="Constant">false</span>], [<span class="Constant">"V"</span>,  <span class="Constant">true</span>]},
<span id="L75" class="LineNr"> 75 </span>           {[<span class="Constant">"U"</span>,  <span class="Constant">true</span>], [<span class="Constant">"V"</span>, <span class="Constant">false</span>]},
<span id="L76" class="LineNr"> 76 </span>           {[<span class="Constant">"U"</span>,  <span class="Constant">true</span>], [<span class="Constant">"V"</span>,  <span class="Constant">true</span>]}
<span id="L77" class="LineNr"> 77 </span>         },
<span id="L78" class="LineNr"> 78 </span>         <span class="Constant">"Error: poss_events is incorrect."</span>);
<span id="L79" class="LineNr"> 79 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] poss_events'</span>);
<span id="L80" class="LineNr"> 80 </span>};
<span id="L81" class="LineNr"> 81 </span><span class="Identifier">test_poss_events</span>();
<span id="L82" class="LineNr"> 82 </span>
<span id="L83" class="LineNr"><a href="#cmm-92" data-file="causal_markov_model" title="actual_events" class="back_to_proc">&#8629;</a> 83 </span><span class="Identifier">test_actual_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L84" class="LineNr"> 84 </span>  <span class="Statement">assert</span>(<span class="Comment">// test a random event</span>
<span id="L85" class="LineNr"> 85 </span>         { [<span class="Constant">"U_t2"</span>, <span class="Constant">true</span>], [<span class="Constant">"U_t3"</span>, <span class="Constant">false</span>], [<span class="Constant">"V_t1"</span>, <span class="Constant">false</span>], [<span class="Constant">"V_t2"</span>, <span class="Constant">true</span>]
<span id="L86" class="LineNr"> 86 </span>         } <span class="Type">in</span> <a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-92">actual_events</a>(),
<span id="L87" class="LineNr"> 87 </span>         <span class="Constant">"Error: actual_events is incorrect."</span>);
<span id="L88" class="LineNr"> 88 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] actual_events'</span>);
<span id="L89" class="LineNr"> 89 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] actual_state'</span>);
<span id="L90" class="LineNr"> 90 </span>};
<span id="L91" class="LineNr"> 91 </span><span class="Identifier">test_actual_events</span>();
<span id="L92" class="LineNr"><a href="#cmm-96" data-file="causal_markov_model" title="actual_state" class="back_to_proc">&#8629;</a> 92 </span><span class="Identifier">test_actual_state</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tcmm-92">test_actual_state</a>(); };
<span id="L93" class="LineNr"> 93 </span>
<span id="L94" class="LineNr"><a href="#cmm-102" data-file="causal_markov_model" title="actual_sync_events" class="back_to_proc">&#8629;</a> 94 </span><span class="Identifier">test_actual_sync_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L95" class="LineNr"> 95 </span>  <span class="Statement">assert</span>(<span class="Comment">// test some random events</span>
<span id="L96" class="LineNr"> 96 </span>         <span class="Type">!</span>({ [<span class="Constant">"U_t2"</span>, <span class="Constant">true</span>], [<span class="Constant">"U_t3"</span>, <span class="Constant">false</span>], [<span class="Constant">"V_t1"</span>, <span class="Constant">false</span>], [<span class="Constant">"V_t2"</span>, <span class="Constant">true</span>]
<span id="L97" class="LineNr"> 97 </span>           } <span class="Type">in</span> <a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-102">actual_sync_events</a>()) <span class="Type">&amp;&amp;</span>
<span id="L98" class="LineNr"> 98 </span>         { {[<span class="Constant">'U_t2'</span>, <span class="Constant">true</span>]}, {[<span class="Constant">'U_t3'</span>,<span class="Constant">false</span>], [<span class="Constant">'V_t3'</span>,<span class="Constant">true</span>]}
<span id="L99" class="LineNr"> 99 </span>           } <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-102">actual_sync_events</a>() <span class="Type">&amp;&amp;</span>
<span id="L100" class="LineNr">100 </span>         <span class="Type">!</span>({[<span class="Constant">'U_t1'</span>, <span class="Constant">false</span>]} <span class="Type">in</span> <a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-102">actual_sync_events</a>()),
<span id="L101" class="LineNr">101 </span>         <span class="Constant">"Error: actual_sync_events is incorrect."</span>);
<span id="L102" class="LineNr">102 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] actual_sync_events'</span>);
<span id="L103" class="LineNr">103 </span>};
<span id="L104" class="LineNr">104 </span><span class="Identifier">test_actual_sync_events</span>();
<span id="L105" class="LineNr">105 </span>
<span id="L106" class="LineNr"><a href="#cmm-108" data-file="causal_markov_model" title="response" class="back_to_proc">&#8629;</a>106 </span><span class="Identifier">test_response</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L107" class="LineNr">107 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-108">response</a>({<span class="Constant">'V'</span>}, {[<span class="Constant">'U'</span>, <span class="Constant">true</span>], [<span class="Constant">'V'</span>, <span class="Constant">false</span>]})[<span class="Constant">'V'</span>] <span class="Type">==</span> <span class="Constant">true</span> <span class="Type">&amp;&amp;</span>
<span id="L108" class="LineNr">108 </span>         <span class="Identifier">cmm1</span>().<a class="Identifier code-proc-link" href="#cmm-108">response</a>({<span class="Constant">'V'</span>}, {[<span class="Constant">'U'</span>, <span class="Constant">true</span>], [<span class="Constant">'V'</span>,  <span class="Constant">true</span>]})[<span class="Constant">'V'</span>] <span class="Type">==</span> <span class="Constant">false</span>,
<span id="L109" class="LineNr">109 </span>         <span class="Constant">"Error: response is incorrect."</span>);
<span id="L110" class="LineNr">110 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] response'</span>);
<span id="L111" class="LineNr">111 </span>};
<span id="L112" class="LineNr">112 </span><span class="Identifier">test_response</span>();
<span id="L113" class="LineNr">113 </span>
<span id="L114" class="LineNr"><a href="#cmm-116" data-file="causal_markov_model" title="t_to_str" class="back_to_proc">&#8629;</a>114 </span><span class="Identifier">test_t_to_str</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L115" class="LineNr">115 </span>  <span class="Statement">assert</span>(<span class="Identifier">eval</span>(<a class="Identifier code-proc-link" href="#tcmm-4">cmm1</a>().<a class="Identifier code-proc-link" href="#cmm-116">t_to_str</a>()) <span class="Type">==</span> [
<span id="L116" class="LineNr">116 </span>           <span class="Comment">// tt</span>
<span id="L117" class="LineNr">117 </span>           { [{[<span class="Constant">"U"</span>, <span class="Constant">false</span>], [<span class="Constant">"V"</span>, <span class="Constant">false</span>]}, {[<span class="Constant">"V"</span>, <span class="Constant">false</span>]}],
<span id="L118" class="LineNr">118 </span>             [{[<span class="Constant">"U"</span>, <span class="Constant">false</span>], [<span class="Constant">"V"</span>,  <span class="Constant">true</span>]}, {[<span class="Constant">"V"</span>,  <span class="Constant">true</span>]}],
<span id="L119" class="LineNr">119 </span>             [{[<span class="Constant">"U"</span>,  <span class="Constant">true</span>], [<span class="Constant">"V"</span>, <span class="Constant">false</span>]}, {[<span class="Constant">"V"</span>,  <span class="Constant">true</span>]}],
<span id="L120" class="LineNr">120 </span>             [{[<span class="Constant">"U"</span>,  <span class="Constant">true</span>], [<span class="Constant">"V"</span>,  <span class="Constant">true</span>]}, {[<span class="Constant">"V"</span>, <span class="Constant">false</span>]}] },
<span id="L121" class="LineNr">121 </span>           <span class="Constant">3</span>, <span class="Comment">// n</span>
<span id="L122" class="LineNr">122 </span>           {<span class="Constant">"U"</span>},
<span id="L123" class="LineNr">123 </span>           {<span class="Constant">"V"</span>},
<span id="L124" class="LineNr">124 </span>           {[<span class="Constant">"U"</span>, {<span class="Constant">false</span>, <span class="Constant">true</span>}], [<span class="Constant">"V"</span>, {<span class="Constant">false</span>, <span class="Constant">true</span>}]} <span class="Comment">// r</span>
<span id="L125" class="LineNr">125 </span>         ],
<span id="L126" class="LineNr">126 </span>         <span class="Constant">"Error: t_to_str is incorrect."</span>);
<span id="L127" class="LineNr">127 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] t_to_str'</span>);
<span id="L128" class="LineNr">128 </span>};
<span id="L129" class="LineNr">129 </span><span class="Identifier">test_t_to_str</span>();
</pre>
<pre class="vimCodeElement" id="causal_model"><span id="L1" class="LineNr">  1 <a title="1.1.1.1" class="back_to_li" href="#t-1-1-1-1"><i class="fas fa-list-ol"></i></a></span><span class="Comment">/* Adapted from Judea Pearl's Causal Models</span>
<span id="L2" class="LineNr">  2 </span><span class="Comment">     e.g. Pearl, Judea. Causes and Explanations: A Structural-Model Approach</span>
<span id="L3" class="LineNr">  3 </span><span class="Comment">          <a href="http://ftp.cs.ucla.edu/pub/stat_ser/R266-part1.pdf" target="_blank">http://ftp.cs.ucla.edu/pub/stat_ser/R266-part1.pdf</a></span>
<span id="L4" class="LineNr">  4 </span><span class="Comment">*/</span>
<span id="L5" class="LineNr">  5 <a title="1.1.1.1.1" class="back_to_li" href="#t-1-1-1-1-1"><i class="fas fa-list-ol"></i></a></span><span class="Type">class</span> <span class="Identifier">causal_model</span>(u, v, r, f, cached_poss_states) {
<span id="L6" class="LineNr">  6 <a title="1.1.1.1.1.1" class="back_to_li" href="#t-1-1-1-1-1-1"><i class="fas fa-list-ol"></i></a></span>  u <span class="Statement">:=</span> u; <span class="Comment">// Set of exogenous variables</span>
<span id="L7" class="LineNr">  7 </span>          <span class="Comment">//   e.g. u := { 'O' };</span>
<span id="L8" class="LineNr">  8 <a title="1.1.1.1.1.2" class="back_to_li" href="#t-1-1-1-1-1-2"><i class="fas fa-list-ol"></i></a></span>  v <span class="Statement">:=</span> v; <span class="Comment">// Set of endogenous variables</span>
<span id="L9" class="LineNr">  9 </span>          <span class="Comment">//   e.g. v := { 'F', 'L', 'ML' };</span>
<span id="L10" class="LineNr"> 10 <a title="1.1.1.1.1.3" class="back_to_li" href="#t-1-1-1-1-1-3"><i class="fas fa-list-ol"></i></a></span>  r <span class="Statement">:=</span> r; <span class="Comment">// Function assigning a range of values for each variable</span>
<span id="L11" class="LineNr"> 11 </span>          <span class="Comment">//   e.g. r := { [x, { false, true }] : x in u + v };</span>
<span id="L12" class="LineNr"> 12 </span>  <span class="Comment">/* Higher order function from y in v to a higher order function from a</span>
<span id="L13" class="LineNr"> 13 </span><span class="Comment">     function assigning values to exogenous and other endogenous vars to a </span>
<span id="L14" class="LineNr"> 14 </span><span class="Comment">     value for y.</span>
<span id="L15" class="LineNr"> 15 </span><span class="Comment">       eg f := { [y, f_y], [z, f_z], ... }</span>
<span id="L16" class="LineNr"> 16 </span><span class="Comment">            f_y := { [f_y_1, true], [f_y_2, false], ... } // rows in truth table</span>
<span id="L17" class="LineNr"> 17 </span><span class="Comment">              f_y_1 := { [x, false], [z, false], ... }</span>
<span id="L18" class="LineNr"> 18 </span><span class="Comment">  */</span>
<span id="L19" class="LineNr"> 19 <a title="1.1.1.1.1.4" class="back_to_li" href="#t-1-1-1-1-1-4"><i class="fas fa-list-ol"></i></a></span>  f <span class="Statement">:=</span> f;
<span id="L20" class="LineNr"> 20 </span>
<span id="L21" class="LineNr"> 21 </span>  <span class="Identifier">uv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L22" class="LineNr"> 22 </span>    <span class="Statement">return</span> u <span class="Type">+</span> v;
<span id="L23" class="LineNr"> 23 </span>  };
<span id="L24" class="LineNr"> 24 </span>
<span id="L25" class="LineNr"> 25 </span>  <span class="Comment">/* Takes an assignment of values to endogenous variables and returns a </span>
<span id="L26" class="LineNr"> 26 </span><span class="Comment">     causal submodel. See 7.12 Pearl's Causality book.  */</span>
<span id="L27" class="LineNr"><a href="#tcm-39" data-file="test_causal_model" title="test_effect_of_do" class="checkmark">&#10004;</a> 27 <a title="1.1.1.1.1.5.1" class="back_to_li" href="#t-1-1-1-1-1-5-1"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">effect_of_do</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(g) {
<span id="L28" class="LineNr"> 28 </span>    h <span class="Statement">:=</span> { [y, f[y]] <span class="Type">:</span> y <span class="Type">in</span> v <span class="Type">|</span> <span class="Type">!</span>(y <span class="Type">in</span> <span class="Identifier">domain</span>(g)) } <span class="Type">+</span>
<span id="L29" class="LineNr"> 29 </span>         { [x, <span class="Identifier">i_proc_to_func</span>(x, <span class="Type">procedure</span>(h) {
<span id="L30" class="LineNr"> 30 </span>                                   <span class="Statement">return</span> g[x];
<span id="L31" class="LineNr"> 31 </span>                                 })] <span class="Type">:</span> x <span class="Type">in</span> <span class="Identifier">domain</span>(g) };
<span id="L32" class="LineNr"> 32 </span>    <span class="Statement">return</span> <span class="Identifier">causal_model</span>(u, v, r, h, <span class="Constant">om</span>);
<span id="L33" class="LineNr"> 33 </span>  };
<span id="L34" class="LineNr"> 34 </span>
<span id="L35" class="LineNr"> 35 </span>  <span class="Comment">/* Takes a set of variables ys and an assignment of values g to endogenous </span>
<span id="L36" class="LineNr"> 36 </span><span class="Comment">     and exogenous variables and returns an assignment of values to ys */</span>
<span id="L37" class="LineNr"><a href="#tcm-55" data-file="test_causal_model" title="test_response" class="checkmark">&#10004;</a> 37 <a title="1.1.1.1.1.5" class="back_to_li" href="#t-1-1-1-1-1-5"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">response</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ys, g) {
<span id="L38" class="LineNr"> 38 </span>    sm <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#cm-27">effect_of_do</a>(g);
<span id="L39" class="LineNr"> 39 </span>    result <span class="Statement">:=</span> { [y, sm.<a class="Identifier code-proc-link" href="#cm-45">solve_for</a>(y, g)] <span class="Type">:</span> y <span class="Type">in</span> ys };
<span id="L40" class="LineNr"> 40 </span>    <span class="Statement">return</span> result;
<span id="L41" class="LineNr"> 41 </span>  };
<span id="L42" class="LineNr"> 42 </span>
<span id="L43" class="LineNr"> 43 </span>  <span class="Comment">/* Takes a variable y and an assignment of values g to exogenous variables </span>
<span id="L44" class="LineNr"> 44 </span><span class="Comment">     and returns a value for y */</span>
<span id="L45" class="LineNr"> 45 <a title="1.1.1.1.1.5.2" class="back_to_li" href="#t-1-1-1-1-1-5-2"><i class="fas fa-list-ol"></i></a></span>  <span class="Identifier">solve_for</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y, g) {
<span id="L46" class="LineNr"> 46 </span>    g <span class="Statement">:=</span> { [x, g[x]] <span class="Type">:</span> x <span class="Type">in</span> <span class="Identifier">domain</span>(g) <span class="Type">|</span> x <span class="Type">in</span> u };
<span id="L47" class="LineNr"> 47 </span>    <span class="Statement">if</span> (y <span class="Type">in</span> u) {
<span id="L48" class="LineNr"> 48 </span>      <span class="Statement">return</span> g[u];
<span id="L49" class="LineNr"> 49 </span>    } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Type">#</span><a class="Identifier code-proc-link" href="#da-197">parents</a>(y) <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L50" class="LineNr"> 50 </span>      <span class="Statement">return</span> <span class="Identifier">last</span>(<span class="Identifier">first</span>(f[y]));
<span id="L51" class="LineNr"> 51 </span>    } <span class="Statement">else</span> { <span class="Comment">// y in v</span>
<span id="L52" class="LineNr"> 52 </span>      <span class="Comment">// todo: sometimes a conflict? </span>
<span id="L53" class="LineNr"> 53 </span>      h <span class="Statement">:=</span> g <span class="Type">+</span> { <span class="Type">procedure</span>() {
<span id="L54" class="LineNr"> 54 </span>                   <span class="Statement">if</span> (z <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-197">parents</a>(y)) {
<span id="L55" class="LineNr"> 55 </span>                     <span class="Statement">return</span> [z, <a class="Identifier code-proc-link" href="#cm-45">solve_for</a>(z, g)];
<span id="L56" class="LineNr"> 56 </span>                   } <span class="Statement">else</span> { <span class="Comment">// doesn't matter, pick first</span>
<span id="L57" class="LineNr"> 57 </span>                     <span class="Statement">return</span> [z, <span class="Identifier">first</span>(r[z])];
<span id="L58" class="LineNr"> 58 </span>                   }
<span id="L59" class="LineNr"> 59 </span>                 }() <span class="Type">:</span> z <span class="Type">in</span> (u <span class="Type">+</span> v) <span class="Type">-</span> <span class="Identifier">domain</span>(g) <span class="Type">|</span> z <span class="Type">!=</span> y };
<span id="L60" class="LineNr"> 60 </span>      <span class="Statement">return</span> f[y][h];
<span id="L61" class="LineNr"> 61 </span>    }
<span id="L62" class="LineNr"> 62 </span>  };
<span id="L63" class="LineNr"> 63 </span>
<span id="L64" class="LineNr"> 64 </span>  <span class="Comment">// Takes a variable and returns its parents</span>
<span id="L65" class="LineNr"><a href="#tcm-50" data-file="test_causal_model" title="test_parents" class="checkmark">&#10004;</a> 65 </span>  <span class="Identifier">parents</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y) {
<span id="L66" class="LineNr"> 66 </span>    <span class="Statement">return</span> { z <span class="Type">:</span> z <span class="Type">in</span> u <span class="Type">+</span> v <span class="Type">|</span> z <span class="Type">!=</span> y <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#cm-72">is_nec_parent_of</a>(z, y) };
<span id="L67" class="LineNr"> 67 </span>  };
<span id="L68" class="LineNr"> 68 </span>
<span id="L69" class="LineNr"> 69 </span>    <span class="Comment">/* Check whether there exists an assignment of values to the other </span>
<span id="L70" class="LineNr"> 70 </span><span class="Comment">       variables such that there are still different values of y depending </span>
<span id="L71" class="LineNr"> 71 </span><span class="Comment">       on values of z.  */</span>
<span id="L72" class="LineNr"> 72 </span>    <span class="Identifier">is_nec_parent_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(z, y) {
<span id="L73" class="LineNr"> 73 </span>      xs <span class="Statement">:=</span> {x <span class="Type">:</span> x <span class="Type">in</span> u <span class="Type">+</span> v <span class="Type">|</span> x <span class="Type">!=</span> y <span class="Type">&amp;&amp;</span> x <span class="Type">!=</span> z}; <span class="Comment">// all other variables but z</span>
<span id="L74" class="LineNr"> 74 </span>      g_xs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(xs, r);
<span id="L75" class="LineNr"> 75 </span>      <span class="Statement">return</span> <span class="Type">exists</span>(g_x <span class="Type">in</span> g_xs <span class="Type">|</span> <a class="Identifier code-proc-link" href="#cm-78">values_diff</a>(g_x, y, z));
<span id="L76" class="LineNr"> 76 </span>    };
<span id="L77" class="LineNr"> 77 </span>
<span id="L78" class="LineNr"> 78 </span>    <span class="Identifier">values_diff</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(g_x, y, z) {
<span id="L79" class="LineNr"> 79 </span>      vals <span class="Statement">:=</span> { f[y][ g_x <span class="Type">+</span> {[z,r_i]} ] <span class="Type">:</span> r_i <span class="Type">in</span> r[z] };
<span id="L80" class="LineNr"> 80 </span>      <span class="Statement">return</span> <span class="Type">#</span>vals <span class="Type">&gt;</span> <span class="Constant">1</span>;
<span id="L81" class="LineNr"> 81 </span>    };
<span id="L82" class="LineNr"> 82 </span>
<span id="L83" class="LineNr"> 83 </span>  <span class="Comment">/* Instance method shorthands for call to static version */</span>
<span id="L84" class="LineNr"> 84 </span>  <span class="Identifier">i_proc_to_func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y, p) {
<span id="L85" class="LineNr"> 85 </span>    <span class="Statement">return</span> causal_model.<a class="Identifier code-proc-link" href="#cm-121">proc_to_func</a>(y, u, v, r, p);
<span id="L86" class="LineNr"> 86 </span>  };
<span id="L87" class="LineNr"> 87 </span>
<span id="L88" class="LineNr"> 88 </span>  <span class="Identifier">poss_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L89" class="LineNr"> 89 </span>    <span class="Statement">if</span> (cached_poss_states <span class="Type">==</span> <span class="Constant">om</span>) {
<span id="L90" class="LineNr"> 90 </span>      cached_poss_states <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#cm-95">compute_poss_states</a>();
<span id="L91" class="LineNr"> 91 </span>    }
<span id="L92" class="LineNr"> 92 </span>    <span class="Statement">return</span> cached_poss_states;
<span id="L93" class="LineNr"> 93 </span>  };
<span id="L94" class="LineNr"> 94 </span>
<span id="L95" class="LineNr"> 95 </span>    <span class="Identifier">compute_poss_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L96" class="LineNr"> 96 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>(u <span class="Type">+</span> v, r);
<span id="L97" class="LineNr"> 97 </span>    };
<span id="L98" class="LineNr"> 98 </span>
<span id="L99" class="LineNr"> 99 </span>  <span class="Identifier">poss_events</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>() {
<span id="L100" class="LineNr">100 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Identifier">pow</span>(ps) <span class="Type">:</span> ps <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-289">poss_states</a>() };
<span id="L101" class="LineNr">101 </span>  };
<span id="L102" class="LineNr">102 </span>
<span id="L103" class="LineNr">103 </span>  <span class="Identifier">sorted_v</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L104" class="LineNr">104 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>( [y <span class="Type">:</span> y <span class="Type">in</span> v],
<span id="L105" class="LineNr">105 </span>                      <span class="Type">procedure</span>(y, z) { <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#cm-108">depth</a>(y) <span class="Type">&lt;</span> <a class="Identifier code-proc-link" href="#cm-108">depth</a>(z); } );
<span id="L106" class="LineNr">106 </span>  };
<span id="L107" class="LineNr">107 </span>
<span id="L108" class="LineNr">108 </span>    <span class="Identifier">depth</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y) {
<span id="L109" class="LineNr">109 </span>      <span class="Statement">if</span> (y <span class="Type">in</span> u) {
<span id="L110" class="LineNr">110 </span>        <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L111" class="LineNr">111 </span>      } <span class="Statement">else</span> {
<span id="L112" class="LineNr">112 </span>        <span class="Statement">return</span> <span class="Constant">1</span> <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-15">max</a>({ <a class="Identifier code-proc-link" href="#cm-108">depth</a>(z) <span class="Type">:</span> z <span class="Type">in</span> <a class="Identifier code-proc-link" href="#da-197">parents</a>(y) });
<span id="L113" class="LineNr">113 </span>      }
<span id="L114" class="LineNr">114 </span>    };
<span id="L115" class="LineNr">115 </span>
<span id="L116" class="LineNr">116 </span>  <span class="Statement">static</span> {
<span id="L117" class="LineNr">117 </span>    <span class="Comment">/* Helper method that takes an endogenous variable y, &amp; u, v, r and a </span>
<span id="L118" class="LineNr">118 </span><span class="Comment">       procedure and returns a function. The procedure should take an </span>
<span id="L119" class="LineNr">119 </span><span class="Comment">       assignment of values to exogenous variables and other endogenous </span>
<span id="L120" class="LineNr">120 </span><span class="Comment">       variables and return y's value. */</span>
<span id="L121" class="LineNr"><a href="#tcm-37" data-file="test_causal_model" title="test_proc_to_func" class="checkmark">&#10004;</a>121 </span>    <span class="Identifier">proc_to_func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(y, u, v, r, p) {
<span id="L122" class="LineNr">122 </span>      dom <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>({ x <span class="Type">:</span> x <span class="Type">in</span> u <span class="Type">+</span> v <span class="Type">|</span> x <span class="Type">!=</span> y }, r);
<span id="L123" class="LineNr">123 </span>      <span class="Statement">return</span> { [g, <span class="Identifier">p</span>(g)] <span class="Type">:</span> g <span class="Type">in</span> dom };
<span id="L124" class="LineNr">124 </span>    };
<span id="L125" class="LineNr">125 </span>
<span id="L126" class="LineNr">126 </span>    <span class="Identifier">new</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L127" class="LineNr">127 </span>      <span class="Statement">return</span> <span class="Identifier">causal_model</span>({}, {}, {}, {}, <span class="Constant">om</span>);
<span id="L128" class="LineNr">128 </span>    };
<span id="L129" class="LineNr">129 </span>  }
<span id="L130" class="LineNr">130 </span>}
</pre>
<pre class="vimCodeElement test_code" id="test_causal_model"><span id="L1" class="LineNr"> 1 </span><span class="Identifier">print</span>(<span class="Constant">"</span><span class="Special">\n</span><span class="Constant">Testing Causal Model"</span>);
<span id="L2" class="LineNr"> 2 </span><span class="Identifier">print</span>(  <span class="Constant">"===================="</span>);
<span id="L3" class="LineNr"> 3 </span>
<span id="L4" class="LineNr"> 4 </span><span class="Identifier">cm1</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L5" class="LineNr"> 5 </span>  u <span class="Statement">:=</span> { <span class="Constant">'O'</span> };
<span id="L6" class="LineNr"> 6 </span>  v <span class="Statement">:=</span> { <span class="Constant">'F'</span>, <span class="Constant">'L'</span>, <span class="Constant">'ML'</span> };
<span id="L7" class="LineNr"> 7 </span>  r <span class="Statement">:=</span> { [x, { <span class="Constant">false</span>, <span class="Constant">true</span> }] <span class="Type">:</span> x <span class="Type">in</span> u <span class="Type">+</span> v };
<span id="L8" class="LineNr"> 8 </span>  f_f <span class="Statement">:=</span> causal_model.<a class="Identifier code-proc-link" href="#cm-121">proc_to_func</a>(<span class="Constant">'F'</span>, u, v, r, <span class="Type">procedure</span>(h) {
<span id="L9" class="LineNr"> 9 </span>           <span class="Statement">if</span> (h[<span class="Constant">'L'</span>] <span class="Type">||</span> h[<span class="Constant">'ML'</span>]) {
<span id="L10" class="LineNr">10 </span>             <span class="Statement">return</span> <span class="Constant">true</span>;
<span id="L11" class="LineNr">11 </span>           } <span class="Statement">else</span> {
<span id="L12" class="LineNr">12 </span>             <span class="Statement">return</span> <span class="Constant">false</span>;
<span id="L13" class="LineNr">13 </span>           }
<span id="L14" class="LineNr">14 </span>         });
<span id="L15" class="LineNr">15 </span>  f <span class="Statement">:=</span> { [<span class="Constant">'F'</span>, { [{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'L'</span>, <span class="Constant">false</span>], [<span class="Constant">'ML'</span>, <span class="Constant">false</span>] }, <span class="Constant">false</span>],
<span id="L16" class="LineNr">16 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'L'</span>, <span class="Constant">false</span>], [<span class="Constant">'ML'</span>, <span class="Constant">true</span> ] }, <span class="Constant">true</span> ],
<span id="L17" class="LineNr">17 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'L'</span>, <span class="Constant">true</span> ], [<span class="Constant">'ML'</span>, <span class="Constant">false</span>] }, <span class="Constant">true</span> ],
<span id="L18" class="LineNr">18 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'L'</span>, <span class="Constant">true</span> ], [<span class="Constant">'ML'</span>, <span class="Constant">true</span> ] }, <span class="Constant">true</span> ],
<span id="L19" class="LineNr">19 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">true</span> ], [<span class="Constant">'L'</span>, <span class="Constant">false</span>], [<span class="Constant">'ML'</span>, <span class="Constant">false</span>] }, <span class="Constant">false</span>],
<span id="L20" class="LineNr">20 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">true</span> ], [<span class="Constant">'L'</span>, <span class="Constant">false</span>], [<span class="Constant">'ML'</span>, <span class="Constant">true</span> ] }, <span class="Constant">true</span> ],
<span id="L21" class="LineNr">21 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">true</span> ], [<span class="Constant">'L'</span>, <span class="Constant">true</span> ], [<span class="Constant">'ML'</span>, <span class="Constant">false</span>] }, <span class="Constant">true</span> ],
<span id="L22" class="LineNr">22 </span>                 [{ [<span class="Constant">'O'</span>, <span class="Constant">true</span> ], [<span class="Constant">'L'</span>, <span class="Constant">true</span> ], [<span class="Constant">'ML'</span>, <span class="Constant">true</span> ] }, <span class="Constant">true</span> ] }],
<span id="L23" class="LineNr">23 </span>         [<span class="Constant">'L'</span>,  causal_model.<a class="Identifier code-proc-link" href="#cm-121">proc_to_func</a>(<span class="Constant">'L'</span>, u, v, r, <span class="Type">procedure</span>(g) {
<span id="L24" class="LineNr">24 </span>                  <span class="Statement">return</span> <span class="Constant">false</span>;
<span id="L25" class="LineNr">25 </span>                })],
<span id="L26" class="LineNr">26 </span>         [<span class="Constant">'ML'</span>, causal_model.<a class="Identifier code-proc-link" href="#cm-121">proc_to_func</a>(<span class="Constant">'ML'</span>, u, v, r, <span class="Type">procedure</span>(g) {
<span id="L27" class="LineNr">27 </span>                  <span class="Statement">return</span> <span class="Constant">false</span>;
<span id="L28" class="LineNr">28 </span>                })] };
<span id="L29" class="LineNr">29 </span>  <span class="Statement">assert</span>(f_f <span class="Type">==</span> f[<span class="Constant">'F'</span>], <span class="Constant">'proc_to_func helper method is incorrect'</span>);
<span id="L30" class="LineNr">30 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] proc_to_func'</span>);
<span id="L31" class="LineNr">31 </span>
<span id="L32" class="LineNr">32 </span>  cm <span class="Statement">:=</span> <span class="Identifier">causal_model</span>(u,v,r,f);
<span id="L33" class="LineNr">33 </span>  <span class="Statement">assert</span>(cm.f[<span class="Constant">'F'</span>] <span class="Type">==</span> f_f, <span class="Constant">'causal model class is incorrect'</span>);
<span id="L34" class="LineNr">34 </span>
<span id="L35" class="LineNr">35 </span>  <span class="Statement">return</span> cm;
<span id="L36" class="LineNr">36 </span>};
<span id="L37" class="LineNr"><a href="#cm-121" data-file="causal_model" title="proc_to_func" class="back_to_proc">&#8629;</a>37 </span><span class="Identifier">test_proc_to_func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tcm-4">cm1</a>(); };
<span id="L38" class="LineNr">38 </span>
<span id="L39" class="LineNr"><a href="#cm-27" data-file="causal_model" title="effect_of_do" class="back_to_proc">&#8629;</a>39 </span><span class="Identifier">test_effect_of_do</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L40" class="LineNr">40 </span>  sm <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#tcm-4">cm1</a>().<a class="Identifier code-proc-link" href="#cm-27">effect_of_do</a>({ [<span class="Constant">'F'</span>, <span class="Constant">true</span>], [<span class="Constant">'L'</span>, <span class="Constant">true</span>] });
<span id="L41" class="LineNr">41 </span>  <span class="Statement">assert</span>((sm.f[<span class="Constant">'F'</span> ])[{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'L'</span>, <span class="Constant">false</span>], [<span class="Constant">'ML'</span>, <span class="Constant">false</span>] }] <span class="Type">&lt;=</span><span class="Type">=&gt;</span> <span class="Constant">true</span>,
<span id="L42" class="LineNr">42 </span>           <span class="Constant">'effect_of_do F is incorrect'</span>);
<span id="L43" class="LineNr">43 </span>  <span class="Statement">assert</span>((sm.f[<span class="Constant">'L'</span> ])[{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'F'</span>, <span class="Constant">false</span>], [<span class="Constant">'ML'</span>, <span class="Constant">false</span>] }] <span class="Type">&lt;=</span><span class="Type">=&gt;</span> <span class="Constant">true</span>,
<span id="L44" class="LineNr">44 </span>           <span class="Constant">'effect_of_do L is incorrect'</span>);
<span id="L45" class="LineNr">45 </span>  <span class="Statement">assert</span>((sm.f[<span class="Constant">'ML'</span> ])[{ [<span class="Constant">'O'</span>, <span class="Constant">false</span>], [<span class="Constant">'F'</span>, <span class="Constant">false</span>], [<span class="Constant">'L'</span>, <span class="Constant">false</span>] }] <span class="Type">&lt;=</span><span class="Type">=&gt;</span> <span class="Constant">false</span>,
<span id="L46" class="LineNr">46 </span>           <span class="Constant">'effect_of_do ML is incorrect'</span>);
<span id="L47" class="LineNr">47 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] effect_of_do'</span>);
<span id="L48" class="LineNr">48 </span>};
<span id="L49" class="LineNr">49 </span>
<span id="L50" class="LineNr"><a href="#cm-65" data-file="causal_model" title="parents" class="back_to_proc">&#8629;</a>50 </span><span class="Identifier">test_parents</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L51" class="LineNr">51 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcm-4">cm1</a>().<a class="Identifier code-proc-link" href="#da-197">parents</a>(<span class="Constant">'F'</span>) <span class="Type">==</span> { <span class="Constant">'L'</span>, <span class="Constant">'ML'</span> }, <span class="Constant">'parents is incorrect'</span>);
<span id="L52" class="LineNr">52 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] parents'</span>);
<span id="L53" class="LineNr">53 </span>};
<span id="L54" class="LineNr">54 </span>
<span id="L55" class="LineNr"><a href="#cm-37" data-file="causal_model" title="response" class="back_to_proc">&#8629;</a>55 </span><span class="Identifier">test_response</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L56" class="LineNr">56 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcm-4">cm1</a>().<a class="Identifier code-proc-link" href="#cmm-108">response</a>({<span class="Constant">'F'</span>}, { [<span class="Constant">'L'</span>, <span class="Constant">false</span>], [<span class="Constant">'O'</span>, <span class="Constant">true</span>] })[<span class="Constant">'F'</span>] <span class="Type">==</span> <span class="Constant">false</span>,
<span id="L57" class="LineNr">57 </span>         <span class="Constant">'response is incorrect'</span>);
<span id="L58" class="LineNr">58 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#tcm-4">cm1</a>().<a class="Identifier code-proc-link" href="#cmm-108">response</a>({<span class="Constant">'F'</span>}, { [<span class="Constant">'L'</span>, <span class="Constant">true</span>], [<span class="Constant">'O'</span>, <span class="Constant">true</span>] })[<span class="Constant">'F'</span>] <span class="Type">==</span> <span class="Constant">true</span>,
<span id="L59" class="LineNr">59 </span>         <span class="Constant">'response is incorrect'</span>);
<span id="L60" class="LineNr">60 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] response'</span>);
<span id="L61" class="LineNr">61 </span>};
</pre>
<pre class="vimCodeElement" id="lib"><span id="L1" class="LineNr">  1 </span>dev <span class="Statement">:=</span> <span class="Constant">false</span>;
<span id="L2" class="LineNr">  2 </span>
<span id="L3" class="LineNr">  3 </span><span class="Identifier">tf</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <span class="Statement">return</span> { <span class="Constant">true</span>, <span class="Constant">false</span> }; };
<span id="L4" class="LineNr">  4 </span>
<span id="L5" class="LineNr">  5 </span><span class="Comment">// Non-empty powerset. Powerset without the empty set.</span>
<span id="L6" class="LineNr"><a href="#tl-4" data-file="test_lib" title="test_ne_pow" class="checkmark">&#10004;</a>  6 </span><span class="Identifier">ne_pow</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(s) {
<span id="L7" class="LineNr">  7 </span>  <span class="Statement">return</span> <span class="Identifier">pow</span>(s) <span class="Type">-</span> {{}};
<span id="L8" class="LineNr">  8 </span>};
<span id="L9" class="LineNr">  9 </span>
<span id="L10" class="LineNr"><a href="#tl-11" data-file="test_lib" title="test_min" class="checkmark">&#10004;</a> 10 </span><span class="Identifier">min</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l) {
<span id="L11" class="LineNr"> 11 </span>  mins <span class="Statement">:=</span> { e <span class="Type">:</span> e <span class="Type">in</span> l <span class="Type">|</span> <span class="Type">forall</span>(e2 <span class="Type">in</span> [x <span class="Type">:</span> x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">!=</span> e ] <span class="Type">|</span> e2 <span class="Type">&gt;=</span> e) };
<span id="L12" class="LineNr"> 12 </span>  <span class="Statement">return</span> <span class="Identifier">first</span>(mins);
<span id="L13" class="LineNr"> 13 </span>};
<span id="L14" class="LineNr"> 14 </span>
<span id="L15" class="LineNr"><a href="#tl-17" data-file="test_lib" title="test_max" class="checkmark">&#10004;</a> 15 </span><span class="Identifier">max</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l) {
<span id="L16" class="LineNr"> 16 </span>  maxs <span class="Statement">:=</span> { e <span class="Type">:</span> e <span class="Type">in</span> l <span class="Type">|</span> <span class="Type">forall</span>(e2 <span class="Type">in</span> [x <span class="Type">:</span> x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">!=</span> e ] <span class="Type">|</span> e <span class="Type">&gt;=</span> e2) };
<span id="L17" class="LineNr"> 17 </span>  <span class="Statement">return</span> <span class="Identifier">first</span>(maxs);
<span id="L18" class="LineNr"> 18 </span>};
<span id="L19" class="LineNr"> 19 </span>
<span id="L20" class="LineNr"><a href="#tl-23" data-file="test_lib" title="test_avg" class="checkmark">&#10004;</a> 20 </span><span class="Identifier">avg</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l) {
<span id="L21" class="LineNr"> 21 </span>  <span class="Statement">return</span> (<span class="Type">+/</span> l)  <span class="Type">/</span> <span class="Type">#</span>l;
<span id="L22" class="LineNr"> 22 </span>};
<span id="L23" class="LineNr"> 23 </span>
<span id="L24" class="LineNr"><a href="#tl-29" data-file="test_lib" title="test_index_of" class="checkmark">&#10004;</a> 24 </span><span class="Identifier">index_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(e, xs) {
<span id="L25" class="LineNr"> 25 </span>  i <span class="Statement">:=</span> <span class="Constant">1</span>;
<span id="L26" class="LineNr"> 26 </span>  <span class="Statement">while</span> (xs[i] <span class="Type">!=</span> e) {
<span id="L27" class="LineNr"> 27 </span>    i <span class="Statement">:=</span> i <span class="Type">+</span> <span class="Constant">1</span>;
<span id="L28" class="LineNr"> 28 </span>  }
<span id="L29" class="LineNr"> 29 </span>  <span class="Statement">if</span> (xs[i] <span class="Type">==</span> e) {
<span id="L30" class="LineNr"> 30 </span>    <span class="Statement">return</span> i;
<span id="L31" class="LineNr"> 31 </span>  } <span class="Statement">else</span> {
<span id="L32" class="LineNr"> 32 </span>    <span class="Statement">return</span> <span class="Constant">om</span>;
<span id="L33" class="LineNr"> 33 </span>  }
<span id="L34" class="LineNr"> 34 </span>};
<span id="L35" class="LineNr"> 35 </span>
<span id="L36" class="LineNr"><a href="#tl-35" data-file="test_lib" title="test_equiv_expr" class="checkmark">&#10004;</a> 36 </span><span class="Identifier">equiv_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(e1, e2, dom) {
<span id="L37" class="LineNr"> 37 </span>  <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'equiv_expr dom '</span> <span class="Type">+</span> dom); }
<span id="L38" class="LineNr"> 38 </span>  <span class="Statement">if</span> (<span class="Identifier">isList</span>(e1) <span class="Type">&amp;&amp;</span> <span class="Type">!</span><span class="Identifier">isList</span>(e2) <span class="Type">||</span>
<span id="L39" class="LineNr"> 39 </span>      <span class="Identifier">isList</span>(e2) <span class="Type">&amp;&amp;</span> <span class="Type">!</span><span class="Identifier">isList</span>(e1)   ) {
<span id="L40" class="LineNr"> 40 </span>    <span class="Statement">return</span> <span class="Constant">false</span>;
<span id="L41" class="LineNr"> 41 </span>  } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">isList</span>(e1)) {
<span id="L42" class="LineNr"> 42 </span>    <span class="Statement">return</span> <span class="Type">forall</span>(j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>e1] <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-36">equiv_expr</a>(e1[j], e2[j], dom) );
<span id="L43" class="LineNr"> 43 </span>  } <span class="Statement">else</span> {
<span id="L44" class="LineNr"> 44 </span>    <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(e1) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(e1) <span class="Type">==</span> <span class="Constant">"BoxArrow"</span>) {
<span id="L45" class="LineNr"> 45 </span>      <span class="Statement">return</span> <span class="Identifier">isTerm</span>(e2) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(e2) <span class="Type">==</span> <span class="Constant">"BoxArrow"</span> <span class="Type">&amp;&amp;</span>
<span id="L46" class="LineNr"> 46 </span>             <span class="Identifier">equiv_expr</span>(<span class="Identifier">args</span>(e1)[<span class="Constant">1</span>], <span class="Identifier">args</span>(e2)[<span class="Constant">1</span>], dom) <span class="Type">&amp;&amp;</span>
<span id="L47" class="LineNr"> 47 </span>             <span class="Identifier">equiv_expr</span>(<span class="Identifier">args</span>(e1)[<span class="Constant">2</span>], <span class="Identifier">args</span>(e2)[<span class="Constant">2</span>], dom);
<span id="L48" class="LineNr"> 48 </span>    } <span class="Statement">else</span> {
<span id="L49" class="LineNr"> 49 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(e1, dom) <span class="Type">==</span> <a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(e2, dom);
<span id="L50" class="LineNr"> 50 </span>    }
<span id="L51" class="LineNr"> 51 </span>  }
<span id="L52" class="LineNr"> 52 </span>};
<span id="L53" class="LineNr"> 53 </span>
<span id="L54" class="LineNr"> 54 </span><span class="Comment">// Possible references for arity of expr</span>
<span id="L55" class="LineNr"><a href="#tl-440" data-file="test_lib" title="test_range_for_arity" class="checkmark">&#10004;</a> 55 </span><span class="Identifier">range_for_arity</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(e_arity, poss_sts) {
<span id="L56" class="LineNr"> 56 </span>  <span class="Comment">/* Propositions are sets of possible states. They can also be treated as </span>
<span id="L57" class="LineNr"> 57 </span><span class="Comment">     objects. You might think of them as the essential realization conditions</span>
<span id="L58" class="LineNr"> 58 </span><span class="Comment">     for objects. */</span>
<span id="L59" class="LineNr"> 59 </span>  poss_objects <span class="Statement">:=</span> <span class="Identifier">pow</span>(poss_sts);
<span id="L60" class="LineNr"> 60 </span>  <span class="Statement">if</span> (e_arity <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L61" class="LineNr"> 61 </span>    <span class="Statement">return</span> poss_objects;
<span id="L62" class="LineNr"> 62 </span>  <span class="Comment">/* Wrapping the sngl event below as a list/1-tuple might be a little </span>
<span id="L63" class="LineNr"> 63 </span><span class="Comment">     counterintuitive but it allows it to be treated consistently with</span>
<span id="L64" class="LineNr"> 64 </span><span class="Comment">     higher arities.  */</span>
<span id="L65" class="LineNr"> 65 </span>  } <span class="Statement">else</span> <span class="Statement">if</span> (e_arity <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L66" class="LineNr"> 66 </span>    <span class="Statement">return</span> <span class="Identifier">pow</span>({ [x] <span class="Type">:</span> x <span class="Type">in</span> poss_objects <span class="Type">-</span> {{}} });
<span id="L67" class="LineNr"> 67 </span>  } <span class="Statement">else</span> {
<span id="L68" class="LineNr"> 68 </span>    <span class="Statement">return</span> <span class="Identifier">pow</span>(<a class="Identifier code-proc-link" href="#l-279">iter_prod</a>(poss_objects <span class="Type">-</span> {{}}, e_arity));
<span id="L69" class="LineNr"> 69 </span>  }
<span id="L70" class="LineNr"> 70 </span>};
<span id="L71" class="LineNr"> 71 </span>
<span id="L72" class="LineNr"> 72 </span><span class="Identifier">connectives</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L73" class="LineNr"> 73 </span>  <span class="Statement">return</span> {<span class="Constant">'And'</span>,<span class="Constant">'Not'</span>,<span class="Constant">'Or'</span>,<span class="Constant">'Implies'</span>,<span class="Constant">'BoxArrow'</span>,<span class="Constant">'At_t'</span>,<span class="Constant">'Forall'</span>,<span class="Constant">'Exists'</span>};
<span id="L74" class="LineNr"> 74 </span>};
<span id="L75" class="LineNr"> 75 </span>
<span id="L76" class="LineNr"><a href="#tl-50" data-file="test_lib" title="test_maybe_not" class="checkmark">&#10004;</a> 76 </span><span class="Identifier">maybe_not</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(var, val) {
<span id="L77" class="LineNr"> 77 </span>  <span class="Statement">if</span> (val <span class="Type">==</span> <span class="Constant">true</span>) {
<span id="L78" class="LineNr"> 78 </span>    <span class="Statement">return</span> var;
<span id="L79" class="LineNr"> 79 </span>  } <span class="Statement">else</span> {
<span id="L80" class="LineNr"> 80 </span>    <span class="Statement">return</span> <span class="Identifier">Not</span>(var);
<span id="L81" class="LineNr"> 81 </span>  }
<span id="L82" class="LineNr"> 82 </span>};
<span id="L83" class="LineNr"> 83 </span>
<span id="L84" class="LineNr"> 84 </span><span class="Identifier">inv_maybe_not</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L85" class="LineNr"> 85 </span>  <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"Not"</span>) {
<span id="L86" class="LineNr"> 86 </span>    <span class="Statement">return</span> { [<span class="Identifier">args</span>(expr)[<span class="Constant">1</span>], <span class="Constant">false</span>] };
<span id="L87" class="LineNr"> 87 </span>  } <span class="Statement">else</span> {
<span id="L88" class="LineNr"> 88 </span>    <span class="Statement">return</span> { [expr,  <span class="Constant">true</span>] };
<span id="L89" class="LineNr"> 89 </span>  }
<span id="L90" class="LineNr"> 90 </span>};
<span id="L91" class="LineNr"> 91 </span>
<span id="L92" class="LineNr"> 92 </span><span class="Comment">/* Takes an expr and returns the set of vars, atomic propositions and objects</span>
<span id="L93" class="LineNr"> 93 </span><span class="Comment">   that occur in it.  */</span>
<span id="L94" class="LineNr"><a href="#tl-60" data-file="test_lib" title="test_atomic_exprs" class="checkmark">&#10004;</a> 94 </span><span class="Identifier">atomic_exprs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L95" class="LineNr"> 95 </span>  <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr)) {
<span id="L96" class="LineNr"> 96 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-94">atomic_exprs</a>(arg_i) <span class="Type">:</span> arg_i <span class="Type">in</span> <span class="Identifier">args</span>(expr) };
<span id="L97" class="LineNr"> 97 </span>  } <span class="Statement">else</span> {
<span id="L98" class="LineNr"> 98 </span>    <span class="Statement">return</span> { expr };
<span id="L99" class="LineNr"> 99 </span>  }
<span id="L100" class="LineNr">100 </span>};
<span id="L101" class="LineNr">101 </span>
<span id="L102" class="LineNr">102 </span><span class="Comment">/* Takes an expr and returns the set of atomic propositions and objects</span>
<span id="L103" class="LineNr">103 </span><span class="Comment">   that occur in it (but not its variables).  */</span>
<span id="L104" class="LineNr"><a href="#tl-67" data-file="test_lib" title="test_atomic_terms" class="checkmark">&#10004;</a>104 </span><span class="Identifier">atomic_terms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L105" class="LineNr">105 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-94">atomic_exprs</a>(expr) <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-526">parse_vars</a>(expr);
<span id="L106" class="LineNr">106 </span>};
<span id="L107" class="LineNr">107 </span>
<span id="L108" class="LineNr">108 </span><span class="Comment">/* Takes a function assigning true or false to vars and turns it into an </span>
<span id="L109" class="LineNr">109 </span><span class="Comment">   expression that is a conjunction of either var or Not(var) depending </span>
<span id="L110" class="LineNr">110 </span><span class="Comment">   on each variable's truth value.  */</span>
<span id="L111" class="LineNr"><a href="#tl-74" data-file="test_lib" title="test_func_to_expr" class="checkmark">&#10004;</a>111 </span><span class="Identifier">func_to_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(g) {
<span id="L112" class="LineNr">112 </span>  sorted_vs <span class="Statement">:=</span> <span class="Identifier">sort</span>([ v <span class="Type">:</span> v <span class="Type">in</span> <span class="Identifier">domain</span>(g) ]);
<span id="L113" class="LineNr">113 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-233">iter_fct</a>(<span class="Constant">"And"</span>, [ <a class="Identifier code-proc-link" href="#l-76">maybe_not</a>(v, g[v]) <span class="Type">:</span> v <span class="Type">in</span> sorted_vs ]);
<span id="L114" class="LineNr">114 </span>};
<span id="L115" class="LineNr">115 </span>
<span id="L116" class="LineNr">116 </span><span class="Identifier">all_atomic_formulas</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(exprs) {
<span id="L117" class="LineNr">117 </span>  <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-120">atomic_formulas</a>(expr) <span class="Type">:</span> expr <span class="Type">in</span> exprs };
<span id="L118" class="LineNr">118 </span>};
<span id="L119" class="LineNr">119 </span>
<span id="L120" class="LineNr"><a href="#tl-85" data-file="test_lib" title="test_atomic_formulas" class="checkmark">&#10004;</a>120 </span><span class="Identifier">atomic_formulas</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L121" class="LineNr">121 </span>  <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'expr '</span> <span class="Type">+</span> expr); }
<span id="L122" class="LineNr">122 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-125">atomic_forms</a>(expr) <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-526">parse_vars</a>(expr);
<span id="L123" class="LineNr">123 </span>};
<span id="L124" class="LineNr">124 </span>
<span id="L125" class="LineNr"><a href="#tl-93" data-file="test_lib" title="test_atomic_forms" class="checkmark">&#10004;</a>125 </span><span class="Identifier">atomic_forms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L126" class="LineNr">126 </span>  <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'atomic forms '</span> <span class="Type">+</span> expr); }
<span id="L127" class="LineNr">127 </span>  <span class="Statement">if</span> (<span class="Type">!</span><span class="Identifier">isTerm</span>(expr) <span class="Type">||</span> <span class="Type">!</span>(<span class="Identifier">fct</span>(expr) <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-72">connectives</a>())) {
<span id="L128" class="LineNr">128 </span>    <span class="Statement">return</span> { expr };
<span id="L129" class="LineNr">129 </span>  } <span class="Statement">else</span> {
<span id="L130" class="LineNr">130 </span>    <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-125">atomic_forms</a>(arg_i) <span class="Type">:</span> arg_i <span class="Type">in</span> <span class="Identifier">args</span>(expr) };
<span id="L131" class="LineNr">131 </span>  }
<span id="L132" class="LineNr">132 </span>};
<span id="L133" class="LineNr">133 </span>
<span id="L134" class="LineNr"><a href="#tl-95" data-file="test_lib" title="test_expr_to_events" class="checkmark">&#10004;</a>134 </span><span class="Identifier">expr_to_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr, dom) {
<span id="L135" class="LineNr">135 </span>  <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'dom: '</span> <span class="Type">+</span> dom); }
<span id="L136" class="LineNr">136 </span>  state_space <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-647">exprs_to_state_space</a>(dom);
<span id="L137" class="LineNr">137 </span>  <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'st sp: '</span> <span class="Type">+</span> state_space); }
<span id="L138" class="LineNr">138 </span>  <span class="Identifier">expand</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(events) {
<span id="L139" class="LineNr">139 </span>    <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'expand '</span> <span class="Type">+</span> events); }
<span id="L140" class="LineNr">140 </span>    <span class="Statement">return</span> { state <span class="Type">:</span> state <span class="Type">in</span> state_space
<span id="L141" class="LineNr">141 </span>             <span class="Type">|</span> <span class="Type">exists</span>(event <span class="Type">in</span> events <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>(state, event)) };
<span id="L142" class="LineNr">142 </span>  };
<span id="L143" class="LineNr">143 </span>  <span class="Identifier">ete</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L144" class="LineNr">144 </span>    <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'ete('</span> <span class="Type">+</span> expr <span class="Type">+</span> <span class="Constant">')'</span>); }
<span id="L145" class="LineNr">145 </span>    <span class="Statement">if</span> (<span class="Identifier">isString</span>(expr)) {
<span id="L146" class="LineNr">146 </span>      <span class="Statement">return</span> { state <span class="Type">:</span> state <span class="Type">in</span> state_space <span class="Type">|</span> state[expr] <span class="Type">==</span> <span class="Constant">true</span> };
<span id="L147" class="LineNr">147 </span>    }
<span id="L148" class="LineNr">148 </span>    <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr)) {
<span id="L149" class="LineNr">149 </span>      <span class="Statement">if</span> (<span class="Type">#</span><span class="Identifier">args</span>(expr) <span class="Type">&gt;=</span> <span class="Constant">1</span>) { a1 <span class="Statement">:=</span> <span class="Identifier">args</span>(expr)[<span class="Constant">1</span>]; }
<span id="L150" class="LineNr">150 </span>      <span class="Statement">if</span> (<span class="Type">#</span><span class="Identifier">args</span>(expr) <span class="Type">&gt;=</span> <span class="Constant">2</span>) { a2 <span class="Statement">:=</span> <span class="Identifier">args</span>(expr)[<span class="Constant">2</span>]; }
<span id="L151" class="LineNr">151 </span>
<span id="L152" class="LineNr">152 </span>      <span class="Statement">if</span> (<span class="Type">!</span>(<span class="Identifier">fct</span>(expr) <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-72">connectives</a>())) {  <span class="Comment">// applied predicate / relation</span>
<span id="L153" class="LineNr">153 </span>        <span class="Statement">return</span> { [expr, <span class="Constant">true</span>] };
<span id="L154" class="LineNr">154 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"And"</span>) {
<span id="L155" class="LineNr">155 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a1)) <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a2));
<span id="L156" class="LineNr">156 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a1)) <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a2));
<span id="L157" class="LineNr">157 </span>        <span class="Comment">// return { g + h : [g,h] in ete(a1) &gt;&lt; ete(a2) | isMap(g + h) };</span>
<span id="L158" class="LineNr">158 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"Or"</span>) {
<span id="L159" class="LineNr">159 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a1)) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a2));
<span id="L160" class="LineNr">160 </span>      <span class="Comment">// a -&gt; b  ==  ~a v b</span>
<span id="L161" class="LineNr">161 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"Implies"</span>) {
<span id="L162" class="LineNr">162 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>( <span class="Identifier">Or</span>(<span class="Identifier">Not</span>(a1), a2) ));
<span id="L163" class="LineNr">163 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"Exists"</span>) {
<span id="L164" class="LineNr">164 </span>        <span class="Comment">// Ex Qx &lt;-&gt; ~ Vx ~Qx</span>
<span id="L165" class="LineNr">165 </span>        <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>( <span class="Identifier">Not</span>( <span class="Identifier">Forall</span>(a1, <span class="Identifier">Not</span>(a2)) ) ));
<span id="L166" class="LineNr">166 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"Forall"</span>) {
<span id="L167" class="LineNr">167 </span>        terms <span class="Statement">:=</span> { var <span class="Type">:</span> var <span class="Type">in</span> dom <span class="Type">|</span> <span class="Identifier">isString</span>(var) };
<span id="L168" class="LineNr">168 </span>        <span class="Statement">return</span> { state <span class="Type">:</span> state <span class="Type">in</span> state_space <span class="Type">|</span>
<span id="L169" class="LineNr">169 </span>          <span class="Type">forall</span>(term <span class="Type">in</span> terms <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-658">is_true_in</a>(<a class="Identifier code-proc-link" href="#l-540">sub</a>(a2, a1, term), state, dom)) };
<span id="L170" class="LineNr">170 </span>      } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">==</span> <span class="Constant">"Not"</span>) {
<span id="L171" class="LineNr">171 </span>        <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'Not'</span>); }
<span id="L172" class="LineNr">172 </span>        <span class="Statement">switch</span> {
<span id="L173" class="LineNr">173 </span>          <span class="Statement">case</span> <span class="Identifier">isString</span>(a1) <span class="Type">:</span>
<span id="L174" class="LineNr">174 </span>            <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'Not(str)'</span>); }
<span id="L175" class="LineNr">175 </span>            <span class="Statement">return</span> { {[a1, <span class="Constant">false</span>]} };
<span id="L176" class="LineNr">176 </span>          <span class="Comment">// Pair, i.e. { [var, val] }</span>
<span id="L177" class="LineNr">177 </span>          <span class="Statement">case</span> <span class="Identifier">isSet</span>(a1) <span class="Type">&amp;&amp;</span> <span class="Type">#</span>a1 <span class="Type">==</span> <span class="Constant">1</span> <span class="Type">&amp;&amp;</span> <span class="Identifier">isMap</span>(a1) <span class="Type">:</span>
<span id="L178" class="LineNr">178 </span>            <span class="Statement">return</span> { { [<span class="Identifier">first</span>(a1)[<span class="Constant">1</span>], <span class="Type">!</span><span class="Identifier">first</span>(a1)[<span class="Constant">2</span>]] } };
<span id="L179" class="LineNr">179 </span>          <span class="Statement">case</span> <span class="Identifier">isSet</span>(a1) <span class="Type">&amp;&amp;</span> <span class="Identifier">isMap</span>(a1) <span class="Type">:</span>
<span id="L180" class="LineNr">180 </span>            <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'~(a ^ b) = ~a v ~b'</span>); }
<span id="L181" class="LineNr">181 </span>            <span class="Comment">// ~(a ^ b) = ~a v ~b</span>
<span id="L182" class="LineNr">182 </span>            <span class="Statement">return</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(<span class="Identifier">Not</span>({pair}))) <span class="Type">:</span> pair <span class="Type">in</span> a1 };
<span id="L183" class="LineNr">183 </span>          <span class="Comment">// Singleton map, eg { g } or { {[x,y],[w,z],...} }</span>
<span id="L184" class="LineNr">184 </span>          <span class="Statement">case</span> <span class="Identifier">isSet</span>(a1) <span class="Type">&amp;&amp;</span> <span class="Type">#</span>a1 <span class="Type">==</span> <span class="Constant">1</span> <span class="Type">:</span>
<span id="L185" class="LineNr">185 </span>            <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'~ { g } = ~g'</span>); }
<span id="L186" class="LineNr">186 </span>            <span class="Comment">// ~ { g } = ~g</span>
<span id="L187" class="LineNr">187 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(<span class="Identifier">Not</span>(<span class="Identifier">first</span>(a1))));
<span id="L188" class="LineNr">188 </span>          <span class="Comment">// Implicit disjunction of maps, eg { g, h, ... }</span>
<span id="L189" class="LineNr">189 </span>          <span class="Statement">case</span> <span class="Identifier">isSet</span>(a1) <span class="Type">:</span>
<span id="L190" class="LineNr">190 </span>            <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'~(a v b) = ~a ^ ~b'</span>); }
<span id="L191" class="LineNr">191 </span>            <span class="Comment">// ~(a v b) = ~a ^ ~b</span>
<span id="L192" class="LineNr">192 </span>            head <span class="Statement">:=</span> <span class="Identifier">first</span>(a1);
<span id="L193" class="LineNr">193 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(  <span class="Identifier">And</span>( <span class="Identifier">Not</span>(head), <span class="Identifier">Not</span>(a1 <span class="Type">-</span> {head}) )  ));
<span id="L194" class="LineNr">194 </span>          <span class="Comment">// Do we allow Not(a[]-&gt;b)? How?</span>
<span id="L195" class="LineNr">195 </span>          <span class="Comment">// case isTerm(a1) &amp;&amp; fct(a1) == 'BoxArrow' :</span>
<span id="L196" class="LineNr">196 </span>          <span class="Statement">default</span> <span class="Type">:</span> <span class="Comment">// e.g. functor term, i.e. predicate or other connective?</span>
<span id="L197" class="LineNr">197 </span>            <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'[~a] = [~[a]]'</span>); }
<span id="L198" class="LineNr">198 </span>            <span class="Comment">// [~a] = [~[a]]</span>
<span id="L199" class="LineNr">199 </span>            <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(<span class="Identifier">Not</span>( <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(a1)))));
<span id="L200" class="LineNr">200 </span>        }
<span id="L201" class="LineNr">201 </span>      }
<span id="L202" class="LineNr">202 </span>    } <span class="Statement">else</span> { <span class="Comment">// not term, atomic expr</span>
<span id="L203" class="LineNr">203 </span>      <span class="Statement">return</span> ({ [expr, <span class="Constant">true</span>] });
<span id="L204" class="LineNr">204 </span>    }
<span id="L205" class="LineNr">205 </span>  }; <span class="Comment">// end ete</span>
<span id="L206" class="LineNr">206 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-138">expand</a>(<a class="Identifier code-proc-link" href="#l-143">ete</a>(expr));
<span id="L207" class="LineNr">207 </span>};
<span id="L208" class="LineNr">208 </span>
<span id="L209" class="LineNr">209 </span><span class="Comment">/* <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" target="_blank">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a>  */</span>
<span id="L210" class="LineNr">210 </span><span class="Identifier">foldr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(proc, z, l) {
<span id="L211" class="LineNr">211 </span>  <span class="Statement">if</span> (<span class="Type">#</span>l <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L212" class="LineNr">212 </span>    <span class="Statement">return</span> z;
<span id="L213" class="LineNr">213 </span>  } <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Type">#</span>l <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L214" class="LineNr">214 </span>    <span class="Statement">return</span> <span class="Identifier">proc</span>(l[<span class="Constant">1</span>], z);
<span id="L215" class="LineNr">215 </span>  } <span class="Statement">else</span> {
<span id="L216" class="LineNr">216 </span>    <span class="Statement">return</span> <span class="Identifier">proc</span>(l[<span class="Constant">1</span>], <a class="Identifier code-proc-link" href="#l-210">foldr</a>(proc, z, l[<span class="Constant">2</span><span class="Statement">..</span>]));
<span id="L217" class="LineNr">217 </span>  }
<span id="L218" class="LineNr">218 </span>};
<span id="L219" class="LineNr">219 </span>
<span id="L220" class="LineNr">220 </span><span class="Comment">/* Takes a setlx functor and returns a procedure which takes two expressions</span>
<span id="L221" class="LineNr">221 </span><span class="Comment">   and if either is om, returns the other, or else constructs a term out of</span>
<span id="L222" class="LineNr">222 </span><span class="Comment">   the functor and two expressions.  */</span>
<span id="L223" class="LineNr">223 </span><span class="Identifier">fctize</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(fct) {
<span id="L224" class="LineNr">224 </span>  <span class="Statement">return</span> <span class="Type">procedure</span>(e1, e2) {
<span id="L225" class="LineNr">225 </span>    <span class="Statement">if</span> (e1 <span class="Type">==</span> <span class="Constant">om</span>) { <span class="Statement">return</span> e2; } <span class="Statement">else</span> <span class="Statement">if</span> (e2 <span class="Type">==</span> <span class="Constant">om</span>) { <span class="Statement">return</span> e1; } <span class="Statement">else</span> {
<span id="L226" class="LineNr">226 </span>      <span class="Statement">return</span> <span class="Identifier">makeTerm</span>(fct, [e1,e2]);
<span id="L227" class="LineNr">227 </span>    }
<span id="L228" class="LineNr">228 </span>  };
<span id="L229" class="LineNr">229 </span>};
<span id="L230" class="LineNr">230 </span>
<span id="L231" class="LineNr">231 </span><span class="Comment">/* Takes a setlx functor and list of expressions and constructs an expression</span>
<span id="L232" class="LineNr">232 </span><span class="Comment">   by repeatedly applying the functor.  */</span>
<span id="L233" class="LineNr">233 </span><span class="Identifier">iter_fct</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(fct, l) {
<span id="L234" class="LineNr">234 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-210">foldr</a>(<a class="Identifier code-proc-link" href="#l-223">fctize</a>(fct), <span class="Constant">om</span>, l);
<span id="L235" class="LineNr">235 </span>};
<span id="L236" class="LineNr">236 </span>
<span id="L237" class="LineNr">237 </span><span class="Comment">/* Takes a function f and returns its inverse. To avoid having to return a set </span>
<span id="L238" class="LineNr">238 </span><span class="Comment">   or list, it just returns the first preimage that f maps to the img. */</span>
<span id="L239" class="LineNr"><a href="#tl-117" data-file="test_lib" title="test_inv" class="checkmark">&#10004;</a>239 </span><span class="Identifier">inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(f) {
<span id="L240" class="LineNr">240 </span>  <span class="Statement">return</span> { [img, ([ pre <span class="Type">:</span> pre <span class="Type">in</span> <span class="Identifier">domain</span>(f) <span class="Type">|</span> f[pre] <span class="Type">==</span> img])[<span class="Constant">1</span>] ]
<span id="L241" class="LineNr">241 </span>           <span class="Type">:</span> img <span class="Type">in</span> <span class="Identifier">range</span>(f) };
<span id="L242" class="LineNr">242 </span>};
<span id="L243" class="LineNr">243 </span>
<span id="L244" class="LineNr">244 </span><span class="Comment">/* Takes a setlx functor and returns its arity */</span>
<span id="L245" class="LineNr"><a href="#tl-124" data-file="test_lib" title="test_arity" class="checkmark">&#10004;</a>245 </span><span class="Identifier">arity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(fct) {
<span id="L246" class="LineNr">246 </span>  <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(fct)) {
<span id="L247" class="LineNr">247 </span>    <span class="Statement">return</span> <span class="Type">#</span><span class="Identifier">args</span>(fct);
<span id="L248" class="LineNr">248 </span>  } <span class="Statement">else</span> {
<span id="L249" class="LineNr">249 </span>    <span class="Statement">return</span> <span class="Constant">0</span>;
<span id="L250" class="LineNr">250 </span>  }
<span id="L251" class="LineNr">251 </span>};
<span id="L252" class="LineNr">252 </span>
<span id="L253" class="LineNr">253 </span><span class="Comment">/* Takes a set like s &gt;&lt; s &gt;&lt; s and returns tuples instead of nested pairs */</span>
<span id="L254" class="LineNr"><a href="#tl-133" data-file="test_lib" title="test_flatten" class="checkmark">&#10004;</a>254 </span><span class="Identifier">flatten</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(set) {
<span id="L255" class="LineNr">255 </span>  <span class="Statement">return</span> { <a class="Identifier code-proc-link" href="#l-259">flatten_list</a>(e) <span class="Type">:</span> e <span class="Type">in</span> set <span class="Type">|</span> <span class="Identifier">isList</span>(e)  } <span class="Type">+</span>
<span id="L256" class="LineNr">256 </span>         { e               <span class="Type">:</span> e <span class="Type">in</span> set <span class="Type">|</span> <span class="Type">!</span><span class="Identifier">isList</span>(e) };
<span id="L257" class="LineNr">257 </span>};
<span id="L258" class="LineNr">258 </span>
<span id="L259" class="LineNr">259 </span><span class="Identifier">flatten_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(list) {
<span id="L260" class="LineNr">260 </span>  <span class="Statement">if</span> (<span class="Identifier">isList</span>(list)) {
<span id="L261" class="LineNr">261 </span>    <span class="Statement">return</span> <span class="Type">+/</span> [ <a class="Identifier code-proc-link" href="#l-259">flatten_list</a>(l) <span class="Type">:</span> l <span class="Type">in</span> list ];
<span id="L262" class="LineNr">262 </span>  } <span class="Statement">else</span> {
<span id="L263" class="LineNr">263 </span>    <span class="Statement">return</span> [list];
<span id="L264" class="LineNr">264 </span>  }
<span id="L265" class="LineNr">265 </span>};
<span id="L266" class="LineNr">266 </span>
<span id="L267" class="LineNr">267 </span><span class="Comment">/* Takes a list of sets and returns the set of tuples taking a value from </span>
<span id="L268" class="LineNr">268 </span><span class="Comment">   each set.  */</span>
<span id="L269" class="LineNr"><a href="#tl-141" data-file="test_lib" title="test_cart_prod" class="checkmark">&#10004;</a>269 </span><span class="Identifier">cart_prod</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(list) {
<span id="L270" class="LineNr">270 </span>  <span class="Statement">if</span> (<span class="Type">#</span>list <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L271" class="LineNr">271 </span>    <span class="Statement">return</span> <span class="Identifier">first</span>(list);
<span id="L272" class="LineNr">272 </span>  } <span class="Statement">else</span> {
<span id="L273" class="LineNr">273 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-254">flatten</a>(<span class="Identifier">first</span>(list) <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#l-269">cart_prod</a>(list[<span class="Constant">2</span><span class="Statement">..</span>]));
<span id="L274" class="LineNr">274 </span>  }
<span id="L275" class="LineNr">275 </span>};
<span id="L276" class="LineNr">276 </span>
<span id="L277" class="LineNr">277 </span><span class="Comment">/* Iterated Cartesian Product </span>
<span id="L278" class="LineNr">278 </span><span class="Comment">   Yields the cartesian product of a set with itself n times.  */</span>
<span id="L279" class="LineNr"><a href="#tl-148" data-file="test_lib" title="test_iter_prod" class="checkmark">&#10004;</a>279 </span><span class="Identifier">iter_prod</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(set, n) {
<span id="L280" class="LineNr">280 </span>  <span class="Statement">if</span> (n <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L281" class="LineNr">281 </span>    <span class="Statement">return</span> set;
<span id="L282" class="LineNr">282 </span>  } <span class="Statement">else</span> {
<span id="L283" class="LineNr">283 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-254">flatten</a>(<a class="Identifier code-proc-link" href="#l-279">iter_prod</a>(set, n <span class="Type">-</span> <span class="Constant">1</span>) <span class="Type">&gt;&lt;</span> set);
<span id="L284" class="LineNr">284 </span>  }
<span id="L285" class="LineNr">285 </span>};
<span id="L286" class="LineNr">286 </span>
<span id="L287" class="LineNr"><a href="#tl-155" data-file="test_lib" title="test_iter_mult" class="checkmark">&#10004;</a>287 </span><span class="Identifier">iter_mult</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(set) {
<span id="L288" class="LineNr">288 </span>  <span class="Statement">if</span> (<span class="Type">#</span>set <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L289" class="LineNr">289 </span>    <span class="Statement">return</span> <span class="Identifier">first</span>(set);
<span id="L290" class="LineNr">290 </span>  } <span class="Statement">else</span> {
<span id="L291" class="LineNr">291 </span>    <span class="Statement">return</span> <span class="Identifier">first</span>(set) <span class="Type">*</span> <a class="Identifier code-proc-link" href="#l-287">iter_mult</a>(set <span class="Type">-</span> { <span class="Identifier">first</span>(set) });
<span id="L292" class="LineNr">292 </span>  }
<span id="L293" class="LineNr">293 </span>};
<span id="L294" class="LineNr">294 </span>
<span id="L295" class="LineNr">295 </span><span class="Comment">/* Takes a set of sets and returns a set of all possible choices taking an </span>
<span id="L296" class="LineNr">296 </span><span class="Comment">   element from each set. */</span>
<span id="L297" class="LineNr"><a href="#tl-162" data-file="test_lib" title="test_choices" class="checkmark">&#10004;</a>297 </span><span class="Identifier">choices</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(set) {
<span id="L298" class="LineNr">298 </span>  list <span class="Statement">:=</span> [ [elem <span class="Type">:</span> elem <span class="Type">in</span> subset] <span class="Type">:</span> subset <span class="Type">in</span> set ];
<span id="L299" class="LineNr">299 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-303">set_choices</a>(list);
<span id="L300" class="LineNr">300 </span>};
<span id="L301" class="LineNr">301 </span>
<span id="L302" class="LineNr">302 </span><span class="Comment">// Same as list_choices but returns a set rather than list of the choices.</span>
<span id="L303" class="LineNr">303 </span><span class="Identifier">set_choices</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(r) {
<span id="L304" class="LineNr">304 </span>  <span class="Statement">return</span> { { o <span class="Type">:</span> o <span class="Type">in</span> p } <span class="Type">:</span> p <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-309">list_choices</a>(r) };
<span id="L305" class="LineNr">305 </span>};
<span id="L306" class="LineNr">306 </span>
<span id="L307" class="LineNr">307 </span><span class="Comment">/* Takes a list of lists and returns a list of all possible choices taking</span>
<span id="L308" class="LineNr">308 </span><span class="Comment">   an element from each list  */</span>
<span id="L309" class="LineNr">309 </span><span class="Identifier">list_choices</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(r) {
<span id="L310" class="LineNr">310 </span>  <span class="Statement">if</span> (<span class="Type">#</span>r <span class="Type">==</span> <span class="Constant">1</span>) {
<span id="L311" class="LineNr">311 </span>    <span class="Statement">return</span> [[x] <span class="Type">:</span> x <span class="Type">in</span> r[<span class="Constant">1</span>]];
<span id="L312" class="LineNr">312 </span>  } <span class="Statement">else</span> {
<span id="L313" class="LineNr">313 </span>    <span class="Statement">return</span> <span class="Type">+/</span> [  [[x] <span class="Type">+</span> row <span class="Type">:</span> row <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-309">list_choices</a>(r[<span class="Constant">2</span><span class="Statement">..</span>])]  <span class="Type">:</span> x <span class="Type">in</span> r[<span class="Constant">1</span>] ];
<span id="L314" class="LineNr">314 </span>  }
<span id="L315" class="LineNr">315 </span>};
<span id="L316" class="LineNr">316 </span>
<span id="L317" class="LineNr">317 </span><span class="Comment">/* Generate the set of all functions from dom to rng. </span>
<span id="L318" class="LineNr">318 </span><span class="Comment">   Generate atomic maps. Collect the choices of those atomic maps. */</span>
<span id="L319" class="LineNr"><a href="#tl-171" data-file="test_lib" title="test_function_space" class="checkmark">&#10004;</a>319 </span><span class="Identifier">function_space</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(dom, rng) {
<span id="L320" class="LineNr">320 </span>  <span class="Comment">// Collect into a set the elements from a list of choices of atomic maps</span>
<span id="L321" class="LineNr">321 </span>  <span class="Comment">// p for preimage and permutation? o is ordered pair?</span>
<span id="L322" class="LineNr">322 </span>  <span class="Statement">return</span> { { o <span class="Type">:</span> o <span class="Type">in</span> p } <span class="Type">:</span> p <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-309">list_choices</a>([ [ [p, i] <span class="Type">:</span> i <span class="Type">in</span> rng ] <span class="Type">:</span> p <span class="Type">in</span> dom]) };
<span id="L323" class="LineNr">323 </span>};
<span id="L324" class="LineNr">324 </span>
<span id="L325" class="LineNr">325 </span><span class="Comment">/* Takes a set of variables s and a function r assigning a set which is the </span>
<span id="L326" class="LineNr">326 </span><span class="Comment">   range of possible values to each variable and returns the set of possible </span>
<span id="L327" class="LineNr">327 </span><span class="Comment">   functions assigning values to those variables.  */</span>
<span id="L328" class="LineNr"><a href="#tl-184" data-file="test_lib" title="test_possible_states" class="checkmark">&#10004;</a>328 </span><span class="Identifier">possible_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(s, r) {
<span id="L329" class="LineNr">329 </span>  <span class="Statement">if</span> (s <span class="Type">==</span> {} <span class="Type">||</span> r <span class="Type">==</span> {}) {
<span id="L330" class="LineNr">330 </span>    <span class="Statement">return</span> {{}};
<span id="L331" class="LineNr">331 </span>  }
<span id="L332" class="LineNr">332 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {v} <span class="Type">&gt;&lt;</span> r[v] <span class="Type">:</span> v <span class="Type">in</span> s });
<span id="L333" class="LineNr">333 </span>};
<span id="L334" class="LineNr">334 </span>
<span id="L335" class="LineNr">335 </span><span class="Comment">/* Takes a function and returns all partial functions, including empty.  */</span>
<span id="L336" class="LineNr"><a href="#tl-197" data-file="test_lib" title="test_partial_functions" class="checkmark">&#10004;</a>336 </span><span class="Identifier">partial_functions</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(f) {
<span id="L337" class="LineNr">337 </span>  <span class="Statement">return</span> <span class="Constant">2</span> <span class="Type">**</span> f;
<span id="L338" class="LineNr">338 </span>};
<span id="L339" class="LineNr">339 </span>
<span id="L340" class="LineNr">340 </span><span class="Comment">/* Takes two functions assigning values to vars and tests whether they are</span>
<span id="L341" class="LineNr">341 </span><span class="Comment">   compatible, i.e. do not assign different values to the same var.  */</span>
<span id="L342" class="LineNr"><a href="#tl-204" data-file="test_lib" title="test_compatible_values" class="checkmark">&#10004;</a>342 </span><span class="Identifier">compatible_values</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(f, g) {
<span id="L343" class="LineNr">343 </span>  h <span class="Statement">:=</span> f <span class="Type">+</span> g;
<span id="L344" class="LineNr">344 </span>  <span class="Statement">return</span> <span class="Type">forall</span>(var <span class="Type">in</span> <span class="Identifier">domain</span>(f) <span class="Type">+</span> <span class="Identifier">domain</span>(g) <span class="Type">|</span> h[var] <span class="Type">!=</span> <span class="Constant">om</span>);
<span id="L345" class="LineNr">345 </span>};
<span id="L346" class="LineNr">346 </span><span class="Identifier">compat</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(f, g) { <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-342">compatible_values</a>(f, g); }; <span class="Comment">// alias</span>
<span id="L347" class="LineNr">347 </span>
<span id="L348" class="LineNr">348 </span><span class="Comment">/* Takes partial state ps, which is a function assigning values to a set of</span>
<span id="L349" class="LineNr">349 </span><span class="Comment">   variables, and set of complete states cs, a set of functions assigning </span>
<span id="L350" class="LineNr">350 </span><span class="Comment">   values to a larger set of variables and returns the subset of cs compatible </span>
<span id="L351" class="LineNr">351 </span><span class="Comment">   with ps.  */</span>
<span id="L352" class="LineNr"><a href="#tl-219" data-file="test_lib" title="test_compatible_complete_states" class="checkmark">&#10004;</a>352 </span><span class="Identifier">compatible_complete_states</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(ps, cs) {
<span id="L353" class="LineNr">353 </span>  <span class="Statement">return</span> { c <span class="Type">:</span> c <span class="Type">in</span> cs
<span id="L354" class="LineNr">354 </span>             <span class="Type">|</span> <span class="Type">forall</span>(d <span class="Type">in</span> <span class="Identifier">domain</span>(ps) <span class="Type">|</span> c[d] <span class="Type">==</span> ps[d] ) };
<span id="L355" class="LineNr">355 </span>};
<span id="L356" class="LineNr">356 </span><span class="Identifier">compat_compl_sts</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ps, cs) { <span class="Comment">// alias </span>
<span id="L357" class="LineNr">357 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-352">compatible_complete_states</a>(ps, cs);
<span id="L358" class="LineNr">358 </span>};
<span id="L359" class="LineNr">359 </span>
<span id="L360" class="LineNr">360 </span><span class="Comment">/* Takes a set of complete states and returns a set of events whose compatible</span>
<span id="L361" class="LineNr">361 </span><span class="Comment">   complete states would sum to to the set of complete states. */</span>
<span id="L362" class="LineNr">362 </span><span class="Identifier">states2events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(css) {
<span id="L363" class="LineNr">363 </span>  vars <span class="Statement">:=</span> <span class="Identifier">domain</span>(css[<span class="Constant">1</span>]);
<span id="L364" class="LineNr">364 </span>  <span class="Comment">/* Variables are unneeded when for all complete states, the states with the </span>
<span id="L365" class="LineNr">365 </span><span class="Comment">     values of all the other variables remaining the same but with the </span>
<span id="L366" class="LineNr">366 </span><span class="Comment">     candidate variable being assigned true and false are both in the set of</span>
<span id="L367" class="LineNr">367 </span><span class="Comment">     complete states.  */</span>
<span id="L368" class="LineNr">368 </span>  unneeded <span class="Statement">:=</span> { v <span class="Type">:</span> v <span class="Type">in</span> vars
<span id="L369" class="LineNr">369 </span>                  <span class="Type">|</span> <span class="Type">forall</span>( cs <span class="Type">in</span> css <span class="Type">|</span>
<span id="L370" class="LineNr">370 </span>                      <span class="Identifier">restrict_domain</span>(cs, vars <span class="Type">-</span> v) <span class="Type">+</span> {[v,  <span class="Constant">true</span>]}  <span class="Type">in</span> css <span class="Type">&amp;&amp;</span>
<span id="L371" class="LineNr">371 </span>                      <span class="Identifier">restrict_domain</span>(cs, vars <span class="Type">-</span> v) <span class="Type">+</span> {[v, <span class="Constant">false</span>]} <span class="Type">in</span> css
<span id="L372" class="LineNr">372 </span>                    )
<span id="L373" class="LineNr">373 </span>  };
<span id="L374" class="LineNr">374 </span>  <span class="Statement">return</span> { <a class="Identifier code-proc-link" href="#l-751">restrict_domain</a>(cs, vars <span class="Type">-</span> unneeded) <span class="Type">:</span> cs <span class="Type">in</span> css };
<span id="L375" class="LineNr">375 </span>};
<span id="L376" class="LineNr">376 </span>
<span id="L377" class="LineNr"><a href="#tl-232" data-file="test_lib" title="test_proc2func" class="checkmark">&#10004;</a>377 </span><span class="Identifier">proc2func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(p, dom) {
<span id="L378" class="LineNr">378 </span>  <span class="Statement">return</span> { [d, <span class="Identifier">p</span>(d)] <span class="Type">:</span> d <span class="Type">in</span> dom };
<span id="L379" class="LineNr">379 </span>};
<span id="L380" class="LineNr">380 </span>
<span id="L381" class="LineNr">381 </span><span class="Comment">// Breaks apart a var label of form 'V_ti' into ['V', i]</span>
<span id="L382" class="LineNr"><a href="#tl-240" data-file="test_lib" title="test_parse_var" class="checkmark">&#10004;</a>382 </span><span class="Identifier">parse_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(label) {
<span id="L383" class="LineNr">383 </span>  j <span class="Statement">:=</span> <span class="Type">#</span>label;
<span id="L384" class="LineNr">384 </span>  <span class="Statement">while</span> (<span class="Identifier">int</span>(label[j]) <span class="Type">!=</span> <span class="Constant">om</span> <span class="Type">&amp;&amp;</span> j <span class="Type">!=</span> <span class="Constant">1</span>) {
<span id="L385" class="LineNr">385 </span>    j <span class="Statement">-=</span> <span class="Constant">1</span>;
<span id="L386" class="LineNr">386 </span>  }
<span id="L387" class="LineNr">387 </span>  t <span class="Statement">:=</span> <span class="Identifier">int</span>(label[(j <span class="Type">+</span> <span class="Constant">1</span>)<span class="Statement">..</span>]);
<span id="L388" class="LineNr">388 </span>  <span class="Statement">assert</span>(t <span class="Type">!=</span> <span class="Constant">om</span>, <span class="Constant">"Error: Expected var label to have time subscript."</span>);
<span id="L389" class="LineNr">389 </span>  var <span class="Statement">:=</span> label[<span class="Constant">1</span><span class="Statement">..</span>(j <span class="Type">-</span> <span class="Constant">2</span>)];
<span id="L390" class="LineNr">390 </span>  <span class="Statement">return</span> [var, t];
<span id="L391" class="LineNr">391 </span>};
<span id="L392" class="LineNr">392 </span>
<span id="L393" class="LineNr"><a href="#tl-247" data-file="test_lib" title="test_orig_var" class="checkmark">&#10004;</a>393 </span><span class="Identifier">orig_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(label) {
<span id="L394" class="LineNr">394 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-382">parse_var</a>(label)[<span class="Constant">1</span>];
<span id="L395" class="LineNr">395 </span>};
<span id="L396" class="LineNr">396 </span>
<span id="L397" class="LineNr"><a href="#tl-254" data-file="test_lib" title="test_var_time" class="checkmark">&#10004;</a>397 </span><span class="Identifier">var_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(label) {
<span id="L398" class="LineNr">398 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-382">parse_var</a>(label)[<span class="Constant">2</span>];
<span id="L399" class="LineNr">399 </span>};
<span id="L400" class="LineNr">400 </span>
<span id="L401" class="LineNr">401 </span><span class="Comment">/* Takes an assignment of values to variables and adds a time subscript to the </span>
<span id="L402" class="LineNr">402 </span><span class="Comment">   variables' labels. */</span>
<span id="L403" class="LineNr"><a href="#tl-261" data-file="test_lib" title="test_assign_time" class="checkmark">&#10004;</a>403 </span><span class="Identifier">assign_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(g, t) {
<span id="L404" class="LineNr">404 </span>  <span class="Statement">return</span> { [ y<span class="Type">+</span><span class="Constant">'_t'</span><span class="Type">+</span>t, g[y] ] <span class="Type">:</span> y <span class="Type">in</span> <span class="Identifier">domain</span>(g) };
<span id="L405" class="LineNr">405 </span>};
<span id="L406" class="LineNr">406 </span>
<span id="L407" class="LineNr">407 </span><span class="Comment">/* Takes an assignment of values to variables and removes time subscripts </span>
<span id="L408" class="LineNr">408 </span><span class="Comment">   from the variables' labels. */</span>
<span id="L409" class="LineNr"><a href="#tl-269" data-file="test_lib" title="test_drop_time" class="checkmark">&#10004;</a>409 </span><span class="Identifier">drop_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(g) {
<span id="L410" class="LineNr">410 </span>  <span class="Statement">return</span> { [ <a class="Identifier code-proc-link" href="#l-393">orig_var</a>(y), g[y] ] <span class="Type">:</span> y <span class="Type">in</span> <span class="Identifier">domain</span>(g) };
<span id="L411" class="LineNr">411 </span>};
<span id="L412" class="LineNr">412 </span>
<span id="L413" class="LineNr">413 </span><span class="Comment">/* From Hilbert System, Wikipedia </span>
<span id="L414" class="LineNr">414 </span><span class="Comment">     <a href="https://en.wikipedia.org/w/index.php?title=Hilbert_system&amp;oldid=873786806" target="_blank">https://en.wikipedia.org/w/index.php?title=Hilbert_system&amp;oldid=873786806</a></span>
<span id="L415" class="LineNr">415 </span><span class="Comment">*/</span>
<span id="L416" class="LineNr">416 </span><span class="Identifier">is_logical_truth</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L417" class="LineNr">417 </span>  vars <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-526">parse_vars</a>(expr);
<span id="L418" class="LineNr">418 </span>
<span id="L419" class="LineNr">419 </span>  <span class="Comment">/* Axiom schemes</span>
<span id="L420" class="LineNr">420 </span><span class="Comment">     Redundant: </span>
<span id="L421" class="LineNr">421 </span><span class="Comment">       P1: phi -&gt; phi</span>
<span id="L422" class="LineNr">422 </span><span class="Comment">       as_p1 := procedure(phi) { return Implies(phi, phi); };  </span>
<span id="L423" class="LineNr">423 </span><span class="Comment">      </span>
<span id="L424" class="LineNr">424 </span><span class="Comment">     P2: phi -&gt; (psi -&gt; phi)  */</span>
<span id="L425" class="LineNr">425 </span>  <span class="Identifier">as_p2</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi) { <span class="Statement">return</span> <span class="Identifier">Implies</span>(phi, <span class="Identifier">Implies</span>(psi, phi)); };
<span id="L426" class="LineNr">426 </span>  <span class="Comment">// P3: (phi -&gt; (psi -&gt; xi)) -&gt; ((phi -&gt; psi) -&gt; (phi -&gt; xi))</span>
<span id="L427" class="LineNr">427 </span>  <span class="Identifier">as_p3</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi, xi) {
<span id="L428" class="LineNr">428 </span>    <span class="Statement">return</span> <span class="Identifier">Implies</span>(
<span id="L429" class="LineNr">429 </span>             <span class="Identifier">Implies</span>(phi, <span class="Identifier">Implies</span>(psi, xi)),
<span id="L430" class="LineNr">430 </span>             <span class="Identifier">Implies</span>(<span class="Identifier">Implies</span>(phi, psi), <span class="Identifier">Implies</span>(phi, xi))
<span id="L431" class="LineNr">431 </span>           );
<span id="L432" class="LineNr">432 </span>  };
<span id="L433" class="LineNr">433 </span>  <span class="Comment">// P4: (~phi -&gt; ~psi) -&gt; (psi -&gt; phi)</span>
<span id="L434" class="LineNr">434 </span>  <span class="Identifier">as_p4</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi) {
<span id="L435" class="LineNr">435 </span>    <span class="Statement">return</span> <span class="Identifier">Implies</span>(<span class="Identifier">Implies</span>(<span class="Identifier">Not</span>(phi), <span class="Identifier">Not</span>(psi)), <span class="Identifier">Implies</span>(psi, phi));
<span id="L436" class="LineNr">436 </span>  };
<span id="L437" class="LineNr">437 </span>  <span class="Comment">// Q5: Vx(phi) -&gt; phi[x := t] where t may be substituted for x in phi</span>
<span id="L438" class="LineNr">438 </span>  <span class="Identifier">as_q5</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(var, phi) {
<span id="L439" class="LineNr">439 </span>    <span class="Statement">return</span> { <span class="Identifier">Implies</span>( <span class="Identifier">Forall</span>(var, phi), <a class="Identifier code-proc-link" href="#l-540">sub</a>(phi, var, term))
<span id="L440" class="LineNr">440 </span>             <span class="Type">:</span> term <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-104">atomic_terms</a>(expr) };
<span id="L441" class="LineNr">441 </span>  };
<span id="L442" class="LineNr">442 </span>  <span class="Comment">// Q6: Vx(phi -&gt; psi) -&gt; (Vx(phi) -&gt; Vx(psi))</span>
<span id="L443" class="LineNr">443 </span>  <span class="Identifier">as_q6</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(var, phi, psi) {
<span id="L444" class="LineNr">444 </span>    <span class="Statement">return</span> <span class="Identifier">Implies</span>( <span class="Identifier">Forall</span>(var, <span class="Identifier">Implies</span>(phi, psi)),
<span id="L445" class="LineNr">445 </span>                    <span class="Identifier">Implies</span>(<span class="Identifier">Forall</span>(var, phi), <span class="Identifier">Forall</span>(var, psi)) );
<span id="L446" class="LineNr">446 </span>  };
<span id="L447" class="LineNr">447 </span>  <span class="Comment">// Q7: phi -&gt; Vx phi where x not in phi</span>
<span id="L448" class="LineNr">448 </span>  <span class="Identifier">as_q7</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, var) {
<span id="L449" class="LineNr">449 </span>    <span class="Statement">if</span> (var <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-94">atomic_exprs</a>(phi)) {
<span id="L450" class="LineNr">450 </span>      <span class="Statement">return</span> {};
<span id="L451" class="LineNr">451 </span>    } <span class="Statement">else</span> {
<span id="L452" class="LineNr">452 </span>      <span class="Statement">return</span> { <span class="Identifier">Implies</span>(phi, <span class="Identifier">Forall</span>(var, phi)) };
<span id="L453" class="LineNr">453 </span>    }
<span id="L454" class="LineNr">454 </span>  };
<span id="L455" class="LineNr">455 </span>  <span class="Comment">/* Conservative Extensions</span>
<span id="L456" class="LineNr">456 </span><span class="Comment">     Conjunction:</span>
<span id="L457" class="LineNr">457 </span><span class="Comment">       Introduction: phi -&gt; (psi -&gt; (phi ^ psi))  */</span>
<span id="L458" class="LineNr">458 </span>  <span class="Identifier">conj_intr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi) {
<span id="L459" class="LineNr">459 </span>    <span class="Statement">return</span> <span class="Identifier">Implies</span>(phi, <span class="Identifier">Implies</span>(psi, <span class="Identifier">And</span>(phi, psi)));
<span id="L460" class="LineNr">460 </span>  };
<span id="L461" class="LineNr">461 </span>  <span class="Comment">//   Elimination: (phi ^ psi) -&gt; phi   and   (phi ^ psi) -&gt; psi</span>
<span id="L462" class="LineNr">462 </span>  <span class="Identifier">conj_elim</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi) {
<span id="L463" class="LineNr">463 </span>    <span class="Statement">return</span> { <span class="Identifier">Implies</span>(<span class="Identifier">And</span>(phi, psi), phi),
<span id="L464" class="LineNr">464 </span>             <span class="Identifier">Implies</span>(<span class="Identifier">And</span>(phi, psi), psi) };
<span id="L465" class="LineNr">465 </span>  };
<span id="L466" class="LineNr">466 </span>  <span class="Comment">/* Disjunction:</span>
<span id="L467" class="LineNr">467 </span><span class="Comment">       Introduction: phi -&gt; (phi v psi)   and   psi -&gt; (phi v psi)  */</span>
<span id="L468" class="LineNr">468 </span>  <span class="Identifier">disj_intr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi) {
<span id="L469" class="LineNr">469 </span>    <span class="Statement">return</span> { <span class="Identifier">Implies</span>(phi, <span class="Identifier">Or</span>(phi, psi)),
<span id="L470" class="LineNr">470 </span>             <span class="Identifier">Implies</span>(psi, <span class="Identifier">Or</span>(phi, psi)) };
<span id="L471" class="LineNr">471 </span>  };
<span id="L472" class="LineNr">472 </span>  <span class="Comment">//   Elimination: (phi -&gt; xi) -&gt; ((psi -&gt; xi) -&gt; ((phi v psi) -&gt; xi))</span>
<span id="L473" class="LineNr">473 </span>  <span class="Identifier">disj_elim</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi, xi) {
<span id="L474" class="LineNr">474 </span>    <span class="Statement">return</span> <span class="Identifier">Implies</span>( <span class="Identifier">Implies</span>(phi, xi),
<span id="L475" class="LineNr">475 </span>                    <span class="Identifier">Implies</span>( <span class="Identifier">Implies</span>(psi, xi),
<span id="L476" class="LineNr">476 </span>                             <span class="Identifier">Implies</span>( <span class="Identifier">Or</span>(phi, psi), xi)));
<span id="L477" class="LineNr">477 </span>  };
<span id="L478" class="LineNr">478 </span>  <span class="Comment">/* Existential Quantification </span>
<span id="L479" class="LineNr">479 </span><span class="Comment">     Introduction: Vx(phi -&gt; Ey(phi[x := y]))  */</span>
<span id="L480" class="LineNr">480 </span>  <span class="Identifier">ex_intr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, x_var, y_var) {
<span id="L481" class="LineNr">481 </span>    <span class="Statement">return</span> <span class="Identifier">Forall</span>(x_var, <span class="Identifier">Implies</span>(phi, <span class="Identifier">Exists</span>(y_var, <a class="Identifier code-proc-link" href="#l-540">sub</a>(phi, x_var, y_var))));
<span id="L482" class="LineNr">482 </span>  };
<span id="L483" class="LineNr">483 </span>  <span class="Comment">// Elimination: Vx(phi -&gt; psi) -&gt; (Ex(phi) -&gt; psi) where !(x in psi)</span>
<span id="L484" class="LineNr">484 </span>  <span class="Identifier">ex_elim</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi, var) {
<span id="L485" class="LineNr">485 </span>    <span class="Statement">if</span> (var <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-94">atomic_exprs</a>(psi)) {
<span id="L486" class="LineNr">486 </span>      <span class="Statement">return</span> {};
<span id="L487" class="LineNr">487 </span>    } <span class="Statement">else</span> {
<span id="L488" class="LineNr">488 </span>      <span class="Statement">return</span> { <span class="Identifier">Implies</span>( <span class="Identifier">Forall</span>(var, <span class="Identifier">Implies</span>(phi, psi)),
<span id="L489" class="LineNr">489 </span>                        <span class="Identifier">Implies</span>( <span class="Identifier">Exists</span>(var, phi), psi)) };
<span id="L490" class="LineNr">490 </span>    }
<span id="L491" class="LineNr">491 </span>  };
<span id="L492" class="LineNr">492 </span>  <span class="Comment">// Modus Ponens Rule of Inference</span>
<span id="L493" class="LineNr">493 </span>  <span class="Comment">// phi, phi -&gt; psi |- psi</span>
<span id="L494" class="LineNr">494 </span>  <span class="Identifier">modus_ponens</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(phi, psi) {
<span id="L495" class="LineNr">495 </span>    <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(psi) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(psi) <span class="Type">==</span> <span class="Constant">'Implies'</span> <span class="Type">&amp;&amp;</span> <span class="Identifier">args</span>(psi)[<span class="Constant">1</span>] <span class="Type">==</span> phi) {
<span id="L496" class="LineNr">496 </span>      <span class="Statement">return</span> { <span class="Identifier">args</span>(psi)[<span class="Constant">2</span>] };
<span id="L497" class="LineNr">497 </span>    } <span class="Statement">else</span> {
<span id="L498" class="LineNr">498 </span>      <span class="Statement">return</span> {};
<span id="L499" class="LineNr">499 </span>    }
<span id="L500" class="LineNr">500 </span>  };
<span id="L501" class="LineNr">501 </span>
<span id="L502" class="LineNr">502 </span>  <span class="Identifier">derive_more</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(exprs) {
<span id="L503" class="LineNr">503 </span>    <span class="Statement">return</span>
<span id="L504" class="LineNr">504 </span>      (<span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-448">as_q7</a>(phi, var) <span class="Type">:</span> [phi, var] <span class="Type">in</span> exprs <span class="Type">&gt;&lt;</span> vars }) <span class="Type">+</span>
<span id="L505" class="LineNr">505 </span>      (<span class="Type">+/</span> { { <a class="Identifier code-proc-link" href="#l-425">as_p2</a>(phi, psi), <a class="Identifier code-proc-link" href="#l-434">as_p4</a>(phi, psi), <a class="Identifier code-proc-link" href="#l-458">conj_intr</a>(phi, psi) } <span class="Type">+</span>
<span id="L506" class="LineNr">506 </span>              { <span class="Identifier">as_q6</span>(var, phi, psi) <span class="Type">:</span> var <span class="Type">in</span> vars } <span class="Type">+</span>
<span id="L507" class="LineNr">507 </span>              <span class="Identifier">conj_elim</span>(phi, psi) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-468">disj_intr</a>(phi, psi) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-494">modus_ponens</a>(phi, psi)
<span id="L508" class="LineNr">508 </span>            <span class="Type">:</span> [phi, psi] <span class="Type">in</span> exprs <span class="Type">&gt;&lt;</span> exprs }) <span class="Type">+</span>
<span id="L509" class="LineNr">509 </span>      { <span class="Identifier">as_p3</span>(phi, psi, xi) <span class="Type">:</span> [phi, psi, xi] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-279">iter_prod</a>(exprs, <span class="Constant">3</span>) } <span class="Type">+</span>
<span id="L510" class="LineNr">510 </span>      (<span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-438">as_q5</a>(var, phi, vars) <span class="Type">:</span> [var, phi] <span class="Type">in</span> vars <span class="Type">&gt;&lt;</span> exprs }) <span class="Type">+</span>
<span id="L511" class="LineNr">511 </span>      (<span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-484">ex_elim</a>(phi, psi, var)
<span id="L512" class="LineNr">512 </span>            <span class="Type">:</span> [phi, psi, var] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-269">cart_prod</a>([exprs, exprs, vars]) } ) <span class="Type">+</span>
<span id="L513" class="LineNr">513 </span>      { <span class="Identifier">ex_intr</span>(phi, x_var, y_var)
<span id="L514" class="LineNr">514 </span>            <span class="Type">:</span> [phi, x_var, y_var] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-269">cart_prod</a>([exprs,vars,vars]) };
<span id="L515" class="LineNr">515 </span>  };
<span id="L516" class="LineNr">516 </span>  <span class="Identifier">derive</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(exprs, j) {
<span id="L517" class="LineNr">517 </span>    <span class="Statement">if</span> (j <span class="Type">==</span> <span class="Constant">0</span>) {
<span id="L518" class="LineNr">518 </span>      <span class="Statement">return</span> exprs;
<span id="L519" class="LineNr">519 </span>    } <span class="Statement">else</span> {
<span id="L520" class="LineNr">520 </span>      <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-502">derive_more</a>(<a class="Identifier code-proc-link" href="#l-516">derive</a>(exprs, j <span class="Type">-</span> <span class="Constant">1</span>));
<span id="L521" class="LineNr">521 </span>    }
<span id="L522" class="LineNr">522 </span>  };
<span id="L523" class="LineNr">523 </span>  <span class="Statement">return</span> expr <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-516">derive</a>(<a class="Identifier code-proc-link" href="#l-552">subformulas</a>(expr), <span class="Constant">10</span> <span class="Type">**</span> <span class="Constant">6</span>);
<span id="L524" class="LineNr">524 </span>};
<span id="L525" class="LineNr">525 </span>
<span id="L526" class="LineNr"><a href="#tl-286" data-file="test_lib" title="test_parse_vars" class="checkmark">&#10004;</a>526 </span><span class="Identifier">parse_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L527" class="LineNr">527 </span>  <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr)) {
<span id="L528" class="LineNr">528 </span>    parse_more <span class="Statement">:=</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-526">parse_vars</a>(arg) <span class="Type">:</span> arg <span class="Type">in</span> <span class="Identifier">args</span>(expr) };
<span id="L529" class="LineNr">529 </span>    <span class="Statement">if</span> (<span class="Identifier">fct</span>(expr) <span class="Type">in</span> {<span class="Constant">'Forall'</span>, <span class="Constant">'Exists'</span>}) {
<span id="L530" class="LineNr">530 </span>      <span class="Statement">return</span> { <span class="Identifier">args</span>(expr)[<span class="Constant">1</span>] } <span class="Type">+</span> parse_more;
<span id="L531" class="LineNr">531 </span>    } <span class="Statement">else</span> {
<span id="L532" class="LineNr">532 </span>      <span class="Statement">return</span> parse_more;
<span id="L533" class="LineNr">533 </span>    }
<span id="L534" class="LineNr">534 </span>  } <span class="Statement">else</span> {
<span id="L535" class="LineNr">535 </span>    <span class="Statement">return</span> {};
<span id="L536" class="LineNr">536 </span>  }
<span id="L537" class="LineNr">537 </span>};
<span id="L538" class="LineNr">538 </span>
<span id="L539" class="LineNr">539 </span><span class="Comment">/* Substitute any occurrences of var in expr with sub_var instead. */</span>
<span id="L540" class="LineNr"><a href="#tl-294" data-file="test_lib" title="test_sub" class="checkmark">&#10004;</a>540 </span><span class="Identifier">sub</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr, var, sub_var) {
<span id="L541" class="LineNr">541 </span>  <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr)) {
<span id="L542" class="LineNr">542 </span>    <span class="Statement">return</span> <span class="Identifier">makeTerm</span>(<span class="Identifier">fct</span>(expr), [<a class="Identifier code-proc-link" href="#l-540">sub</a>(arg, var, sub_var) <span class="Type">:</span> arg <span class="Type">in</span> <span class="Identifier">args</span>(expr)]);
<span id="L543" class="LineNr">543 </span>  } <span class="Statement">else</span> {
<span id="L544" class="LineNr">544 </span>    <span class="Statement">if</span> (expr <span class="Type">==</span> var) {
<span id="L545" class="LineNr">545 </span>      <span class="Statement">return</span> sub_var;
<span id="L546" class="LineNr">546 </span>    } <span class="Statement">else</span> {
<span id="L547" class="LineNr">547 </span>      <span class="Statement">return</span> expr;
<span id="L548" class="LineNr">548 </span>    }
<span id="L549" class="LineNr">549 </span>  }
<span id="L550" class="LineNr">550 </span>};
<span id="L551" class="LineNr">551 </span>
<span id="L552" class="LineNr"><a href="#tl-302" data-file="test_lib" title="test_subformulas" class="checkmark">&#10004;</a>552 </span><span class="Identifier">subformulas</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr) {
<span id="L553" class="LineNr">553 </span>  <span class="Statement">if</span> (<span class="Identifier">isTerm</span>(expr) <span class="Type">&amp;&amp;</span> <span class="Identifier">fct</span>(expr) <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-72">connectives</a>()) {
<span id="L554" class="LineNr">554 </span>    <span class="Statement">return</span> { expr } <span class="Type">+</span> (<span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-552">subformulas</a>(arg) <span class="Type">:</span> arg <span class="Type">in</span> <span class="Identifier">args</span>(expr) })
<span id="L555" class="LineNr">555 </span>                    <span class="Type">-</span> <a class="Identifier code-proc-link" href="#l-526">parse_vars</a>(expr);
<span id="L556" class="LineNr">556 </span>  } <span class="Statement">else</span> {
<span id="L557" class="LineNr">557 </span>    <span class="Statement">return</span> { expr };
<span id="L558" class="LineNr">558 </span>  }
<span id="L559" class="LineNr">559 </span>};
<span id="L560" class="LineNr">560 </span>
<span id="L561" class="LineNr">561 </span><span class="Comment">/* Hausdorff Distance</span>
<span id="L562" class="LineNr">562 </span><span class="Comment">   "It is the greatest of all the distances from a point in one set to the </span>
<span id="L563" class="LineNr">563 </span><span class="Comment">    closest point in the other set."   </span>
<span id="L564" class="LineNr">564 </span><span class="Comment">      -- <a href="https://en.wikipedia.org/wiki/Hausdorff_distance" target="_blank">https://en.wikipedia.org/wiki/Hausdorff_distance</a> </span>
<span id="L565" class="LineNr">565 </span><span class="Comment">*/</span>
<span id="L566" class="LineNr"><a href="#tl-313" data-file="test_lib" title="test_hausdorff_dist" class="checkmark">&#10004;</a>566 <a title="1.2.3.5.2.3.4" class="back_to_li" href="#t-1-2-3-5-2-3-4"><i class="fas fa-list-ol"></i></a><a title="1.4.2.2.3" class="back_to_li" href="#t-1-4-2-2-3"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">hausdorff_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(s1, s2, dist_f) {
<span id="L567" class="LineNr">567 </span>  <span class="Identifier">dist_to_closest</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(e1) {
<span id="L568" class="LineNr">568 </span>    <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-10">min</a>([ <span class="Identifier">dist_f</span>(e1, e2) <span class="Type">:</span> e2 <span class="Type">in</span> s2 ]);
<span id="L569" class="LineNr">569 </span>  };
<span id="L570" class="LineNr">570 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-15">max</a>([ <a class="Identifier code-proc-link" href="#l-567">dist_to_closest</a>(e1) <span class="Type">:</span> e1 <span class="Type">in</span> s1 ]);
<span id="L571" class="LineNr">571 </span>};
<span id="L572" class="LineNr">572 </span>
<span id="L573" class="LineNr">573 </span><span class="Comment">/* Kendalls Tau Distance</span>
<span id="L574" class="LineNr">574 </span><span class="Comment">   Takes two strict ordinal utility functions with the same domain and counts </span>
<span id="L575" class="LineNr">575 </span><span class="Comment">   the number of discordant pairs. Returns a normalized distance from 0 - 1.</span>
<span id="L576" class="LineNr">576 </span><span class="Comment">   Each u1, u2 is a set of setlx functors Succ(state1, state2). (Succ stands </span>
<span id="L577" class="LineNr">577 </span><span class="Comment">   for succeeds.) States are logical expressions, i.e. setlx functors of </span>
<span id="L578" class="LineNr">578 </span><span class="Comment">   combinators on string base propositions. </span>
<span id="L579" class="LineNr">579 </span>
<span id="L580" class="LineNr">580 </span><span class="Comment">   "Kendall tau distance is also called bubble-sort distance since it is </span>
<span id="L581" class="LineNr">581 </span><span class="Comment">    equivalent to the number of swaps that the bubble sort algorithm would </span>
<span id="L582" class="LineNr">582 </span><span class="Comment">    take to place one list in the same order as the other list."</span>
<span id="L583" class="LineNr">583 </span><span class="Comment">      -- <a href="https://en.wikipedia.org/wiki/Kendall_tau_distance" target="_blank">https://en.wikipedia.org/wiki/Kendall_tau_distance</a>  </span>
<span id="L584" class="LineNr">584 </span><span class="Comment">*/</span>
<span id="L585" class="LineNr"><a href="#tl-321" data-file="test_lib" title="test_kendalls_tau_dist" class="checkmark">&#10004;</a>585 <a title="1.2.3.5.2.3.5" class="back_to_li" href="#t-1-2-3-5-2-3-5"><i class="fas fa-list-ol"></i></a><a title="1.4.2.2.4" class="back_to_li" href="#t-1-4-2-2-4"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">kendalls_tau_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(u1, u2) {
<span id="L586" class="LineNr">586 </span>  pairs <span class="Statement">:=</span> { [x,y] <span class="Type">:</span> [x,y] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-606">states_u</a>(u1) <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#l-606">states_u</a>(u1) <span class="Type">|</span> x <span class="Type">!=</span> y };
<span id="L587" class="LineNr">587 </span>  <span class="Comment">// Discordant (unordered) pairs</span>
<span id="L588" class="LineNr">588 </span>  disc_un_pairs <span class="Statement">:=</span> <span class="Type">#</span>{ [x,y] <span class="Type">:</span> [x,y] <span class="Type">in</span> pairs
<span id="L589" class="LineNr">589 </span>                      <span class="Type">|</span> (<span class="Identifier">Succ</span>(x,y) <span class="Type">in</span> u1 <span class="Type">&amp;&amp;</span> <span class="Identifier">Succ</span>(y,x) <span class="Type">in</span> u2) <span class="Type">||</span>
<span id="L590" class="LineNr">590 </span>                        (<span class="Identifier">Succ</span>(x,y) <span class="Type">in</span> u2 <span class="Type">&amp;&amp;</span> <span class="Identifier">Succ</span>(y,x) <span class="Type">in</span> u1)
<span id="L591" class="LineNr">591 </span>                    } <span class="Type">/</span> <span class="Constant">2</span>;
<span id="L592" class="LineNr">592 </span>  n <span class="Statement">:=</span> <span class="Type">#</span><a class="Identifier code-proc-link" href="#l-606">states_u</a>(u1);
<span id="L593" class="LineNr">593 </span>  <span class="Statement">return</span> disc_un_pairs <span class="Type">/</span> (n <span class="Type">*</span> (n <span class="Type">-</span> <span class="Constant">1</span>) <span class="Type">/</span> <span class="Constant">2</span>);
<span id="L594" class="LineNr">594 </span>};
<span id="L595" class="LineNr">595 </span>
<span id="L596" class="LineNr">596 </span><span class="Comment">/* Takes an ordinal utility function expressed as a set of SuccEq setlx</span>
<span id="L597" class="LineNr">597 </span><span class="Comment">   functors comparing events or states and returns the set of atomic variables</span>
<span id="L598" class="LineNr">598 </span><span class="Comment">   those events or states range over.  */</span>
<span id="L599" class="LineNr"><a href="#tl-339" data-file="test_lib" title="test_atom_u" class="checkmark">&#10004;</a>599 </span><span class="Identifier">atom_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(u) {
<span id="L600" class="LineNr">600 </span>  states <span class="Statement">:=</span> <span class="Type">+/</span> { { <span class="Identifier">args</span>(pref)[<span class="Constant">1</span>], <span class="Identifier">args</span>(pref)[<span class="Constant">2</span>] } <span class="Type">:</span> pref <span class="Type">in</span> u };
<span id="L601" class="LineNr">601 </span>  <span class="Statement">return</span> <span class="Type">+/</span> { <span class="Identifier">domain</span>(state) <span class="Type">:</span> state <span class="Type">in</span> states };
<span id="L602" class="LineNr">602 </span>};
<span id="L603" class="LineNr">603 </span>
<span id="L604" class="LineNr">604 </span><span class="Comment">/* Takes an ordinal utility function and returns the states that are compared</span>
<span id="L605" class="LineNr">605 </span><span class="Comment">   in them.  */</span>
<span id="L606" class="LineNr">606 </span><span class="Identifier">states_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(u) {
<span id="L607" class="LineNr">607 </span>  <span class="Statement">return</span> <span class="Type">+/</span> { { <span class="Identifier">args</span>(pref)[<span class="Constant">1</span>], <span class="Identifier">args</span>(pref)[<span class="Constant">2</span>] } <span class="Type">:</span> pref <span class="Type">in</span> u };
<span id="L608" class="LineNr">608 </span>};
<span id="L609" class="LineNr">609 </span>
<span id="L610" class="LineNr">610 </span><span class="Comment">/* Cardinal Utility Function to Ordinal Utility Function */</span>
<span id="L611" class="LineNr"><a href="#tl-347" data-file="test_lib" title="test_card_u_to_ord_u" class="checkmark">&#10004;</a>611 <a title="1.2.3.5.2.3.2.2" class="back_to_li" href="#t-1-2-3-5-2-3-2-2"><i class="fas fa-list-ol"></i></a><a title="1.4.2.2.1" class="back_to_li" href="#t-1-4-2-2-1"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">card_u_to_ord_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(card_u, state_space, probs) {
<span id="L612" class="LineNr">612 </span>  poss_lotteries <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ { [state, prob] <span class="Type">:</span> prob <span class="Type">in</span> probs }
<span id="L613" class="LineNr">613 </span>                              <span class="Type">:</span> state <span class="Type">in</span> state_space });
<span id="L614" class="LineNr">614 </span>  lotteries <span class="Statement">:=</span> { lottery <span class="Type">:</span> lottery <span class="Type">in</span> poss_lotteries
<span id="L615" class="LineNr">615 </span>                         <span class="Type">|</span> <span class="Type">+/</span> [ prob <span class="Type">:</span> [state, prob] <span class="Type">in</span> lottery ] <span class="Type">==</span> <span class="Constant">1</span> };
<span id="L616" class="LineNr">616 </span>  <span class="Identifier">compare_lots</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(lot1, lot2) {
<span id="L617" class="LineNr">617 </span>    <span class="Identifier">util_of_lot</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(lot) {
<span id="L618" class="LineNr">618 </span>      <span class="Statement">return</span> <span class="Type">+/</span> { card_u[state] <span class="Type">*</span> prob <span class="Type">:</span> [state, prob] <span class="Type">in</span> lot };
<span id="L619" class="LineNr">619 </span>    };
<span id="L620" class="LineNr">620 </span>    <span class="Statement">if</span> (<a class="Identifier code-proc-link" href="#l-617">util_of_lot</a>(lot1) <span class="Type">&gt;=</span> <a class="Identifier code-proc-link" href="#l-617">util_of_lot</a>(lot2)) {
<span id="L621" class="LineNr">621 </span>      <span class="Statement">return</span> <span class="Identifier">SuccEq</span>(lot1, lot2); <span class="Comment">// Succeeds or equals</span>
<span id="L622" class="LineNr">622 </span>    } <span class="Statement">else</span> {
<span id="L623" class="LineNr">623 </span>      <span class="Statement">return</span> <span class="Identifier">SuccEq</span>(lot2, lot1);
<span id="L624" class="LineNr">624 </span>    }
<span id="L625" class="LineNr">625 </span>  };
<span id="L626" class="LineNr">626 </span>  <span class="Statement">return</span> { <a class="Identifier code-proc-link" href="#l-616">compare_lots</a>(lot1, lot2) <span class="Type">:</span> [lot1, lot2] <span class="Type">in</span> lotteries <span class="Type">&gt;&lt;</span> lotteries };
<span id="L627" class="LineNr">627 </span>};
<span id="L628" class="LineNr">628 </span>
<span id="L629" class="LineNr">629 </span><span class="Comment">/* Additive Utility Function to Cardinal Utility Function: </span>
<span id="L630" class="LineNr">630 </span><span class="Comment">   Takes a utility function expressed as { [expr, val], ... } where the </span>
<span id="L631" class="LineNr">631 </span><span class="Comment">   utility of a state is the sum of all its true exprs' val and a state space.</span>
<span id="L632" class="LineNr">632 </span><span class="Comment">   Returns a cardinal utility function assigning values to states rather than</span>
<span id="L633" class="LineNr">633 </span><span class="Comment">   expressions.</span>
<span id="L634" class="LineNr">634 </span><span class="Comment">*/</span>
<span id="L635" class="LineNr"><a href="#tl-361" data-file="test_lib" title="test_add_u_to_card_u" class="checkmark">&#10004;</a>635 <a title="1.2.3.5.2.3.2.1" class="back_to_li" href="#t-1-2-3-5-2-3-2-1"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">add_u_to_card_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(add_u, state_space) {
<span id="L636" class="LineNr">636 </span>  atoms <span class="Statement">:=</span> <span class="Type">+/</span> { <span class="Identifier">domain</span>(state) <span class="Type">:</span> state <span class="Type">in</span> state_space };
<span id="L637" class="LineNr">637 </span>  <span class="Identifier">util</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(state) {
<span id="L638" class="LineNr">638 </span>    sum <span class="Statement">:=</span> <span class="Type">+/</span> { val <span class="Type">:</span> [expr, val] <span class="Type">in</span> add_u <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-658">is_true_in</a>(expr, state, atoms) };
<span id="L639" class="LineNr">639 </span>    <span class="Statement">if</span> (sum <span class="Type">==</span> <span class="Constant">om</span>) { sum <span class="Statement">:=</span> <span class="Constant">0</span>; }
<span id="L640" class="LineNr">640 </span>    <span class="Statement">return</span> sum;
<span id="L641" class="LineNr">641 </span>  };
<span id="L642" class="LineNr">642 </span>  <span class="Statement">return</span> { [state, <a class="Identifier code-proc-link" href="#l-637">util</a>(state)] <span class="Type">:</span> state <span class="Type">in</span> state_space };
<span id="L643" class="LineNr">643 </span>};
<span id="L644" class="LineNr">644 </span>
<span id="L645" class="LineNr">645 </span><span class="Comment">/* Expressions to State Space:</span>
<span id="L646" class="LineNr">646 </span><span class="Comment">   Return the possible ways of assigning true or false to each expr in exprs. */</span>
<span id="L647" class="LineNr"><a href="#tl-457" data-file="test_lib" title="test_exprs_to_state_space" class="checkmark">&#10004;</a>647 </span><span class="Identifier">exprs_to_state_space</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(exprs) {
<span id="L648" class="LineNr">648 </span>  <span class="Statement">if</span> (dev) { <span class="Identifier">print</span>(<span class="Constant">'exprs_to_state_space '</span> <span class="Type">+</span> exprs); }
<span id="L649" class="LineNr">649 </span>  atoms <span class="Statement">:=</span> <span class="Type">+/</span> { <a class="Identifier code-proc-link" href="#l-120">atomic_formulas</a>(expr) <span class="Type">:</span> expr <span class="Type">in</span> exprs };
<span id="L650" class="LineNr">650 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {[atom,<span class="Constant">true</span>], [atom,<span class="Constant">false</span>]} <span class="Type">:</span> atom <span class="Type">in</span> atoms });
<span id="L651" class="LineNr">651 </span>};
<span id="L652" class="LineNr">652 </span>
<span id="L653" class="LineNr">653 </span><span class="Comment">/* Expression is True in State:</span>
<span id="L654" class="LineNr">654 </span><span class="Comment">   Takes an expression and a state, a function assigning true/false to the </span>
<span id="L655" class="LineNr">655 </span><span class="Comment">   atomic terms in expr, and returns true or false for whether the expr</span>
<span id="L656" class="LineNr">656 </span><span class="Comment">   is true in the state.</span>
<span id="L657" class="LineNr">657 </span><span class="Comment">*/</span>
<span id="L658" class="LineNr">658 </span><span class="Identifier">is_true_in</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(expr, state, dom) {
<span id="L659" class="LineNr">659 </span>  <span class="Comment">// return state in expr_to_events(expr, dom); // assumes event is state</span>
<span id="L660" class="LineNr">660 </span>  <span class="Statement">return</span> <span class="Type">exists</span>(event <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(expr, dom)
<span id="L661" class="LineNr">661 </span>                <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>(state, event) );
<span id="L662" class="LineNr">662 </span>};
<span id="L663" class="LineNr">663 </span>
<span id="L664" class="LineNr">664 </span><span class="Comment">/* Ordinality Utility Function Distance:</span>
<span id="L665" class="LineNr">665 </span><span class="Comment">   Takes two weak ordinal utility functions expressed as a set of SuccEq setlx </span>
<span id="L666" class="LineNr">666 </span><span class="Comment">   functors and returns the distance between them.</span>
<span id="L667" class="LineNr">667 </span>
<span id="L668" class="LineNr">668 </span><span class="Comment">   See hausdorff_dist and kendalls_tau_dist.</span>
<span id="L669" class="LineNr">669 </span><span class="Comment">   See also: <a href="https://en.wikipedia.org/wiki/Kemeny-Young_method" target="_blank">https://en.wikipedia.org/wiki/Kemeny-Young_method</a> </span>
<span id="L670" class="LineNr">670 </span><span class="Comment">     Interestly, since we read the utility functions off the brains rather</span>
<span id="L671" class="LineNr">671 </span><span class="Comment">     than elicit them through votes, we don't need to be concerned with </span>
<span id="L672" class="LineNr">672 </span><span class="Comment">     strategic manipulation through insincere votes.</span>
<span id="L673" class="LineNr">673 </span><span class="Comment">*/</span>
<span id="L674" class="LineNr"><a href="#tl-379" data-file="test_lib" title="test_ord_u_dist" class="checkmark">&#10004;</a>674 <a title="1.2.3.5.2.3" class="back_to_li" href="#t-1-2-3-5-2-3"><i class="fas fa-list-ol"></i></a><a title="1.4.2.2" class="back_to_li" href="#t-1-4-2-2"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">ord_u_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(u1, u2) {
<span id="L675" class="LineNr">675 </span>  lots <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-702">lots_of_u</a>(u1) <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-702">lots_of_u</a>(u2);
<span id="L676" class="LineNr">676 </span>  <span class="Identifier">sharpenings</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(u) {
<span id="L677" class="LineNr">677 </span>    poss_total_orders <span class="Statement">:=</span> <span class="Identifier">permutations</span>([lot <span class="Type">:</span> lot <span class="Type">in</span> lots]);
<span id="L678" class="LineNr">678 </span>    <span class="Identifier">list_to_ord</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l) {
<span id="L679" class="LineNr">679 </span>      <span class="Statement">if</span> (l <span class="Type">==</span> []) {
<span id="L680" class="LineNr">680 </span>        <span class="Statement">return</span> {};
<span id="L681" class="LineNr">681 </span>      } <span class="Statement">else</span> {
<span id="L682" class="LineNr">682 </span>        <span class="Statement">return</span> { <span class="Identifier">Succ</span>(l[<span class="Constant">1</span>], lot) <span class="Type">:</span> lot <span class="Type">in</span> l[<span class="Constant">2</span><span class="Statement">..</span>] } <span class="Type">+</span> <a class="Identifier code-proc-link" href="#l-678">list_to_ord</a>(l[<span class="Constant">2</span><span class="Statement">..</span>]);
<span id="L683" class="LineNr">683 </span>      }
<span id="L684" class="LineNr">684 </span>    };
<span id="L685" class="LineNr">685 </span>    ord_us <span class="Statement">:=</span> { <a class="Identifier code-proc-link" href="#l-678">list_to_ord</a>(pto) <span class="Type">:</span> pto <span class="Type">in</span> poss_total_orders };
<span id="L686" class="LineNr">686 </span>    <span class="Comment">// exts := lots - lots_of_u(u); // extending lotteries</span>
<span id="L687" class="LineNr">687 </span>    <span class="Statement">return</span> {
<span id="L688" class="LineNr">688 </span>      ord_u <span class="Type">:</span> ord_u <span class="Type">in</span> ord_us
<span id="L689" class="LineNr">689 </span>      <span class="Type">|</span> <span class="Type">forall</span>(pref <span class="Type">in</span> u <span class="Comment">// u: a1 &gt;= a2 </span>
<span id="L690" class="LineNr">690 </span>          <span class="Type">|</span> <span class="Identifier">Succ</span>(<span class="Identifier">args</span>(pref)[<span class="Constant">1</span>], <span class="Identifier">args</span>(pref)[<span class="Constant">2</span>]) <span class="Type">in</span> ord_u <span class="Type">||</span> <span class="Comment">// ord_u: a1 &gt; a2</span>
<span id="L691" class="LineNr">691 </span>            <span class="Identifier">SuccEq</span>(<span class="Identifier">args</span>(pref)[<span class="Constant">2</span>], <span class="Identifier">args</span>(pref)[<span class="Constant">1</span>]) <span class="Type">in</span> u      <span class="Comment">// u: a2 &gt;= a1, ie ==</span>
<span id="L692" class="LineNr">692 </span>        ) <span class="Comment">// end forall pref</span>
<span id="L693" class="LineNr">693 </span>    }; <span class="Comment">// end return</span>
<span id="L694" class="LineNr">694 </span>  }; <span class="Comment">// end sharpenings  </span>
<span id="L695" class="LineNr">695 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-566">hausdorff_dist</a>( <a class="Identifier code-proc-link" href="#l-676">sharpenings</a>(u1),
<span id="L696" class="LineNr">696 </span>                         <span class="Identifier">sharpenings</span>(u2),
<span id="L697" class="LineNr">697 </span>                         kendalls_tau_dist );
<span id="L698" class="LineNr">698 </span>};
<span id="L699" class="LineNr">699 </span>
<span id="L700" class="LineNr">700 </span><span class="Comment">/* Takes an ordinal utility function, a set of Succ or SuccEq relations, and</span>
<span id="L701" class="LineNr">701 </span><span class="Comment">   returns the lotteries that they range over.  */</span>
<span id="L702" class="LineNr">702 </span><span class="Identifier">lots_of_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(ord_u) {
<span id="L703" class="LineNr">703 </span>  <span class="Comment">// { print(pref) : pref in u };</span>
<span id="L704" class="LineNr">704 </span>  <span class="Statement">return</span> <span class="Type">+/</span> { { <span class="Identifier">args</span>(pref)[<span class="Constant">1</span>], <span class="Identifier">args</span>(pref)[<span class="Constant">2</span>] } <span class="Type">:</span> pref <span class="Type">in</span> ord_u };
<span id="L705" class="LineNr">705 </span>};
<span id="L706" class="LineNr">706 </span>
<span id="L707" class="LineNr">707 </span><span class="Comment">/* p 56 of setlx tutorial */</span>
<span id="L708" class="LineNr"><a href="#tl-399" data-file="test_lib" title="test_sort_list" class="checkmark">&#10004;</a>708 </span><span class="Identifier">sort_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l, cmp) {
<span id="L709" class="LineNr">709 </span>  <span class="Statement">if</span> (<span class="Type">#</span>l <span class="Type">&lt;</span> <span class="Constant">2</span>) { <span class="Statement">return</span> l; }
<span id="L710" class="LineNr">710 </span>  m <span class="Statement">:=</span> <span class="Type">#</span>l <span class="Type">\</span> <span class="Constant">2</span>;
<span id="L711" class="LineNr">711 </span>  [l1, l2] <span class="Statement">:=</span> [l[<span class="Statement">..</span> m], l[m<span class="Type">+</span><span class="Constant">1</span> <span class="Statement">..</span>]];
<span id="L712" class="LineNr">712 </span>  [s1, s2] <span class="Statement">:=</span> [<a class="Identifier code-proc-link" href="#l-708">sort_list</a>(l1, cmp), <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(l2, cmp)];
<span id="L713" class="LineNr">713 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-720">merge</a>(s1, s2, cmp);
<span id="L714" class="LineNr">714 </span>};
<span id="L715" class="LineNr">715 </span>
<span id="L716" class="LineNr">716 </span><span class="Identifier">sort_set</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(s, cmp) {
<span id="L717" class="LineNr">717 </span>  <span class="Statement">return</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>([x <span class="Type">:</span> x <span class="Type">in</span> s], cmp);
<span id="L718" class="LineNr">718 </span>};
<span id="L719" class="LineNr">719 </span>
<span id="L720" class="LineNr">720 </span><span class="Identifier">merge</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(l1, l2, cmp) {
<span id="L721" class="LineNr">721 </span>  <span class="Statement">match</span> ([l1, l2]) {
<span id="L722" class="LineNr">722 </span>    <span class="Statement">case</span> [[], _] <span class="Type">:</span> <span class="Statement">return</span> l2;
<span id="L723" class="LineNr">723 </span>    <span class="Statement">case</span> [_, []] <span class="Type">:</span> <span class="Statement">return</span> l1;
<span id="L724" class="LineNr">724 </span>    <span class="Statement">case</span> [[x1<span class="Type">|</span>r1], [x2<span class="Type">|</span>r2]] <span class="Type">:</span>
<span id="L725" class="LineNr">725 </span>    <span class="Statement">if</span> (<span class="Identifier">cmp</span>(x1, x2)) {
<span id="L726" class="LineNr">726 </span>      <span class="Statement">return</span> [x1 <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-720">merge</a>(r1, l2, cmp)];
<span id="L727" class="LineNr">727 </span>    } <span class="Statement">else</span> {
<span id="L728" class="LineNr">728 </span>      <span class="Statement">return</span> [x2 <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-720">merge</a>(l1, r2, cmp)];
<span id="L729" class="LineNr">729 </span>    }
<span id="L730" class="LineNr">730 </span>  }
<span id="L731" class="LineNr">731 </span>};
<span id="L732" class="LineNr">732 </span>
<span id="L733" class="LineNr">733 </span><span class="Identifier">setlx_chars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L734" class="LineNr">734 </span>  str <span class="Statement">:=</span> <span class="Constant">" !</span><span class="Special">\"</span><span class="Constant">#%&amp;'()*+,-./0123456789:;&lt;=&gt;?"</span> <span class="Type">+</span>
<span id="L735" class="LineNr">735 </span>         <span class="Constant">"ABCDEFGHIJKLMNOPQRSTUVWXYZ[</span><span class="Special">\\</span><span class="Constant">]_"</span> <span class="Type">+</span>
<span id="L736" class="LineNr">736 </span>         <span class="Constant">"abcdefghijklmnopqrstuvwxyz{|}~"</span>;
<span id="L737" class="LineNr">737 </span>  <span class="Statement">return</span> { str[j] <span class="Type">:</span> j <span class="Type">in</span> [<span class="Constant">1</span><span class="Statement">..</span><span class="Type">#</span>str] };
<span id="L738" class="LineNr">738 </span>};
<span id="L739" class="LineNr">739 </span>
<span id="L740" class="LineNr">740 </span><span class="Identifier">all_strs_lte</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(s) {
<span id="L741" class="LineNr">741 </span>  poss_strs <span class="Statement">:=</span> {<span class="Constant">''</span>};
<span id="L742" class="LineNr">742 </span>  length <span class="Statement">:=</span> <span class="Constant">0</span>;
<span id="L743" class="LineNr">743 </span>  <span class="Statement">while</span> (length <span class="Type">&lt;</span> <span class="Type">#</span>s) {
<span id="L744" class="LineNr">744 </span>    length <span class="Statement">:=</span> length <span class="Type">+</span> <span class="Constant">1</span>;
<span id="L745" class="LineNr">745 </span>    poss_strs <span class="Statement">:=</span> poss_strs <span class="Type">+</span> { poss_str <span class="Type">+</span> char <span class="Type">:</span> [poss_str, char] <span class="Type">in</span>
<span id="L746" class="LineNr">746 </span>                                                 poss_strs <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#l-733">setlx_chars</a>() };
<span id="L747" class="LineNr">747 </span>  }
<span id="L748" class="LineNr">748 </span>  <span class="Statement">return</span> poss_strs;
<span id="L749" class="LineNr">749 </span>};
<span id="L750" class="LineNr">750 </span>
<span id="L751" class="LineNr"><a href="#tl-420" data-file="test_lib" title="test_restrict_domain" class="checkmark">&#10004;</a>751 </span><span class="Identifier">restrict_domain</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(event, vars) {
<span id="L752" class="LineNr">752 </span>  <span class="Statement">return</span> { [var, val] <span class="Type">:</span> [var, val] <span class="Type">in</span> event <span class="Type">|</span> var <span class="Type">in</span> vars };
<span id="L753" class="LineNr">753 </span>};
<span id="L754" class="LineNr">754 </span>
<span id="L755" class="LineNr"><a href="#tl-428" data-file="test_lib" title="test_restricted_eq" class="checkmark">&#10004;</a>755 </span><span class="Identifier">restricted_eq</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(state, event) {
<span id="L756" class="LineNr">756 </span>  <span class="Statement">return</span> event <span class="Type">==</span> <a class="Identifier code-proc-link" href="#l-751">restrict_domain</a>(state, <span class="Identifier">domain</span>(event));
<span id="L757" class="LineNr">757 </span>};
<span id="L758" class="LineNr">758 </span>
<span id="L759" class="LineNr">759 </span><span class="Comment">/* Kolmogorov Complexity of a string</span>
<span id="L760" class="LineNr">760 </span><span class="Comment">   <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity" target="_blank">https://en.wikipedia.org/wiki/Kolmogorov_complexity</a>  </span>
<span id="L761" class="LineNr">761 </span>
<span id="L762" class="LineNr">762 </span><span class="Comment">   k is an incomputable function but we include a naive attempt to define it</span>
<span id="L763" class="LineNr">763 </span><span class="Comment">   anyway. Although it may seem possible this way, it will not work because</span>
<span id="L764" class="LineNr">764 </span><span class="Comment">   eval(poss_str) may not terminate. In practice, some finite approximation</span>
<span id="L765" class="LineNr">765 </span><span class="Comment">   could be used. For instance, if setlx allowed us to catch a timeout error</span>
<span id="L766" class="LineNr">766 </span><span class="Comment">   as many other languages do, it would be particularly easy by just trying </span>
<span id="L767" class="LineNr">767 </span><span class="Comment">   each program string up to a fixed length of time.</span>
<span id="L768" class="LineNr">768 </span><span class="Comment">*/</span>
<span id="L769" class="LineNr">769 <a title="1.2.1.3.2.2.3" class="back_to_li" href="#t-1-2-1-3-2-2-3"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">k</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(s) {
<span id="L770" class="LineNr">770 </span>  poss_strs <span class="Statement">:=</span> {<span class="Constant">''</span>};
<span id="L771" class="LineNr">771 </span>  success <span class="Statement">:=</span> <span class="Constant">false</span>;
<span id="L772" class="LineNr">772 </span>  length <span class="Statement">:=</span> <span class="Constant">0</span>;
<span id="L773" class="LineNr">773 </span>  <span class="Statement">while</span> (<span class="Type">!</span>success) {
<span id="L774" class="LineNr">774 </span>    length <span class="Statement">:=</span> length <span class="Type">+</span> <span class="Constant">1</span>;
<span id="L775" class="LineNr">775 </span>    poss_strs <span class="Statement">:=</span> { poss_str <span class="Type">+</span> char
<span id="L776" class="LineNr">776 </span>                   <span class="Type">:</span> [poss_str, char] <span class="Type">in</span> poss_strs <span class="Type">&gt;&lt;</span> <a class="Identifier code-proc-link" href="#l-733">setlx_chars</a>() };
<span id="L777" class="LineNr">777 </span>    <span class="Statement">if</span> (<span class="Type">exists</span>(bool <span class="Type">in</span> { <span class="Identifier">eval</span>(poss_str) <span class="Type">==</span> s <span class="Type">:</span> poss_str <span class="Type">in</span> poss_strs } <span class="Type">|</span> bool)
<span id="L778" class="LineNr">778 </span>        <span class="Type">||</span> length <span class="Type">==</span> <span class="Type">#</span>s <span class="Type">+</span> <span class="Constant">2</span> )  { <span class="Comment">// +2 because a str plus quotes encodes itself</span>
<span id="L779" class="LineNr">779 </span>      success <span class="Statement">:=</span> <span class="Constant">true</span>;
<span id="L780" class="LineNr">780 </span>    }
<span id="L781" class="LineNr">781 </span>  }
<span id="L782" class="LineNr">782 </span>  <span class="Statement">return</span> length;
<span id="L783" class="LineNr">783 </span>};
<span id="L784" class="LineNr">784 </span>
<span id="L785" class="LineNr">785 </span><span class="Comment">/* Conditional Kolmogorov Complexity  K(s|i)  </span>
<span id="L786" class="LineNr">786 </span><span class="Comment">   The length of the shortest program which outputs a string s when given the </span>
<span id="L787" class="LineNr">787 </span><span class="Comment">   string i as input. Again, this is incomputable but can be finitely </span>
<span id="L788" class="LineNr">788 </span><span class="Comment">   approximated.</span>
<span id="L789" class="LineNr">789 </span><span class="Comment">*/</span>
<span id="L790" class="LineNr">790 <a title="1.2.1.3.2.2.4" class="back_to_li" href="#t-1-2-1-3-2-2-4"><i class="fas fa-list-ol"></i></a></span><span class="Identifier">k_given</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(s, i) {
<span id="L791" class="LineNr">791 </span>  <span class="Identifier">eval_str</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(str) {
<span id="L792" class="LineNr">792 </span>    try {
<span id="L793" class="LineNr">793 </span>      <span class="Statement">return</span> <span class="Identifier">eval</span>(str <span class="Type">+</span> <span class="Constant">'("'</span> <span class="Type">+</span> i <span class="Type">+</span> <span class="Constant">'");'</span>);
<span id="L794" class="LineNr">794 </span>    } catch(e) {
<span id="L795" class="LineNr">795 </span>      <span class="Statement">return</span> <span class="Constant">''</span>;
<span id="L796" class="LineNr">796 </span>    }
<span id="L797" class="LineNr">797 </span>  };
<span id="L798" class="LineNr">798 </span>  strs <span class="Statement">:=</span> { str <span class="Type">:</span> str <span class="Type">in</span> <span class="Identifier">all_str_lte</span>(<span class="Type">#</span>s <span class="Type">+</span> <span class="Constant">2</span>) <span class="Type">|</span> <a class="Identifier code-proc-link" href="#l-791">eval_str</a>(str) <span class="Type">==</span> s };
<span id="L799" class="LineNr">799 </span>  strs <span class="Statement">:=</span> <span class="Identifier">sort</span>(strs, <span class="Type">procedure</span>(s1, s2) { <span class="Statement">return</span> <span class="Type">#</span>s1 <span class="Type">&lt;</span> <span class="Type">#</span>s2; });
<span id="L800" class="LineNr">800 </span>  <span class="Statement">return</span> <span class="Type">#</span>strs[<span class="Constant">1</span>];
<span id="L801" class="LineNr">801 </span>};
</pre>
<pre class="vimCodeElement test_code" id="test_lib"><span id="L1" class="LineNr">  1 </span><span class="Identifier">print</span>(<span class="Constant">'Testing Lib'</span>);
<span id="L2" class="LineNr">  2 </span><span class="Identifier">print</span>(<span class="Constant">'==========='</span>);
<span id="L3" class="LineNr">  3 </span>
<span id="L4" class="LineNr"><a href="#l-6" data-file="lib" title="ne_pow" class="back_to_proc">&#8629;</a>  4 </span><span class="Identifier">test_ne_pow</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L5" class="LineNr">  5 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-6">ne_pow</a>({<span class="Constant">1</span>,<span class="Constant">2</span>}) <span class="Type">==</span> {{<span class="Constant">1</span>}, {<span class="Constant">2</span>}, {<span class="Constant">1</span>,<span class="Constant">2</span>}},
<span id="L6" class="LineNr">  6 </span>         <span class="Constant">"Error: ne_pow is incorrect."</span>);
<span id="L7" class="LineNr">  7 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] ne_pow'</span>);
<span id="L8" class="LineNr">  8 </span>};
<span id="L9" class="LineNr">  9 </span><span class="Identifier">test_ne_pow</span>();
<span id="L10" class="LineNr"> 10 </span>
<span id="L11" class="LineNr"><a href="#l-10" data-file="lib" title="min" class="back_to_proc">&#8629;</a> 11 </span><span class="Identifier">test_min</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L12" class="LineNr"> 12 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-10">min</a>([<span class="Constant">3</span>,<span class="Constant">4</span>,<span class="Constant">5</span>]) <span class="Type">==</span> <span class="Constant">3</span>, <span class="Constant">"Error: min is incorrect."</span>);
<span id="L13" class="LineNr"> 13 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] min'</span>);
<span id="L14" class="LineNr"> 14 </span>};
<span id="L15" class="LineNr"> 15 </span><span class="Identifier">test_min</span>();
<span id="L16" class="LineNr"> 16 </span>
<span id="L17" class="LineNr"><a href="#l-15" data-file="lib" title="max" class="back_to_proc">&#8629;</a> 17 </span><span class="Identifier">test_max</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L18" class="LineNr"> 18 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-15">max</a>([<span class="Constant">3</span>,<span class="Constant">4</span>,<span class="Constant">5</span>]) <span class="Type">==</span> <span class="Constant">5</span>, <span class="Constant">"Error: max is incorrect."</span>);
<span id="L19" class="LineNr"> 19 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] max'</span>);
<span id="L20" class="LineNr"> 20 </span>};
<span id="L21" class="LineNr"> 21 </span><span class="Identifier">test_max</span>();
<span id="L22" class="LineNr"> 22 </span>
<span id="L23" class="LineNr"><a href="#l-20" data-file="lib" title="avg" class="back_to_proc">&#8629;</a> 23 </span><span class="Identifier">test_avg</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L24" class="LineNr"> 24 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-20">avg</a>([<span class="Constant">3</span>,<span class="Constant">4</span>,<span class="Constant">5</span>]) <span class="Type">==</span> <span class="Constant">4</span>, <span class="Constant">"Error: avg is incorrect."</span>);
<span id="L25" class="LineNr"> 25 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] avg'</span>);
<span id="L26" class="LineNr"> 26 </span>};
<span id="L27" class="LineNr"> 27 </span><span class="Identifier">test_avg</span>();
<span id="L28" class="LineNr"> 28 </span>
<span id="L29" class="LineNr"><a href="#l-24" data-file="lib" title="index_of" class="back_to_proc">&#8629;</a> 29 </span><span class="Identifier">test_index_of</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L30" class="LineNr"> 30 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-24">index_of</a>(<span class="Constant">5</span>, [<span class="Constant">3</span>,<span class="Constant">4</span>,<span class="Constant">5</span>]) <span class="Type">==</span> <span class="Constant">3</span>, <span class="Constant">"Error: index_of is incorrect."</span>);
<span id="L31" class="LineNr"> 31 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] index_of'</span>);
<span id="L32" class="LineNr"> 32 </span>};
<span id="L33" class="LineNr"> 33 </span><span class="Identifier">test_index_of</span>();
<span id="L34" class="LineNr"> 34 </span>
<span id="L35" class="LineNr"><a href="#l-36" data-file="lib" title="equiv_expr" class="back_to_proc">&#8629;</a> 35 </span><span class="Identifier">test_equiv_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L36" class="LineNr"> 36 </span>  e1 <span class="Statement">:=</span> <span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>);
<span id="L37" class="LineNr"> 37 </span>  e2 <span class="Statement">:=</span> <span class="Identifier">And</span>(<span class="Constant">'B'</span>, <span class="Constant">'A'</span>);
<span id="L38" class="LineNr"> 38 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-36">equiv_expr</a>(e1, e2, { <span class="Constant">'A'</span>, <span class="Constant">'B'</span> }), <span class="Constant">"Error: equiv_expr is incorrect."</span>);
<span id="L39" class="LineNr"> 39 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] equiv_expr: A ^ B == B ^ A'</span>);
<span id="L40" class="LineNr"> 40 </span>
<span id="L41" class="LineNr"> 41 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-36">equiv_expr</a>(<span class="Identifier">Exists</span>(<span class="Constant">'x'</span>, <span class="Identifier">Odd</span>(<span class="Constant">'x'</span>)),
<span id="L42" class="LineNr"> 42 </span>                    <span class="Identifier">Not</span>(<span class="Identifier">Forall</span>(<span class="Constant">'y'</span>, <span class="Identifier">Not</span>(<span class="Identifier">Odd</span>(<span class="Constant">'y'</span>)))),
<span id="L43" class="LineNr"> 43 </span>                    { <span class="Identifier">Odd</span>(<span class="Constant">'a'</span>), <span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">Odd</span>(<span class="Constant">'c'</span>) }),
<span id="L44" class="LineNr"> 44 </span>         <span class="Constant">"Error: equiv_expr is incorrect."</span>);
<span id="L45" class="LineNr"> 45 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] equiv_expr: Ex Odd(x) == ~( Vy ~Odd(y) )'</span>);
<span id="L46" class="LineNr"> 46 </span>  <span class="Comment">// print('[ok] expr_to_events');</span>
<span id="L47" class="LineNr"> 47 </span>};
<span id="L48" class="LineNr"> 48 </span><span class="Identifier">test_equiv_expr</span>();
<span id="L49" class="LineNr"> 49 </span>
<span id="L50" class="LineNr"><a href="#l-76" data-file="lib" title="maybe_not" class="back_to_proc">&#8629;</a> 50 </span><span class="Identifier">test_maybe_not</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L51" class="LineNr"> 51 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-76">maybe_not</a>(<span class="Constant">'A'</span>, <span class="Constant">true</span>) <span class="Type">==</span> <span class="Constant">'A'</span>,
<span id="L52" class="LineNr"> 52 </span>         <span class="Constant">"Error: maybe_not true is incorrect."</span>);
<span id="L53" class="LineNr"> 53 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] maybe_not true'</span>);
<span id="L54" class="LineNr"> 54 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-76">maybe_not</a>(<span class="Constant">'A'</span>, <span class="Constant">false</span>) <span class="Type">==</span> <span class="Identifier">Not</span>(<span class="Constant">'A'</span>),
<span id="L55" class="LineNr"> 55 </span>         <span class="Constant">"Error: maybe_not false is incorrect."</span>);
<span id="L56" class="LineNr"> 56 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] maybe_not false'</span>);
<span id="L57" class="LineNr"> 57 </span>};
<span id="L58" class="LineNr"> 58 </span><span class="Identifier">test_maybe_not</span>();
<span id="L59" class="LineNr"> 59 </span>
<span id="L60" class="LineNr"><a href="#l-94" data-file="lib" title="atomic_exprs" class="back_to_proc">&#8629;</a> 60 </span><span class="Identifier">test_atomic_exprs</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L61" class="LineNr"> 61 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-94">atomic_exprs</a>(<span class="Identifier">Exists</span>(<span class="Constant">'x'</span>, <span class="Identifier">And</span>(<span class="Constant">'B'</span>, <span class="Identifier">Odd</span>(<span class="Constant">'a'</span>)))) <span class="Type">==</span> { <span class="Constant">'x'</span>, <span class="Constant">'B'</span>, <span class="Constant">'a'</span> },
<span id="L62" class="LineNr"> 62 </span>         <span class="Constant">"Error: atomic_exprs is incorrect."</span>);
<span id="L63" class="LineNr"> 63 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] atomic_exprs'</span>);
<span id="L64" class="LineNr"> 64 </span>};
<span id="L65" class="LineNr"> 65 </span><span class="Identifier">test_atomic_exprs</span>();
<span id="L66" class="LineNr"> 66 </span>
<span id="L67" class="LineNr"><a href="#l-104" data-file="lib" title="atomic_terms" class="back_to_proc">&#8629;</a> 67 </span><span class="Identifier">test_atomic_terms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L68" class="LineNr"> 68 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-104">atomic_terms</a>(<span class="Identifier">Exists</span>(<span class="Constant">'x'</span>, <span class="Identifier">And</span>(<span class="Constant">'B'</span>, <span class="Identifier">Odd</span>(<span class="Constant">'a'</span>)))) <span class="Type">==</span> { <span class="Constant">'B'</span>, <span class="Constant">'a'</span> },
<span id="L69" class="LineNr"> 69 </span>         <span class="Constant">"Error: atomic_terms is incorrect."</span>);
<span id="L70" class="LineNr"> 70 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] atomic_terms'</span>);
<span id="L71" class="LineNr"> 71 </span>};
<span id="L72" class="LineNr"> 72 </span><span class="Identifier">test_atomic_terms</span>();
<span id="L73" class="LineNr"> 73 </span>
<span id="L74" class="LineNr"><a href="#l-111" data-file="lib" title="func_to_expr" class="back_to_proc">&#8629;</a> 74 </span><span class="Identifier">test_func_to_expr</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L75" class="LineNr"> 75 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-111">func_to_expr</a>({ [<span class="Constant">'A'</span>, <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>], [<span class="Constant">'C'</span>, <span class="Constant">false</span>] }) <span class="Type">==</span>
<span id="L76" class="LineNr"> 76 </span>         <span class="Identifier">And</span>(<span class="Constant">"A"</span>, <span class="Identifier">And</span>(<span class="Identifier">Not</span>(<span class="Constant">"B"</span>), <span class="Identifier">Not</span>(<span class="Constant">"C"</span>))),
<span id="L77" class="LineNr"> 77 </span>         <span class="Constant">"Error: func_to_expr is incorrect."</span>);
<span id="L78" class="LineNr"> 78 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] func_to_expr'</span>);
<span id="L79" class="LineNr"> 79 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] iter_fct'</span>);
<span id="L80" class="LineNr"> 80 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] foldr'</span>);
<span id="L81" class="LineNr"> 81 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] fctize'</span>);
<span id="L82" class="LineNr"> 82 </span>};
<span id="L83" class="LineNr"> 83 </span><span class="Identifier">test_func_to_expr</span>();
<span id="L84" class="LineNr"> 84 </span>
<span id="L85" class="LineNr"><a href="#l-120" data-file="lib" title="atomic_formulas" class="back_to_proc">&#8629;</a> 85 </span><span class="Identifier">test_atomic_formulas</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L86" class="LineNr"> 86 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-120">atomic_formulas</a>(<span class="Identifier">Forall</span>(<span class="Constant">'x'</span>, <span class="Identifier">Implies</span>(<span class="Identifier">Odd</span>(<span class="Constant">'a'</span>),<span class="Constant">'B'</span>) )) <span class="Type">==</span>
<span id="L87" class="LineNr"> 87 </span>         { <span class="Identifier">Odd</span>(<span class="Constant">'a'</span>), <span class="Constant">'B'</span> },
<span id="L88" class="LineNr"> 88 </span>         <span class="Constant">"Error: atomic_formulas is incorrect."</span>);
<span id="L89" class="LineNr"> 89 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] atomic_formulas'</span>);
<span id="L90" class="LineNr"> 90 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] atomic_forms'</span>);
<span id="L91" class="LineNr"> 91 </span>};
<span id="L92" class="LineNr"> 92 </span><span class="Identifier">test_atomic_formulas</span>();
<span id="L93" class="LineNr"><a href="#l-125" data-file="lib" title="atomic_forms" class="back_to_proc">&#8629;</a> 93 </span><span class="Identifier">test_atomic_forms</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() { <a class="Identifier code-proc-link" href="#tl-85">test_atomic_formulas</a>(); };
<span id="L94" class="LineNr"> 94 </span>
<span id="L95" class="LineNr"><a href="#l-134" data-file="lib" title="expr_to_events" class="back_to_proc">&#8629;</a> 95 </span><span class="Identifier">test_expr_to_events</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L96" class="LineNr"> 96 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(<span class="Identifier">Not</span>(<span class="Constant">'A'</span>), {<span class="Constant">'A'</span>}) <span class="Type">==</span> { { [<span class="Constant">'A'</span>, <span class="Constant">false</span>] } },
<span id="L97" class="LineNr"> 97 </span>         <span class="Constant">"Error: expr_to_events ~A is incorrect."</span>);
<span id="L98" class="LineNr"> 98 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(<span class="Constant">'A'</span>, {<span class="Constant">'A'</span>, <span class="Constant">'B'</span> }) <span class="Type">==</span>
<span id="L99" class="LineNr"> 99 </span>         { { [<span class="Constant">'A'</span>, <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>] },
<span id="L100" class="LineNr">100 </span>           { [<span class="Constant">'A'</span>, <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ] } },
<span id="L101" class="LineNr">101 </span>         <span class="Constant">"Error: expr_to_events A is incorrect."</span>);
<span id="L102" class="LineNr">102 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(<span class="Identifier">Implies</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), {<span class="Constant">'A'</span>, <span class="Constant">'B'</span> }) <span class="Type">==</span>
<span id="L103" class="LineNr">103 </span>         { { [<span class="Constant">'A'</span>, <span class="Constant">true</span> ], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ] },
<span id="L104" class="LineNr">104 </span>           { [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ] },
<span id="L105" class="LineNr">105 </span>           { [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>] } },
<span id="L106" class="LineNr">106 </span>         <span class="Constant">"Error: expr_to_events A-&gt;B is incorrect."</span>);
<span id="L107" class="LineNr">107 </span>  dom <span class="Statement">:=</span> { <span class="Constant">'A'</span>, <span class="Constant">'B'</span>, <span class="Constant">'C'</span> };
<span id="L108" class="LineNr">108 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-134">expr_to_events</a>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), dom) <span class="Type">==</span>
<span id="L109" class="LineNr">109 </span>         { { [<span class="Constant">'A'</span>, <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span>], [<span class="Constant">'C'</span>, <span class="Constant">true</span> ] },
<span id="L110" class="LineNr">110 </span>           { [<span class="Constant">'A'</span>, <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span>], [<span class="Constant">'C'</span>, <span class="Constant">false</span>] }  },
<span id="L111" class="LineNr">111 </span>         <span class="Constant">"Error: expr_to_events A^B is incorrect."</span>);
<span id="L112" class="LineNr">112 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] expr_to_events'</span>);
<span id="L113" class="LineNr">113 </span>  <span class="Identifier">print</span>(<span class="Constant">'[  ] more expr_to_events'</span>);
<span id="L114" class="LineNr">114 </span>};
<span id="L115" class="LineNr">115 </span><span class="Identifier">test_expr_to_events</span>();
<span id="L116" class="LineNr">116 </span>
<span id="L117" class="LineNr"><a href="#l-239" data-file="lib" title="inv" class="back_to_proc">&#8629;</a>117 </span><span class="Identifier">test_inv</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L118" class="LineNr">118 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-239">inv</a>({ [<span class="Constant">'a'</span>, <span class="Constant">1</span>], [<span class="Constant">'b'</span>, <span class="Constant">2</span>] }) <span class="Type">==</span> { [<span class="Constant">1</span>, <span class="Constant">'a'</span>], [<span class="Constant">2</span>, <span class="Constant">'b'</span>] },
<span id="L119" class="LineNr">119 </span>         <span class="Constant">"Error: inv is incorrect."</span>);
<span id="L120" class="LineNr">120 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] inv'</span>);
<span id="L121" class="LineNr">121 </span>};
<span id="L122" class="LineNr">122 </span><span class="Identifier">test_inv</span>();
<span id="L123" class="LineNr">123 </span>
<span id="L124" class="LineNr"><a href="#l-245" data-file="lib" title="arity" class="back_to_proc">&#8629;</a>124 </span><span class="Identifier">test_arity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L125" class="LineNr">125 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-245">arity</a>(<span class="Constant">'A'</span>) <span class="Type">==</span> <span class="Constant">0</span> <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#l-245">arity</a>(<span class="Identifier">B</span>()) <span class="Type">==</span> <span class="Constant">0</span> <span class="Type">&amp;&amp;</span> <a class="Identifier code-proc-link" href="#l-245">arity</a>(<span class="Identifier">Odd</span>(<span class="Constant">'x'</span>)) <span class="Type">==</span> <span class="Constant">1</span> <span class="Type">&amp;&amp;</span>
<span id="L126" class="LineNr">126 </span>         <span class="Identifier">arity</span>(<span class="Identifier">GreaterThan</span>(<span class="Constant">'x'</span>, <span class="Constant">'y'</span>)) <span class="Type">==</span> <span class="Constant">2</span> <span class="Type">&amp;&amp;</span>
<span id="L127" class="LineNr">127 </span>         <span class="Identifier">arity</span>(<span class="Identifier">Relation</span>(<span class="Constant">'x'</span>, <span class="Constant">'y'</span>, <span class="Constant">'z'</span>)) <span class="Type">==</span> <span class="Constant">3</span>,
<span id="L128" class="LineNr">128 </span>         <span class="Constant">"Error: arity is incorrect."</span>);
<span id="L129" class="LineNr">129 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] arity'</span>);
<span id="L130" class="LineNr">130 </span>};
<span id="L131" class="LineNr">131 </span><span class="Identifier">test_arity</span>();
<span id="L132" class="LineNr">132 </span>
<span id="L133" class="LineNr"><a href="#l-254" data-file="lib" title="flatten" class="back_to_proc">&#8629;</a>133 </span><span class="Identifier">test_flatten</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L134" class="LineNr">134 </span>  <span class="Statement">assert</span>([<span class="Constant">1</span>,<span class="Constant">'a'</span>,<span class="Constant">'C'</span>] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-254">flatten</a>({<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>} <span class="Type">&gt;&lt;</span> {<span class="Constant">'a'</span>,<span class="Constant">'b'</span>,<span class="Constant">'c'</span>} <span class="Type">&gt;&lt;</span> {<span class="Constant">'A'</span>, <span class="Constant">'B'</span>, <span class="Constant">'C'</span>}),
<span id="L135" class="LineNr">135 </span>         <span class="Constant">"Error: flatten is incorrect."</span>);
<span id="L136" class="LineNr">136 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] flatten'</span>);
<span id="L137" class="LineNr">137 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] flatten_list'</span>);
<span id="L138" class="LineNr">138 </span>};
<span id="L139" class="LineNr">139 </span><span class="Identifier">test_flatten</span>();
<span id="L140" class="LineNr">140 </span>
<span id="L141" class="LineNr"><a href="#l-269" data-file="lib" title="cart_prod" class="back_to_proc">&#8629;</a>141 </span><span class="Identifier">test_cart_prod</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L142" class="LineNr">142 </span>  <span class="Statement">assert</span>([<span class="Constant">2</span>,<span class="Constant">'a'</span>,<span class="Constant">'B'</span>] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-269">cart_prod</a>([{<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>}, {<span class="Constant">'a'</span>,<span class="Constant">'b'</span>,<span class="Constant">'c'</span>}, {<span class="Constant">'A'</span>, <span class="Constant">'B'</span>, <span class="Constant">'C'</span>}]),
<span id="L143" class="LineNr">143 </span>         <span class="Constant">"Error: cart_prod is incorrect."</span>);
<span id="L144" class="LineNr">144 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] cart_prod'</span>);
<span id="L145" class="LineNr">145 </span>};
<span id="L146" class="LineNr">146 </span><span class="Identifier">test_cart_prod</span>();
<span id="L147" class="LineNr">147 </span>
<span id="L148" class="LineNr"><a href="#l-279" data-file="lib" title="iter_prod" class="back_to_proc">&#8629;</a>148 </span><span class="Identifier">test_iter_prod</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L149" class="LineNr">149 </span>  <span class="Statement">assert</span>([<span class="Constant">3</span>,<span class="Constant">2</span>,<span class="Constant">1</span>] <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-279">iter_prod</a>({<span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span>}, <span class="Constant">3</span>),
<span id="L150" class="LineNr">150 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L151" class="LineNr">151 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] iter_prod '</span>);
<span id="L152" class="LineNr">152 </span>};
<span id="L153" class="LineNr">153 </span><span class="Identifier">test_iter_prod</span>();
<span id="L154" class="LineNr">154 </span>
<span id="L155" class="LineNr"><a href="#l-287" data-file="lib" title="iter_mult" class="back_to_proc">&#8629;</a>155 </span><span class="Identifier">test_iter_mult</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L156" class="LineNr">156 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-287">iter_mult</a>({ <span class="Constant">3</span>, <span class="Constant">5</span>, <span class="Constant">7</span> }) <span class="Type">==</span> <span class="Constant">105</span>,
<span id="L157" class="LineNr">157 </span>         <span class="Constant">"Error: iter_mult is incorrect."</span>);
<span id="L158" class="LineNr">158 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] iter_mult'</span>);
<span id="L159" class="LineNr">159 </span>};
<span id="L160" class="LineNr">160 </span><span class="Identifier">test_iter_mult</span>();
<span id="L161" class="LineNr">161 </span>
<span id="L162" class="LineNr"><a href="#l-297" data-file="lib" title="choices" class="back_to_proc">&#8629;</a>162 </span><span class="Identifier">test_choices</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L163" class="LineNr">163 </span>  <span class="Statement">assert</span>({<span class="Constant">3</span>,<span class="Constant">'b'</span>,<span class="Constant">'A'</span>} <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-297">choices</a>({ {<span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span>}, {<span class="Constant">'a'</span>,<span class="Constant">'b'</span>,<span class="Constant">'c'</span>}, {<span class="Constant">'A'</span>,<span class="Constant">'B'</span>,<span class="Constant">'C'</span>} }),
<span id="L164" class="LineNr">164 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L165" class="LineNr">165 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] choices '</span>);
<span id="L166" class="LineNr">166 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] set_choices '</span>);
<span id="L167" class="LineNr">167 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] list_choices '</span>);
<span id="L168" class="LineNr">168 </span>};
<span id="L169" class="LineNr">169 </span><span class="Identifier">test_choices</span>();
<span id="L170" class="LineNr">170 </span>
<span id="L171" class="LineNr"><a href="#l-319" data-file="lib" title="function_space" class="back_to_proc">&#8629;</a>171 </span><span class="Identifier">test_function_space</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L172" class="LineNr">172 </span>  dom <span class="Statement">:=</span> { <span class="Constant">'a'</span>, <span class="Constant">'b'</span> };
<span id="L173" class="LineNr">173 </span>  rng <span class="Statement">:=</span> { <span class="Constant">1</span>, <span class="Constant">2</span> };
<span id="L174" class="LineNr">174 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-319">function_space</a>(dom, rng) <span class="Type">==</span> { {[<span class="Constant">"a"</span>, <span class="Constant">1</span>], [<span class="Constant">"b"</span>, <span class="Constant">1</span>]},
<span id="L175" class="LineNr">175 </span>                                       {[<span class="Constant">"a"</span>, <span class="Constant">1</span>], [<span class="Constant">"b"</span>, <span class="Constant">2</span>]},
<span id="L176" class="LineNr">176 </span>                                       {[<span class="Constant">"a"</span>, <span class="Constant">2</span>], [<span class="Constant">"b"</span>, <span class="Constant">1</span>]},
<span id="L177" class="LineNr">177 </span>                                       {[<span class="Constant">"a"</span>, <span class="Constant">2</span>], [<span class="Constant">"b"</span>, <span class="Constant">2</span>]}
<span id="L178" class="LineNr">178 </span>                                     },
<span id="L179" class="LineNr">179 </span>         <span class="Constant">'Error: function_space is incorrect'</span>);
<span id="L180" class="LineNr">180 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] function_space'</span>);
<span id="L181" class="LineNr">181 </span>};
<span id="L182" class="LineNr">182 </span><span class="Identifier">test_function_space</span>();
<span id="L183" class="LineNr">183 </span>
<span id="L184" class="LineNr"><a href="#l-328" data-file="lib" title="possible_states" class="back_to_proc">&#8629;</a>184 </span><span class="Identifier">test_possible_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L185" class="LineNr">185 </span>  s <span class="Statement">:=</span> { <span class="Constant">'a'</span>, <span class="Constant">'b'</span> };
<span id="L186" class="LineNr">186 </span>  r <span class="Statement">:=</span> { [<span class="Constant">'a'</span>, {<span class="Constant">0</span>,<span class="Constant">1</span>}], [<span class="Constant">'b'</span>, {<span class="Constant">3</span>,<span class="Constant">4</span>}] };
<span id="L187" class="LineNr">187 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-328">possible_states</a>(s,r) <span class="Type">==</span> { {[<span class="Constant">"a"</span>, <span class="Constant">0</span>], [<span class="Constant">"b"</span>, <span class="Constant">3</span>]},
<span id="L188" class="LineNr">188 </span>                                   {[<span class="Constant">"a"</span>, <span class="Constant">0</span>], [<span class="Constant">"b"</span>, <span class="Constant">4</span>]},
<span id="L189" class="LineNr">189 </span>                                   {[<span class="Constant">"a"</span>, <span class="Constant">1</span>], [<span class="Constant">"b"</span>, <span class="Constant">3</span>]},
<span id="L190" class="LineNr">190 </span>                                   {[<span class="Constant">"a"</span>, <span class="Constant">1</span>], [<span class="Constant">"b"</span>, <span class="Constant">4</span>]}
<span id="L191" class="LineNr">191 </span>                                 },
<span id="L192" class="LineNr">192 </span>         <span class="Constant">'Error: possible_states is incorrect'</span>);
<span id="L193" class="LineNr">193 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] possible_states'</span>);
<span id="L194" class="LineNr">194 </span>};
<span id="L195" class="LineNr">195 </span><span class="Identifier">test_possible_states</span>();
<span id="L196" class="LineNr">196 </span>
<span id="L197" class="LineNr"><a href="#l-336" data-file="lib" title="partial_functions" class="back_to_proc">&#8629;</a>197 </span><span class="Identifier">test_partial_functions</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L198" class="LineNr">198 </span>  f <span class="Statement">:=</span> { [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">2</span>,<span class="Constant">4</span>] };
<span id="L199" class="LineNr">199 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-336">partial_functions</a>(f) <span class="Type">==</span> {{}, {[<span class="Constant">1</span>, <span class="Constant">2</span>]}, {[<span class="Constant">1</span>, <span class="Constant">2</span>], [<span class="Constant">2</span>, <span class="Constant">4</span>]}, {[<span class="Constant">2</span>, <span class="Constant">4</span>]}},
<span id="L200" class="LineNr">200 </span>         <span class="Constant">'Error: partial_functions is incorrect'</span>);
<span id="L201" class="LineNr">201 </span>};
<span id="L202" class="LineNr">202 </span><span class="Identifier">test_partial_functions</span>();
<span id="L203" class="LineNr">203 </span>
<span id="L204" class="LineNr"><a href="#l-342" data-file="lib" title="compatible_values" class="back_to_proc">&#8629;</a>204 </span><span class="Identifier">test_compatible_values</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L205" class="LineNr">205 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-342">compatible_values</a>(
<span id="L206" class="LineNr">206 </span>           { [<span class="Constant">'A'</span>,<span class="Constant">true</span>], [<span class="Constant">'B'</span>,<span class="Constant">false</span>] },
<span id="L207" class="LineNr">207 </span>           { [<span class="Constant">'C'</span>,<span class="Constant">false</span>], [<span class="Constant">'B'</span>,<span class="Constant">false</span>] }
<span id="L208" class="LineNr">208 </span>         ) <span class="Type">==</span> <span class="Constant">true</span>,
<span id="L209" class="LineNr">209 </span>         <span class="Constant">"Error: compatible_values is incorrect."</span>);
<span id="L210" class="LineNr">210 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-342">compatible_values</a>(
<span id="L211" class="LineNr">211 </span>           { [<span class="Constant">'A'</span>,<span class="Constant">true</span>], [<span class="Constant">'B'</span>,<span class="Constant">false</span>] },
<span id="L212" class="LineNr">212 </span>           { [<span class="Constant">'C'</span>,<span class="Constant">false</span>], [<span class="Constant">'B'</span>,<span class="Constant">true</span>] }
<span id="L213" class="LineNr">213 </span>         ) <span class="Type">==</span> <span class="Constant">false</span>,
<span id="L214" class="LineNr">214 </span>         <span class="Constant">"Error: compatible_values is incorrect."</span>);
<span id="L215" class="LineNr">215 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] compatible_values'</span>);
<span id="L216" class="LineNr">216 </span>};
<span id="L217" class="LineNr">217 </span><span class="Identifier">test_compatible_values</span>();
<span id="L218" class="LineNr">218 </span>
<span id="L219" class="LineNr"><a href="#l-352" data-file="lib" title="compatible_complete_states" class="back_to_proc">&#8629;</a>219 </span><span class="Identifier">test_compatible_complete_states</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L220" class="LineNr">220 </span>  ps <span class="Statement">:=</span> { [<span class="Constant">'X'</span>, <span class="Constant">true</span>] };
<span id="L221" class="LineNr">221 </span>  cs <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>( { <span class="Constant">'X'</span>, <span class="Constant">'Y'</span> },
<span id="L222" class="LineNr">222 </span>                         { [<span class="Constant">'X'</span>, {<span class="Constant">true</span>, <span class="Constant">false</span>}],
<span id="L223" class="LineNr">223 </span>                           [<span class="Constant">'Y'</span>, {<span class="Constant">true</span>, <span class="Constant">false</span>}]  });
<span id="L224" class="LineNr">224 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-352">compatible_complete_states</a>(ps, cs) <span class="Type">==</span> {
<span id="L225" class="LineNr">225 </span>         {[<span class="Constant">"X"</span>, <span class="Constant">true</span>], [<span class="Constant">"Y"</span>, <span class="Constant">false</span>]},
<span id="L226" class="LineNr">226 </span>         {[<span class="Constant">"X"</span>, <span class="Constant">true</span>], [<span class="Constant">"Y"</span>, <span class="Constant">true</span>]}
<span id="L227" class="LineNr">227 </span>       }, <span class="Constant">'Error: compatible_complete_states is incorrect'</span>);
<span id="L228" class="LineNr">228 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] compatible_complete_states'</span>);
<span id="L229" class="LineNr">229 </span>};
<span id="L230" class="LineNr">230 </span><span class="Identifier">test_compatible_complete_states</span>();
<span id="L231" class="LineNr">231 </span>
<span id="L232" class="LineNr"><a href="#l-377" data-file="lib" title="proc2func" class="back_to_proc">&#8629;</a>232 </span><span class="Identifier">test_proc2func</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L233" class="LineNr">233 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-377">proc2func</a>(<span class="Type">procedure</span>(x) { <span class="Statement">return</span> <span class="Constant">2</span> <span class="Type">*</span> x; }, { <span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span> }) <span class="Type">==</span>
<span id="L234" class="LineNr">234 </span>         { [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">2</span>,<span class="Constant">4</span>], [<span class="Constant">3</span>,<span class="Constant">6</span>] },
<span id="L235" class="LineNr">235 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L236" class="LineNr">236 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] proc2func'</span>);
<span id="L237" class="LineNr">237 </span>};
<span id="L238" class="LineNr">238 </span><span class="Identifier">test_proc2func</span>();
<span id="L239" class="LineNr">239 </span>
<span id="L240" class="LineNr"><a href="#l-382" data-file="lib" title="parse_var" class="back_to_proc">&#8629;</a>240 </span><span class="Identifier">test_parse_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L241" class="LineNr">241 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-382">parse_var</a>(<span class="Constant">'V_t4'</span>) <span class="Type">==</span> [<span class="Constant">'V'</span>, <span class="Constant">4</span>],
<span id="L242" class="LineNr">242 </span>         <span class="Constant">"Error: parse_var is incorrect."</span>);
<span id="L243" class="LineNr">243 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] parse_var'</span>);
<span id="L244" class="LineNr">244 </span>};
<span id="L245" class="LineNr">245 </span><span class="Identifier">test_parse_var</span>();
<span id="L246" class="LineNr">246 </span>
<span id="L247" class="LineNr"><a href="#l-393" data-file="lib" title="orig_var" class="back_to_proc">&#8629;</a>247 </span><span class="Identifier">test_orig_var</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L248" class="LineNr">248 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-393">orig_var</a>(<span class="Constant">'V_t3'</span>) <span class="Type">==</span> <span class="Constant">'V'</span>,
<span id="L249" class="LineNr">249 </span>         <span class="Constant">"Error: orig_var is incorrect."</span>);
<span id="L250" class="LineNr">250 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] orig_var '</span>);
<span id="L251" class="LineNr">251 </span>};
<span id="L252" class="LineNr">252 </span><span class="Identifier">test_orig_var</span>();
<span id="L253" class="LineNr">253 </span>
<span id="L254" class="LineNr"><a href="#l-397" data-file="lib" title="var_time" class="back_to_proc">&#8629;</a>254 </span><span class="Identifier">test_var_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L255" class="LineNr">255 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-397">var_time</a>(<span class="Constant">'V_t2'</span>) <span class="Type">==</span> <span class="Constant">2</span>,
<span id="L256" class="LineNr">256 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L257" class="LineNr">257 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] var_time'</span>);
<span id="L258" class="LineNr">258 </span>};
<span id="L259" class="LineNr">259 </span><span class="Identifier">test_var_time</span>();
<span id="L260" class="LineNr">260 </span>
<span id="L261" class="LineNr"><a href="#l-403" data-file="lib" title="assign_time" class="back_to_proc">&#8629;</a>261 </span><span class="Identifier">test_assign_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L262" class="LineNr">262 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-403">assign_time</a>({ [<span class="Constant">'A'</span>,    <span class="Constant">true</span>], [<span class="Constant">'B'</span>,     <span class="Constant">false</span>] }, <span class="Constant">4</span>) <span class="Type">==</span>
<span id="L263" class="LineNr">263 </span>                     { [<span class="Constant">'A_t4'</span>, <span class="Constant">true</span>], [<span class="Constant">'B_t4'</span>, <span class="Constant">false</span>] },
<span id="L264" class="LineNr">264 </span>         <span class="Constant">"Error: assign_time is incorrect."</span>);
<span id="L265" class="LineNr">265 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] assign_time'</span>);
<span id="L266" class="LineNr">266 </span>};
<span id="L267" class="LineNr">267 </span><span class="Identifier">test_assign_time</span>();
<span id="L268" class="LineNr">268 </span>
<span id="L269" class="LineNr"><a href="#l-409" data-file="lib" title="drop_time" class="back_to_proc">&#8629;</a>269 </span><span class="Identifier">test_drop_time</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L270" class="LineNr">270 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-409">drop_time</a>({ [<span class="Constant">'A_t3'</span>, <span class="Constant">true</span>], [<span class="Constant">'B_t3'</span>, <span class="Constant">false</span>] }) <span class="Type">==</span>
<span id="L271" class="LineNr">271 </span>                   { [<span class="Constant">'A'</span>,     <span class="Constant">true</span>], [<span class="Constant">'B'</span>,    <span class="Constant">false</span>] },
<span id="L272" class="LineNr">272 </span>         <span class="Constant">"Error: drop_time is incorrect."</span>);
<span id="L273" class="LineNr">273 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] drop_time'</span>);
<span id="L274" class="LineNr">274 </span>};
<span id="L275" class="LineNr">275 </span><span class="Identifier">test_drop_time</span>();
<span id="L276" class="LineNr">276 </span>
<span id="L277" class="LineNr">277 </span><span class="Comment">/*</span>
<span id="L278" class="LineNr">278 </span><span class="Comment">test_is_logical_truth := procedure() {</span>
<span id="L279" class="LineNr">279 </span><span class="Comment">  assert(true,</span>
<span id="L280" class="LineNr">280 </span><span class="Comment">         "Error: is_logical_truth is incorrect.");</span>
<span id="L281" class="LineNr">281 </span><span class="Comment">  print('[  ] is_logical_truth');</span>
<span id="L282" class="LineNr">282 </span><span class="Comment">};</span>
<span id="L283" class="LineNr">283 </span><span class="Comment">test_is_logical_truth();</span>
<span id="L284" class="LineNr">284 </span><span class="Comment">*/</span>
<span id="L285" class="LineNr">285 </span>
<span id="L286" class="LineNr"><a href="#l-526" data-file="lib" title="parse_vars" class="back_to_proc">&#8629;</a>286 </span><span class="Identifier">test_parse_vars</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L287" class="LineNr">287 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-526">parse_vars</a>(<span class="Identifier">Forall</span>(<span class="Constant">'x'</span>, <span class="Identifier">Exists</span>(<span class="Constant">'y'</span>, <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'a'</span>)))))
<span id="L288" class="LineNr">288 </span>         <span class="Type">==</span> { <span class="Constant">'x'</span>, <span class="Constant">'y'</span> },
<span id="L289" class="LineNr">289 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L290" class="LineNr">290 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] parse_vars'</span>);
<span id="L291" class="LineNr">291 </span>};
<span id="L292" class="LineNr">292 </span><span class="Identifier">test_parse_vars</span>();
<span id="L293" class="LineNr">293 </span>
<span id="L294" class="LineNr"><a href="#l-540" data-file="lib" title="sub" class="back_to_proc">&#8629;</a>294 </span><span class="Identifier">test_sub</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L295" class="LineNr">295 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-540">sub</a>(<span class="Identifier">Forall</span>(<span class="Constant">'x'</span>, <span class="Identifier">Exists</span>(<span class="Constant">'y'</span>, <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'x'</span>)))),<span class="Constant">'x'</span>,<span class="Constant">'z'</span>)
<span id="L296" class="LineNr">296 </span>         <span class="Type">==</span>  <span class="Identifier">Forall</span>(<span class="Constant">'z'</span>, <span class="Identifier">Exists</span>(<span class="Constant">'y'</span>, <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'z'</span>)))),
<span id="L297" class="LineNr">297 </span>         <span class="Constant">"Error: sub is incorrect."</span>);
<span id="L298" class="LineNr">298 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] sub'</span>);
<span id="L299" class="LineNr">299 </span>};
<span id="L300" class="LineNr">300 </span><span class="Identifier">test_sub</span>();
<span id="L301" class="LineNr">301 </span>
<span id="L302" class="LineNr"><a href="#l-552" data-file="lib" title="subformulas" class="back_to_proc">&#8629;</a>302 </span><span class="Identifier">test_subformulas</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L303" class="LineNr">303 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-552">subformulas</a>(<span class="Identifier">Forall</span>(<span class="Constant">'x'</span>, <span class="Identifier">Exists</span>(<span class="Constant">'y'</span>, <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'x'</span>)))))
<span id="L304" class="LineNr">304 </span>         <span class="Type">==</span> { <span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'x'</span>), <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'x'</span>)),
<span id="L305" class="LineNr">305 </span>              <span class="Identifier">Exists</span>(<span class="Constant">'y'</span>, <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'x'</span>))),
<span id="L306" class="LineNr">306 </span>              <span class="Identifier">Forall</span>(<span class="Constant">'x'</span>, <span class="Identifier">Exists</span>(<span class="Constant">'y'</span>, <span class="Identifier">And</span>(<span class="Identifier">Odd</span>(<span class="Constant">'b'</span>), <span class="Identifier">LessThan</span>(<span class="Constant">'y'</span>,<span class="Constant">'x'</span>))))
<span id="L307" class="LineNr">307 </span>            },
<span id="L308" class="LineNr">308 </span>         <span class="Constant">"Error: subformulas is incorrect."</span>);
<span id="L309" class="LineNr">309 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] subformulas'</span>);
<span id="L310" class="LineNr">310 </span>};
<span id="L311" class="LineNr">311 </span><span class="Identifier">test_subformulas</span>();
<span id="L312" class="LineNr">312 </span>
<span id="L313" class="LineNr"><a href="#l-566" data-file="lib" title="hausdorff_dist" class="back_to_proc">&#8629;</a>313 </span><span class="Identifier">test_hausdorff_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L314" class="LineNr">314 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-566">hausdorff_dist</a>({<span class="Constant">1</span>, <span class="Constant">8</span>, <span class="Constant">17</span>}, {<span class="Constant">4</span>, <span class="Constant">7</span>, <span class="Constant">15</span>},
<span id="L315" class="LineNr">315 </span>                        <span class="Type">procedure</span>(x, y) { <span class="Statement">return</span> (x <span class="Type">-</span> y) <span class="Type">**</span> <span class="Constant">2</span>; }) <span class="Type">==</span> <span class="Constant">9</span>,
<span id="L316" class="LineNr">316 </span>         <span class="Constant">"Error: hausdorff_dist is incorrect."</span>);
<span id="L317" class="LineNr">317 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] hausdorff_dist'</span>);
<span id="L318" class="LineNr">318 </span>};
<span id="L319" class="LineNr">319 </span><span class="Identifier">test_hausdorff_dist</span>();
<span id="L320" class="LineNr">320 </span>
<span id="L321" class="LineNr"><a href="#l-585" data-file="lib" title="kendalls_tau_dist" class="back_to_proc">&#8629;</a>321 </span><span class="Identifier">test_kendalls_tau_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L322" class="LineNr">322 </span>  <span class="Comment">// In actual usage, instead of letters, states/events would be compared.</span>
<span id="L323" class="LineNr">323 </span>  <span class="Comment">// A &gt; B &gt; C &gt; D</span>
<span id="L324" class="LineNr">324 </span>  u1 <span class="Statement">:=</span> { <span class="Identifier">Succ</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Identifier">Succ</span>(<span class="Constant">'A'</span>, <span class="Constant">'C'</span>), <span class="Identifier">Succ</span>(<span class="Constant">'A'</span>, <span class="Constant">'D'</span>),
<span id="L325" class="LineNr">325 </span>          <span class="Identifier">Succ</span>(<span class="Constant">'B'</span>, <span class="Constant">'C'</span>), <span class="Identifier">Succ</span>(<span class="Constant">'B'</span>, <span class="Constant">'D'</span>),
<span id="L326" class="LineNr">326 </span>          <span class="Identifier">Succ</span>(<span class="Constant">'C'</span>, <span class="Constant">'D'</span>) };
<span id="L327" class="LineNr">327 </span>  <span class="Comment">// C &gt; A &gt; D &gt; B</span>
<span id="L328" class="LineNr">328 </span>  <span class="Comment">// Bubble sort: abcd =&gt; aCBd =&gt; CAbd =&gt; caDB </span>
<span id="L329" class="LineNr">329 </span>  u2 <span class="Statement">:=</span> { <span class="Identifier">Succ</span>(<span class="Constant">'C'</span>, <span class="Constant">'A'</span>), <span class="Identifier">Succ</span>(<span class="Constant">'C'</span>, <span class="Constant">'D'</span>), <span class="Identifier">Succ</span>(<span class="Constant">'C'</span>, <span class="Constant">'B'</span>),
<span id="L330" class="LineNr">330 </span>          <span class="Identifier">Succ</span>(<span class="Constant">'A'</span>, <span class="Constant">'D'</span>), <span class="Identifier">Succ</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>),
<span id="L331" class="LineNr">331 </span>          <span class="Identifier">Succ</span>(<span class="Constant">'D'</span>, <span class="Constant">'B'</span>) };
<span id="L332" class="LineNr">332 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-585">kendalls_tau_dist</a>(u1, u2) <span class="Type">==</span> <span class="Constant">1</span><span class="Type">/</span><span class="Constant">2</span>, <span class="Comment">// = 3 / (4 * (4-1) / 2)</span>
<span id="L333" class="LineNr">333 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L334" class="LineNr">334 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] kendalls_tau_dist'</span>);
<span id="L335" class="LineNr">335 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] states_u'</span>);
<span id="L336" class="LineNr">336 </span>};
<span id="L337" class="LineNr">337 </span><span class="Identifier">test_kendalls_tau_dist</span>();
<span id="L338" class="LineNr">338 </span>
<span id="L339" class="LineNr"><a href="#l-599" data-file="lib" title="atom_u" class="back_to_proc">&#8629;</a>339 </span><span class="Identifier">test_atom_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L340" class="LineNr">340 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-599">atom_u</a>({ <span class="Identifier">SuccEq</span>({ [<span class="Constant">'A'</span>, <span class="Constant">true</span> ], [<span class="Constant">'B'</span>, <span class="Constant">false</span>] },
<span id="L341" class="LineNr">341 </span>                         { [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>] }) }) <span class="Type">==</span> { <span class="Constant">'A'</span>, <span class="Constant">'B'</span> },
<span id="L342" class="LineNr">342 </span>         <span class="Constant">"Error: atom_u is incorrect."</span>);
<span id="L343" class="LineNr">343 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] atom_u'</span>);
<span id="L344" class="LineNr">344 </span>};
<span id="L345" class="LineNr">345 </span><span class="Identifier">test_atom_u</span>();
<span id="L346" class="LineNr">346 </span>
<span id="L347" class="LineNr"><a href="#l-611" data-file="lib" title="card_u_to_ord_u" class="back_to_proc">&#8629;</a>347 </span><span class="Identifier">test_card_u_to_ord_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L348" class="LineNr">348 </span>  <span class="Comment">// In actual usage, instead of letters, states/events would be compared.</span>
<span id="L349" class="LineNr">349 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>({ [<span class="Constant">'A'</span>, <span class="Constant">5</span>], [<span class="Constant">'B'</span>, <span class="Constant">3</span>] }, {<span class="Constant">'A'</span>, <span class="Constant">'B'</span>}, {<span class="Constant">0</span>, <span class="Constant">0.5</span>, <span class="Constant">1</span>}) <span class="Type">==</span>
<span id="L350" class="LineNr">350 </span>         { <span class="Identifier">SuccEq</span>( {[<span class="Constant">"A"</span>, <span class="Constant">0</span>], [<span class="Constant">"B"</span>, <span class="Constant">1</span>]},       {[<span class="Constant">"A"</span>, <span class="Constant">0</span>], [<span class="Constant">"B"</span>, <span class="Constant">1</span>]}),
<span id="L351" class="LineNr">351 </span>           <span class="Identifier">SuccEq</span>( {[<span class="Constant">"A"</span>, <span class="Constant">0.5</span>], [<span class="Constant">"B"</span>, <span class="Constant">0.5</span>]},   {[<span class="Constant">"A"</span>, <span class="Constant">0</span>], [<span class="Constant">"B"</span>, <span class="Constant">1</span>]}),
<span id="L352" class="LineNr">352 </span>           <span class="Identifier">SuccEq</span>( {[<span class="Constant">"A"</span>, <span class="Constant">0.5</span>], [<span class="Constant">"B"</span>, <span class="Constant">0.5</span>]},   {[<span class="Constant">"A"</span>, <span class="Constant">0.5</span>], [<span class="Constant">"B"</span>, <span class="Constant">0.5</span>]}),
<span id="L353" class="LineNr">353 </span>           <span class="Identifier">SuccEq</span>( {[<span class="Constant">"A"</span>, <span class="Constant">1</span>], [<span class="Constant">"B"</span>, <span class="Constant">0</span>]},        {[<span class="Constant">"A"</span>, <span class="Constant">0</span>], [<span class="Constant">"B"</span>, <span class="Constant">1</span>]}),
<span id="L354" class="LineNr">354 </span>           <span class="Identifier">SuccEq</span>( {[<span class="Constant">"A"</span>, <span class="Constant">1</span>], [<span class="Constant">"B"</span>, <span class="Constant">0</span>]},        {[<span class="Constant">"A"</span>, <span class="Constant">0.5</span>], [<span class="Constant">"B"</span>, <span class="Constant">0.5</span>]}),
<span id="L355" class="LineNr">355 </span>           <span class="Identifier">SuccEq</span>( {[<span class="Constant">"A"</span>, <span class="Constant">1</span>], [<span class="Constant">"B"</span>, <span class="Constant">0</span>]},        {[<span class="Constant">"A"</span>, <span class="Constant">1</span>], [<span class="Constant">"B"</span>, <span class="Constant">0</span>]})
<span id="L356" class="LineNr">356 </span>         }, <span class="Constant">"Error: card_u_to_ord_u is incorrect."</span>);
<span id="L357" class="LineNr">357 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] card_u_to_ord_u'</span>);
<span id="L358" class="LineNr">358 </span>};
<span id="L359" class="LineNr">359 </span><span class="Identifier">test_card_u_to_ord_u</span>();
<span id="L360" class="LineNr">360 </span>
<span id="L361" class="LineNr"><a href="#l-635" data-file="lib" title="add_u_to_card_u" class="back_to_proc">&#8629;</a>361 </span><span class="Identifier">test_add_u_to_card_u</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L362" class="LineNr">362 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-635">add_u_to_card_u</a>({ [<span class="Constant">'A'</span>, <span class="Constant">3</span>], [<span class="Constant">'B'</span>, <span class="Constant">5</span>], [<span class="Constant">'C'</span>, <span class="Constant">9</span>],
<span id="L363" class="LineNr">363 </span>                           [<span class="Identifier">And</span>(<span class="Constant">'A'</span>,<span class="Constant">'B'</span>), <span class="Type">-</span><span class="Constant">2</span>] },
<span id="L364" class="LineNr">364 </span>                         <span class="Identifier">exprs_to_state_space</span>({ <span class="Constant">'A'</span>, <span class="Constant">'B'</span>, <span class="Constant">'C'</span> })) <span class="Type">==</span>
<span id="L365" class="LineNr">365 </span>         { [{ [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>], [<span class="Constant">'C'</span>, <span class="Constant">false</span>] }, <span class="Constant">0</span>],
<span id="L366" class="LineNr">366 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>], [<span class="Constant">'C'</span>, <span class="Constant">true</span> ] }, <span class="Constant">9</span>],
<span id="L367" class="LineNr">367 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ], [<span class="Constant">'C'</span>, <span class="Constant">false</span>] }, <span class="Constant">5</span>],
<span id="L368" class="LineNr">368 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ], [<span class="Constant">'C'</span>, <span class="Constant">true</span> ] }, <span class="Constant">14</span>],
<span id="L369" class="LineNr">369 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">true</span> ], [<span class="Constant">'B'</span>, <span class="Constant">false</span>], [<span class="Constant">'C'</span>, <span class="Constant">false</span>] }, <span class="Constant">3</span>],
<span id="L370" class="LineNr">370 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">true</span> ], [<span class="Constant">'B'</span>, <span class="Constant">false</span>], [<span class="Constant">'C'</span>, <span class="Constant">true</span> ] }, <span class="Constant">12</span>],
<span id="L371" class="LineNr">371 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">true</span> ], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ], [<span class="Constant">'C'</span>, <span class="Constant">false</span>] }, <span class="Constant">6</span>],
<span id="L372" class="LineNr">372 </span>           [{ [<span class="Constant">'A'</span>, <span class="Constant">true</span> ], [<span class="Constant">'B'</span>, <span class="Constant">true</span> ], [<span class="Constant">'C'</span>, <span class="Constant">true</span> ] }, <span class="Constant">15</span>]
<span id="L373" class="LineNr">373 </span>         },
<span id="L374" class="LineNr">374 </span>         <span class="Constant">"Error: add_u_to_card_u is incorrect."</span>);
<span id="L375" class="LineNr">375 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] add_u_to_card_u'</span>);
<span id="L376" class="LineNr">376 </span>};
<span id="L377" class="LineNr">377 </span><span class="Identifier">test_add_u_to_card_u</span>();
<span id="L378" class="LineNr">378 </span>
<span id="L379" class="LineNr"><a href="#l-674" data-file="lib" title="ord_u_dist" class="back_to_proc">&#8629;</a>379 </span><span class="Identifier">test_ord_u_dist</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L380" class="LineNr">380 </span>  <span class="Comment">// Todo: manually set ord_us with partial states</span>
<span id="L381" class="LineNr">381 </span>  dom <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-647">exprs_to_state_space</a>({ <span class="Constant">'A'</span>, <span class="Constant">'B'</span> });
<span id="L382" class="LineNr">382 </span>  ldom <span class="Statement">:=</span> [ x <span class="Type">:</span> x <span class="Type">in</span> dom ];
<span id="L383" class="LineNr">383 </span>  probs <span class="Statement">:=</span> {<span class="Constant">0</span>, <span class="Constant">0.5</span>, <span class="Constant">1</span>};
<span id="L384" class="LineNr">384 </span>  <span class="Comment">// probs := {0, 1};</span>
<span id="L385" class="LineNr">385 </span>  u1 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>({
<span id="L386" class="LineNr">386 </span>    [ldom[<span class="Constant">1</span>], <span class="Constant">10</span>], [ldom[<span class="Constant">2</span>], <span class="Constant">7</span>], [ldom[<span class="Constant">3</span>], <span class="Constant">3</span> ], [ldom[<span class="Constant">4</span>], <span class="Constant">0</span>]
<span id="L387" class="LineNr">387 </span>  }, dom, probs);
<span id="L388" class="LineNr">388 </span>  u2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-611">card_u_to_ord_u</a>({
<span id="L389" class="LineNr">389 </span>    [ldom[<span class="Constant">1</span>], <span class="Constant">9</span>], [ldom[<span class="Constant">2</span>], <span class="Constant">1</span>], [ldom[<span class="Constant">3</span>], <span class="Constant">11</span> ], [ldom[<span class="Constant">4</span>], <span class="Constant">4</span>]
<span id="L390" class="LineNr">390 </span>  }, dom, probs);
<span id="L391" class="LineNr">391 </span>  <span class="Comment">// print(ord_u_dist(u1, u2));</span>
<span id="L392" class="LineNr">392 </span>  <span class="Comment">// assert(ord_u_dist(u1, u2) == 1/2,</span>
<span id="L393" class="LineNr">393 </span>  <span class="Comment">//       "Error: ord_u_dist is incorrect.");</span>
<span id="L394" class="LineNr">394 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ ?] ord_u_dist'</span>);
<span id="L395" class="LineNr">395 </span>  <span class="Identifier">print</span>(<span class="Constant">'[  ] ord_u_dist w/ sharpenings'</span>);
<span id="L396" class="LineNr">396 </span>};
<span id="L397" class="LineNr">397 </span><span class="Identifier">test_ord_u_dist</span>();
<span id="L398" class="LineNr">398 </span>
<span id="L399" class="LineNr"><a href="#l-708" data-file="lib" title="sort_list" class="back_to_proc">&#8629;</a>399 </span><span class="Identifier">test_sort_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L400" class="LineNr">400 </span>  <span class="Identifier">less</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(x, y) { <span class="Statement">return</span> x <span class="Type">&lt;</span> y; };
<span id="L401" class="LineNr">401 </span>  <span class="Identifier">greater</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(x, y) { <span class="Statement">return</span> y <span class="Type">&lt;</span> x; };
<span id="L402" class="LineNr">402 </span>
<span id="L403" class="LineNr">403 </span>  l <span class="Statement">:=</span> [<span class="Constant">1</span>,<span class="Constant">3</span>,<span class="Constant">5</span>,<span class="Constant">4</span>,<span class="Constant">2</span>];
<span id="L404" class="LineNr">404 </span>  s1 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(l, less );
<span id="L405" class="LineNr">405 </span>  s2 <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-708">sort_list</a>(l, greater);
<span id="L406" class="LineNr">406 </span>  <span class="Statement">assert</span>(s1 <span class="Type">==</span> [<span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span>,<span class="Constant">4</span>,<span class="Constant">5</span>], <span class="Constant">'Error: sort_list is incorrect.'</span>);
<span id="L407" class="LineNr">407 </span>  <span class="Statement">assert</span>(s2 <span class="Type">==</span> [<span class="Constant">5</span>,<span class="Constant">4</span>,<span class="Constant">3</span>,<span class="Constant">2</span>,<span class="Constant">1</span>], <span class="Constant">'Error: sort_list is incorrect.'</span>);
<span id="L408" class="LineNr">408 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] sort_list'</span>);
<span id="L409" class="LineNr">409 </span>};
<span id="L410" class="LineNr">410 </span><span class="Identifier">test_sort_list</span>();
<span id="L411" class="LineNr">411 </span>
<span id="L412" class="LineNr">412 </span><span class="Identifier">test_sort_list</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L413" class="LineNr">413 </span>  <span class="Identifier">less</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(x, y) { <span class="Statement">return</span> x <span class="Type">&lt;</span> y; };
<span id="L414" class="LineNr">414 </span>  s <span class="Statement">:=</span> {<span class="Constant">1</span>,<span class="Constant">3</span>,<span class="Constant">5</span>,<span class="Constant">4</span>,<span class="Constant">2</span>};
<span id="L415" class="LineNr">415 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-716">sort_set</a>(s, less) <span class="Type">==</span> [<span class="Constant">1</span>,<span class="Constant">2</span>,<span class="Constant">3</span>,<span class="Constant">4</span>,<span class="Constant">5</span>], <span class="Constant">'Error: sort_list is incorrect.'</span>);
<span id="L416" class="LineNr">416 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] sort_set'</span>);
<span id="L417" class="LineNr">417 </span>};
<span id="L418" class="LineNr">418 </span><span class="Identifier">test_sort_list</span>();
<span id="L419" class="LineNr">419 </span>
<span id="L420" class="LineNr"><a href="#l-751" data-file="lib" title="restrict_domain" class="back_to_proc">&#8629;</a>420 </span><span class="Identifier">test_restrict_domain</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L421" class="LineNr">421 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-751">restrict_domain</a>({ [<span class="Constant">'a'</span>, <span class="Constant">1</span>], [<span class="Constant">'b'</span>, <span class="Constant">3</span>], [<span class="Constant">'c'</span>, <span class="Constant">5</span>] }, {<span class="Constant">'b'</span>, <span class="Constant">'c'</span>})
<span id="L422" class="LineNr">422 </span>           <span class="Type">==</span> { [<span class="Constant">'b'</span>, <span class="Constant">3</span>], [<span class="Constant">'c'</span>, <span class="Constant">5</span>] },
<span id="L423" class="LineNr">423 </span>         <span class="Constant">"Error: is incorrect."</span>);
<span id="L424" class="LineNr">424 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] restrict_doman'</span>);
<span id="L425" class="LineNr">425 </span>};
<span id="L426" class="LineNr">426 </span><span class="Identifier">test_restrict_domain</span>();
<span id="L427" class="LineNr">427 </span>
<span id="L428" class="LineNr"><a href="#l-755" data-file="lib" title="restricted_eq" class="back_to_proc">&#8629;</a>428 </span><span class="Identifier">test_restricted_eq</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L429" class="LineNr">429 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>({[<span class="Constant">'a'</span>, <span class="Constant">1</span>], [<span class="Constant">'b'</span>, <span class="Constant">2</span>], [<span class="Constant">'c'</span>, <span class="Constant">3</span>]},
<span id="L430" class="LineNr">430 </span>                                 {[<span class="Constant">'b'</span>, <span class="Constant">2</span>], [<span class="Constant">'c'</span>, <span class="Constant">3</span>]} ) <span class="Type">==</span> <span class="Constant">true</span>,
<span id="L431" class="LineNr">431 </span>         <span class="Constant">"Error: restricted_eq true is incorrect."</span>);
<span id="L432" class="LineNr">432 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] restricted_eq true'</span>);
<span id="L433" class="LineNr">433 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-755">restricted_eq</a>({[<span class="Constant">'a'</span>, <span class="Constant">1</span>], [<span class="Constant">'b'</span>, <span class="Constant">2</span>], [<span class="Constant">'c'</span>, <span class="Constant">3</span>]},
<span id="L434" class="LineNr">434 </span>                                 {[<span class="Constant">'b'</span>, <span class="Constant">2</span>], [<span class="Constant">'c'</span>, <span class="Constant">3</span>], [<span class="Constant">'d'</span>, <span class="Constant">4</span>]} ) <span class="Type">==</span> <span class="Constant">false</span>,
<span id="L435" class="LineNr">435 </span>         <span class="Constant">"Error: restricted_eq false is incorrect."</span>);
<span id="L436" class="LineNr">436 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] restricted_eq false'</span>);
<span id="L437" class="LineNr">437 </span>};
<span id="L438" class="LineNr">438 </span><span class="Identifier">test_restricted_eq</span>();
<span id="L439" class="LineNr">439 </span>
<span id="L440" class="LineNr"><a href="#l-55" data-file="lib" title="range_for_arity" class="back_to_proc">&#8629;</a>440 </span><span class="Identifier">test_range_for_arity</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L441" class="LineNr">441 </span>  poss_sts <span class="Statement">:=</span> <a class="Identifier code-proc-link" href="#l-328">possible_states</a>({ <span class="Constant">'A'</span>, <span class="Constant">'B'</span> }, { [<span class="Constant">'A'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()], [<span class="Constant">'B'</span>, <a class="Identifier code-proc-link" href="#l-3">tf</a>()] });
<span id="L442" class="LineNr">442 </span>  sts <span class="Statement">:=</span> { <span class="Identifier">first</span>(poss_sts), { [<span class="Constant">'A'</span>, <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>]} };
<span id="L443" class="LineNr">443 </span>  <span class="Statement">assert</span>(sts <span class="Type">in</span> <a class="Identifier code-proc-link" href="#l-55">range_for_arity</a>(<span class="Constant">0</span>, poss_sts),
<span id="L444" class="LineNr">444 </span>         <span class="Constant">"Error: range_for_arity 0 is incorrect."</span>);
<span id="L445" class="LineNr">445 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] range_for_arity 0'</span>);
<span id="L446" class="LineNr">446 </span>  sts2 <span class="Statement">:=</span> { { [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>]}, { [<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span>]} };
<span id="L447" class="LineNr">447 </span>  <span class="Comment">// assert({ [sts], [sts2] } in range_for_arity(1, poss_sts), </span>
<span id="L448" class="LineNr">448 </span>  <span class="Comment">//       "Error: range_for_arity 1 is incorrect.");</span>
<span id="L449" class="LineNr">449 </span>  <span class="Comment">// print('[ok] range_for_arity 1');</span>
<span id="L450" class="LineNr">450 </span>  <span class="Identifier">print</span>(<span class="Constant">'[..] range_for_arity 1'</span>);
<span id="L451" class="LineNr">451 </span>  <span class="Comment">// assert({ [sts, sts2] } in range_for_arity(2, poss_sts),</span>
<span id="L452" class="LineNr">452 </span>  <span class="Comment">//       "Error: range_for_arity 2 is incorrect.");</span>
<span id="L453" class="LineNr">453 </span>  <span class="Comment">// print('[ok] range_for_arity 2');</span>
<span id="L454" class="LineNr">454 </span>};
<span id="L455" class="LineNr">455 </span><span class="Identifier">test_range_for_arity</span>();
<span id="L456" class="LineNr">456 </span>
<span id="L457" class="LineNr"><a href="#l-647" data-file="lib" title="exprs_to_state_space" class="back_to_proc">&#8629;</a>457 </span><span class="Identifier">test_exprs_to_state_space</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L458" class="LineNr">458 </span>  <span class="Statement">assert</span>(<a class="Identifier code-proc-link" href="#l-647">exprs_to_state_space</a>({ <span class="Constant">"A"</span>, <span class="Constant">"B"</span>, <span class="Identifier">Implies</span>(<span class="Constant">"A"</span>, <span class="Constant">"B"</span>),
<span id="L459" class="LineNr">459 </span>                                <span class="Identifier">Not</span>(<span class="Identifier">And</span>(<span class="Constant">"A"</span>, <span class="Identifier">Not</span>(<span class="Constant">"B"</span>))) }) <span class="Type">==</span> {
<span id="L460" class="LineNr">460 </span>           {[<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>]}, {[<span class="Constant">'A'</span>, <span class="Constant">false</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span>]},
<span id="L461" class="LineNr">461 </span>           {[<span class="Constant">'A'</span>,  <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">false</span>]}, {[<span class="Constant">'A'</span>,  <span class="Constant">true</span>], [<span class="Constant">'B'</span>, <span class="Constant">true</span>]}
<span id="L462" class="LineNr">462 </span>         }, <span class="Constant">"Error: exprs_to_state_space is incorrect."</span>);
<span id="L463" class="LineNr">463 </span>  <span class="Identifier">print</span>(<span class="Constant">'[ok] exprs_to_state_space'</span>);
<span id="L464" class="LineNr">464 </span>};
<span id="L465" class="LineNr">465 </span><span class="Identifier">test_exprs_to_state_space</span>();
</pre>
<pre class="vimCodeElement" id="setlx"><div id="cheat_sheet">
<span id="L1" class="LineNr">  1 </span><span class="Comment">/* SetlX 2.2.0 Cheat Sheet</span>
<span id="L2" class="LineNr">  2 </span><span class="Comment">   Here I've compiled a short list of examples illustrating the setlX language.</span>
<span id="L3" class="LineNr">  3 </span>
<span id="L4" class="LineNr">  4 </span><span class="Comment">   There is also a slightly expanded <a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank"></a><a class="quick_ref" target="_blank">quick_ref.stlx</a> version which demonstrates </span>
<span id="L5" class="LineNr">  5 </span><span class="Comment">   nearly all the setlX needed in order to understand MetaEthical.AI. The main </span>
<span id="L6" class="LineNr">  6 </span><span class="Comment">   difference is that this cheat sheet focuses on aspects that are more unique </span>
<span id="L7" class="LineNr">  7 </span><span class="Comment">   to the setlX language and omits many commands that are more obvious or </span>
<span id="L8" class="LineNr">  8 </span><span class="Comment">   self-explanatory, especially among programmers.</span>
<span id="L9" class="LineNr">  9 </span>
<span id="L10" class="LineNr"> 10 </span><span class="Comment">   A much more thorough guide can be found in the official setlX <a href="/images/setlX_v2-2-0_tutorial.pdf" target="_blank">tutorial.pdf</a>.</span>
<span id="L11" class="LineNr"> 11 </span><span class="Comment">*/</span>
<span id="L12" class="LineNr"> 12 </span>
<span id="L13" class="LineNr"> 13 </span><span class="Comment">// Standard Arithmetic Operations </span>
<span id="L14" class="LineNr"> 14 </span>x <span class="Statement">:=</span> (<span class="Constant">1</span> <span class="Type">+</span> <span class="Constant">2</span>) <span class="Type">*</span> <span class="Constant">3</span> <span class="Type">/</span> <span class="Constant">4</span>;
<span id="L15" class="LineNr"> 15 </span><span class="Comment">// ~&lt; Result: 9/4 &gt;~</span>
<span id="L16" class="LineNr"> 16 </span><span class="Comment">/* Note that lines always end with a semi-colon. </span>
<span id="L17" class="LineNr"> 17 </span><span class="Comment">   Assignment of a value to a variable is done with ":=", not "=".</span>
<span id="L18" class="LineNr"> 18 </span><span class="Comment">   Variable names start with a lowercase letter because capitalized names are</span>
<span id="L19" class="LineNr"> 19 </span><span class="Comment">     reserved for setlx functors.  */</span>
<span id="L20" class="LineNr"> 20 </span>
<span id="L21" class="LineNr"> 21 </span><span class="Comment">// Exponents</span>
<span id="L22" class="LineNr"> 22 </span><span class="Constant">2</span> <span class="Type">**</span> <span class="Constant">5</span>;
<span id="L23" class="LineNr"> 23 </span><span class="Comment">// ~&lt; Result: 32 &gt;~</span>
<span id="L24" class="LineNr"> 24 </span>
<span id="L25" class="LineNr"> 25 </span><span class="Comment">// String Length</span>
<span id="L26" class="LineNr"> 26 </span><span class="Type">#</span><span class="Constant">"abc"</span>;
<span id="L27" class="LineNr"> 27 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L28" class="LineNr"> 28 </span>
<span id="L29" class="LineNr"> 29 </span>
<span id="L30" class="LineNr"> 30 </span><span class="Comment Heading">// Sets</span>
<span id="L31" class="LineNr"> 31 </span><span class="Comment Heading">// ====</span>
<span id="L32" class="LineNr"> 32 </span>a <span class="Statement">:=</span> { <span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span> };
<span id="L33" class="LineNr"> 33 </span>b <span class="Statement">:=</span> { <span class="Constant">3</span>, <span class="Constant">4</span>, <span class="Constant">5</span> };
<span id="L34" class="LineNr"> 34 </span>
<span id="L35" class="LineNr"> 35 </span><span class="Comment">// Cardinality</span>
<span id="L36" class="LineNr"> 36 </span><span class="Type">#</span>b;
<span id="L37" class="LineNr"> 37 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L38" class="LineNr"> 38 </span>
<span id="L39" class="LineNr"> 39 </span><span class="Comment">// Union</span>
<span id="L40" class="LineNr"> 40 </span>a <span class="Type">+</span> b;
<span id="L41" class="LineNr"> 41 </span><span class="Comment">// ~&lt; Result: {1, 2, 3, 4, 5} &gt;~</span>
<span id="L42" class="LineNr"> 42 </span>
<span id="L43" class="LineNr"> 43 </span><span class="Comment">// Intersection</span>
<span id="L44" class="LineNr"> 44 </span>a <span class="Type">*</span> b;
<span id="L45" class="LineNr"> 45 </span><span class="Comment">// ~&lt; Result: {3} &gt;~</span>
<span id="L46" class="LineNr"> 46 </span>
<span id="L47" class="LineNr"> 47 </span><span class="Comment">// Difference</span>
<span id="L48" class="LineNr"> 48 </span>a <span class="Type">-</span> b;
<span id="L49" class="LineNr"> 49 </span><span class="Comment">// ~&lt; Result: {1, 2} &gt;~</span>
<span id="L50" class="LineNr"> 50 </span>
<span id="L51" class="LineNr"> 51 </span><span class="Comment">// Check Membership</span>
<span id="L52" class="LineNr"> 52 </span><span class="Constant">1</span> <span class="Type">in</span> a;
<span id="L53" class="LineNr"> 53 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L54" class="LineNr"> 54 </span>
<span id="L55" class="LineNr"> 55 </span><span class="Comment">// Check if Subset</span>
<span id="L56" class="LineNr"> 56 </span>{<span class="Constant">1</span>, <span class="Constant">2</span>} <span class="Type">&lt;</span> {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>};
<span id="L57" class="LineNr"> 57 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L58" class="LineNr"> 58 </span>
<span id="L59" class="LineNr"> 59 </span><span class="Comment">// Powerset</span>
<span id="L60" class="LineNr"> 60 </span><span class="Identifier">pow</span>({ <span class="Constant">1</span>, <span class="Constant">2</span> });
<span id="L61" class="LineNr"> 61 </span><span class="Comment">// ~&lt; Result: {{}, {1}, {1, 2}, {2}} &gt;~</span>
<span id="L62" class="LineNr"> 62 </span><span class="Constant">2</span> <span class="Type">**</span> { <span class="Constant">1</span>, <span class="Constant">2</span> }; <span class="Comment">// alternate syntax</span>
<span id="L63" class="LineNr"> 63 </span><span class="Comment">// ~&lt; Result: {{}, {1}, {1, 2}, {2}} &gt;~</span>
<span id="L64" class="LineNr"> 64 </span>
<span id="L65" class="LineNr"> 65 </span><span class="Comment">// Cartesian Product</span>
<span id="L66" class="LineNr"> 66 </span>pairs <span class="Statement">:=</span> { <span class="Constant">'a'</span>, <span class="Constant">'b'</span> } <span class="Type">&gt;&lt;</span> { <span class="Constant">1</span>, <span class="Constant">2</span> };
<span id="L67" class="LineNr"> 67 </span><span class="Comment">// ~&lt; Result: {["a", 1], ["a", 2], ["b", 1], ["b", 2]} &gt;~</span>
<span id="L68" class="LineNr"> 68 </span>
<span id="L69" class="LineNr"> 69 </span><span class="Comment">// Set comprehension</span>
<span id="L70" class="LineNr"> 70 </span>{ x <span class="Type">*</span> <span class="Constant">2</span> <span class="Type">:</span> x <span class="Type">in</span> a };
<span id="L71" class="LineNr"> 71 </span><span class="Comment">// ~&lt; Result: {2, 4, 6} &gt;~</span>
<span id="L72" class="LineNr"> 72 </span>
<span id="L73" class="LineNr"> 73 </span><span class="Comment">// Set comprehension with filter</span>
<span id="L74" class="LineNr"> 74 </span>{ x <span class="Type">:</span> x <span class="Type">in</span> a <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">3</span> };
<span id="L75" class="LineNr"> 75 </span><span class="Comment">// ~&lt; Result: {1, 2} &gt;~</span>
<span id="L76" class="LineNr"> 76 </span>
<span id="L77" class="LineNr"> 77 </span><span class="Comment">// Set comprehension with list pattern matching</span>
<span id="L78" class="LineNr"> 78 </span><span class="Comment">// Also, since we don't use the first element of the ordered pair, we can </span>
<span id="L79" class="LineNr"> 79 </span><span class="Comment">// discard it with _ instead of giving it a variable name.</span>
<span id="L80" class="LineNr"> 80 </span>{ y <span class="Type">:</span> [_, y] <span class="Type">in</span> pairs };
<span id="L81" class="LineNr"> 81 </span><span class="Comment">// ~&lt; Result: {1, 2} &gt;~</span>
<span id="L82" class="LineNr"> 82 </span>
<span id="L83" class="LineNr"> 83 </span><span class="Comment">// Quantification</span>
<span id="L84" class="LineNr"> 84 </span><span class="Type">exists</span>(x <span class="Type">in</span> a <span class="Type">|</span> x <span class="Type">==</span> <span class="Constant">2</span>);
<span id="L85" class="LineNr"> 85 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L86" class="LineNr"> 86 </span><span class="Type">forall</span>(x <span class="Type">in</span> a <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">5</span>);
<span id="L87" class="LineNr"> 87 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L88" class="LineNr"> 88 </span>
<span id="L89" class="LineNr"> 89 </span><span class="Comment">// Returns the first element according to the language's internal order.</span>
<span id="L90" class="LineNr"> 90 </span><span class="Comment">// If the set is not all numbers or lists of them, the ordering should not be </span>
<span id="L91" class="LineNr"> 91 </span><span class="Comment">// relied upon.</span>
<span id="L92" class="LineNr"> 92 </span><span class="Identifier">first</span>(a);
<span id="L93" class="LineNr"> 93 </span><span class="Comment">// ~&lt; Result: 1 &gt;~</span>
<span id="L94" class="LineNr"> 94 </span>
<span id="L95" class="LineNr"> 95 </span><span class="Comment">// Sum of a Set of...</span>
<span id="L96" class="LineNr"> 96 </span><span class="Comment">//   Integers </span>
<span id="L97" class="LineNr"> 97 </span><span class="Type">+/</span> {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>};
<span id="L98" class="LineNr"> 98 </span><span class="Comment">// ~&lt; Result: 6 &gt;~</span>
<span id="L99" class="LineNr"> 99 </span>
<span id="L100" class="LineNr">100 </span><span class="Comment">//   Strings</span>
<span id="L101" class="LineNr">101 </span><span class="Type">+/</span> {<span class="Constant">'a'</span>, <span class="Constant">'b'</span>, <span class="Constant">'c'</span>};
<span id="L102" class="LineNr">102 </span><span class="Comment">// ~&lt; Result: "abc" &gt;~</span>
<span id="L103" class="LineNr">103 </span>
<span id="L104" class="LineNr">104 </span><span class="Comment">//   Sets</span>
<span id="L105" class="LineNr">105 </span><span class="Type">+/</span> { {<span class="Constant">1</span>, <span class="Constant">2</span>}, {<span class="Constant">3</span>, <span class="Constant">4</span>} };
<span id="L106" class="LineNr">106 </span><span class="Comment">// ~&lt; Result: {1, 2, 3, 4} &gt;~</span>
<span id="L107" class="LineNr">107 </span>
<span id="L108" class="LineNr">108 </span><span class="Comment">//   Lists</span>
<span id="L109" class="LineNr">109 </span><span class="Type">+/</span> { [<span class="Constant">1</span>, <span class="Constant">2</span>], [<span class="Constant">3</span>, <span class="Constant">4</span>] };
<span id="L110" class="LineNr">110 </span><span class="Comment">// ~&lt; Result: [1, 2, 3, 4] &gt;~</span>
<span id="L111" class="LineNr">111 </span>
<span id="L112" class="LineNr">112 </span>
<span id="L113" class="LineNr">113 </span><span class="Comment Heading">// Lists</span>
<span id="L114" class="LineNr">114 </span><span class="Comment Heading">// =====</span>
<span id="L115" class="LineNr">115 </span>l <span class="Statement">:=</span> [ <span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span> ];
<span id="L116" class="LineNr">116 </span>m <span class="Statement">:=</span> [ <span class="Constant">3</span>, <span class="Constant">4</span>, <span class="Constant">5</span> ];
<span id="L117" class="LineNr">117 </span>
<span id="L118" class="LineNr">118 </span><span class="Comment">// Note that list indexes start at 1! </span>
<span id="L119" class="LineNr">119 </span><span class="Comment">// Not 0 as with most other programming languages.</span>
<span id="L120" class="LineNr">120 </span>m[<span class="Constant">1</span>];
<span id="L121" class="LineNr">121 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L122" class="LineNr">122 </span>
<span id="L123" class="LineNr">123 </span><span class="Comment">// Concatenation</span>
<span id="L124" class="LineNr">124 </span>l <span class="Type">+</span> m;
<span id="L125" class="LineNr">125 </span><span class="Comment">// ~&lt; Result: [ 1, 2, 3, 3, 4, 5] &gt;~</span>
<span id="L126" class="LineNr">126 </span><span class="Comment">// Note that unlike with sets, the 3 is duplicated</span>
<span id="L127" class="LineNr">127 </span>
<span id="L128" class="LineNr">128 </span><span class="Comment">// List comprehension</span>
<span id="L129" class="LineNr">129 </span>[ x <span class="Type">*</span> <span class="Constant">2</span> <span class="Type">:</span> x <span class="Type">in</span> l ];
<span id="L130" class="LineNr">130 </span><span class="Comment">// ~&lt; Result: [2, 4, 6] &gt;~</span>
<span id="L131" class="LineNr">131 </span>
<span id="L132" class="LineNr">132 </span><span class="Comment">// List comprehension with filter</span>
<span id="L133" class="LineNr">133 </span>[ x <span class="Type">:</span> x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">3</span> ];
<span id="L134" class="LineNr">134 </span><span class="Comment">// ~&lt; Result: [1, 2] &gt;~</span>
<span id="L135" class="LineNr">135 </span>
<span id="L136" class="LineNr">136 </span><span class="Comment">// Check Inclusion</span>
<span id="L137" class="LineNr">137 </span><span class="Constant">1</span> <span class="Type">in</span> l;
<span id="L138" class="LineNr">138 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L139" class="LineNr">139 </span>
<span id="L140" class="LineNr">140 </span><span class="Comment">// Quantification</span>
<span id="L141" class="LineNr">141 </span><span class="Type">exists</span>(x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">==</span> <span class="Constant">2</span>);
<span id="L142" class="LineNr">142 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L143" class="LineNr">143 </span><span class="Type">forall</span>(x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">5</span>);
<span id="L144" class="LineNr">144 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L145" class="LineNr">145 </span>
<span id="L146" class="LineNr">146 </span><span class="Comment">// Range</span>
<span id="L147" class="LineNr">147 </span>m[<span class="Constant">1</span><span class="Statement">..</span><span class="Constant">2</span>];
<span id="L148" class="LineNr">148 </span><span class="Comment">// ~&lt; Result: [3, 4] &gt;~</span>
<span id="L149" class="LineNr">149 </span>
<span id="L150" class="LineNr">150 </span>m[<span class="Statement">..</span><span class="Constant">2</span>];
<span id="L151" class="LineNr">151 </span><span class="Comment">// ~&lt; Result: [3, 4] &gt;~</span>
<span id="L152" class="LineNr">152 </span>
<span id="L153" class="LineNr">153 </span>m[<span class="Constant">2</span><span class="Statement">..</span>];
<span id="L154" class="LineNr">154 </span><span class="Comment">// ~&lt; Result: [4, 5] &gt;~</span>
<span id="L155" class="LineNr">155 </span>
<span id="L156" class="LineNr">156 </span><span class="Identifier">first</span>([<span class="Constant">3</span>,<span class="Constant">2</span>,<span class="Constant">1</span>]);
<span id="L157" class="LineNr">157 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L158" class="LineNr">158 </span>
<span id="L159" class="LineNr">159 </span><span class="Identifier">last</span>([<span class="Constant">3</span>,<span class="Constant">2</span>,<span class="Constant">1</span>]);
<span id="L160" class="LineNr">160 </span><span class="Comment">// ~&lt; Result: 1 &gt;~</span>
<span id="L161" class="LineNr">161 </span>
<span id="L162" class="LineNr">162 </span><span class="Identifier">permutations</span>([<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>]);
<span id="L163" class="LineNr">163 </span><span class="Comment">// ~&lt; Result: {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]} &gt;~</span>
<span id="L164" class="LineNr">164 </span>
<span id="L165" class="LineNr">165 </span><span class="Comment">// Sum of a List of:</span>
<span id="L166" class="LineNr">166 </span><span class="Comment">//   Integers </span>
<span id="L167" class="LineNr">167 </span><span class="Type">+/</span> [<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>];
<span id="L168" class="LineNr">168 </span><span class="Comment">// ~&lt; Result: 6 &gt;~</span>
<span id="L169" class="LineNr">169 </span>
<span id="L170" class="LineNr">170 </span><span class="Comment">//   Strings</span>
<span id="L171" class="LineNr">171 </span><span class="Type">+/</span> [<span class="Constant">'a'</span>, <span class="Constant">'b'</span>, <span class="Constant">'c'</span>];
<span id="L172" class="LineNr">172 </span><span class="Comment">// ~&lt; Result: "abc" &gt;~</span>
<span id="L173" class="LineNr">173 </span>
<span id="L174" class="LineNr">174 </span><span class="Comment">//   Sets</span>
<span id="L175" class="LineNr">175 </span><span class="Type">+/</span> [ {<span class="Constant">1</span>, <span class="Constant">2</span>}, {<span class="Constant">3</span>, <span class="Constant">4</span>} ];
<span id="L176" class="LineNr">176 </span><span class="Comment">// ~&lt; Result: {1, 2, 3, 4} &gt;~</span>
<span id="L177" class="LineNr">177 </span>
<span id="L178" class="LineNr">178 </span><span class="Comment">//   Lists</span>
<span id="L179" class="LineNr">179 </span><span class="Type">+/</span> [ [<span class="Constant">1</span>, <span class="Constant">2</span>], [<span class="Constant">3</span>, <span class="Constant">4</span>] ];
<span id="L180" class="LineNr">180 </span><span class="Comment">// ~&lt; Result: [1, 2, 3, 4] &gt;~</span>
<span id="L181" class="LineNr">181 </span>
<span id="L182" class="LineNr">182 </span>
<span id="L183" class="LineNr">183 </span><span class="Comment Heading">// Functions</span>
<span id="L184" class="LineNr">184 </span><span class="Comment Heading">// =========</span>
<span id="L185" class="LineNr">185 </span><span class="Comment">// They are just sets of ordered pairs where each element of the domain is </span>
<span id="L186" class="LineNr">186 </span><span class="Comment">// mapped to one element of the range.</span>
<span id="L187" class="LineNr">187 </span>f <span class="Statement">:=</span> { [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">2</span>,<span class="Constant">4</span>], [<span class="Constant">3</span>,<span class="Constant">6</span>] };
<span id="L188" class="LineNr">188 </span>
<span id="L189" class="LineNr">189 </span><span class="Comment">// You can find the value given an input</span>
<span id="L190" class="LineNr">190 </span>f[<span class="Constant">2</span>];
<span id="L191" class="LineNr">191 </span><span class="Comment">// ~&lt; Result: 4 &gt;~</span>
<span id="L192" class="LineNr">192 </span>
<span id="L193" class="LineNr">193 </span><span class="Comment">// But if it's not a function (an input is mapped to more than one output)</span>
<span id="L194" class="LineNr">194 </span><span class="Comment">// then it's om (which is like javascript's null).</span>
<span id="L195" class="LineNr">195 </span>g <span class="Statement">:=</span> { [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">1</span>,<span class="Constant">3</span>] };
<span id="L196" class="LineNr">196 </span>g[<span class="Constant">1</span>];
<span id="L197" class="LineNr">197 </span><span class="Comment">// ~&lt; Result: om &gt;~</span>
<span id="L198" class="LineNr">198 </span>
<span id="L199" class="LineNr">199 </span><span class="Identifier">domain</span>(f);
<span id="L200" class="LineNr">200 </span><span class="Comment">// ~&lt; Result: {1, 2, 3} &gt;~</span>
<span id="L201" class="LineNr">201 </span>
<span id="L202" class="LineNr">202 </span><span class="Identifier">range</span>(f);
<span id="L203" class="LineNr">203 </span><span class="Comment">// ~&lt; Result: {2, 4, 6} &gt;~</span>
<span id="L204" class="LineNr">204 </span>
<span id="L205" class="LineNr">205 </span><span class="Identifier">isMap</span>({ [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">2</span>,<span class="Constant">4</span>] });
<span id="L206" class="LineNr">206 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L207" class="LineNr">207 </span><span class="Identifier">isMap</span>({ [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">1</span>,<span class="Constant">4</span>] });
<span id="L208" class="LineNr">208 </span><span class="Comment">// ~&lt; Result: false &gt;~</span>
<span id="L209" class="LineNr">209 </span>
<span id="L210" class="LineNr">210 </span>
<span id="L211" class="LineNr">211 </span><span class="Comment Heading">// Control Structures</span>
<span id="L212" class="LineNr">212 </span><span class="Comment Heading">// ==================</span>
<span id="L213" class="LineNr">213 </span><span class="Statement">switch</span> {
<span id="L214" class="LineNr">214 </span>  <span class="Statement">case</span> <span class="Constant">false</span> <span class="Type">:</span>
<span id="L215" class="LineNr">215 </span>    <span class="Identifier">print</span>(<span class="Constant">'hi'</span>);
<span id="L216" class="LineNr">216 </span>  <span class="Statement">case</span> <span class="Constant">false</span> <span class="Type">:</span>
<span id="L217" class="LineNr">217 </span>    <span class="Identifier">print</span>(<span class="Constant">'hey'</span>);
<span id="L218" class="LineNr">218 </span>  <span class="Statement">default</span> <span class="Type">:</span>
<span id="L219" class="LineNr">219 </span>    <span class="Identifier">print</span>(<span class="Constant">'bye'</span>);
<span id="L220" class="LineNr">220 </span>}
<span id="L221" class="LineNr">221 </span><span class="Comment">// bye</span>
<span id="L222" class="LineNr">222 </span>
<span id="L223" class="LineNr">223 </span>
<span id="L224" class="LineNr">224 </span><span class="Comment">// Procedures</span>
<span id="L225" class="LineNr">225 </span><span class="Identifier">sum</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(x, y) {
<span id="L226" class="LineNr">226 </span>  <span class="Statement">return</span> x <span class="Type">+</span> y;
<span id="L227" class="LineNr">227 </span>};
<span id="L228" class="LineNr">228 </span><span class="Identifier">sum</span>(<span class="Constant">3</span>, <span class="Constant">4</span>);
<span id="L229" class="LineNr">229 </span><span class="Comment">// ~&lt; Result: 7 &gt;~</span>
<span id="L230" class="LineNr">230 </span>
<span id="L231" class="LineNr">231 </span><span class="Comment">// It can also be cached to avoid recomputing when given the same inputs</span>
<span id="L232" class="LineNr">232 </span><span class="Identifier">sum</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(x, y) {
<span id="L233" class="LineNr">233 </span>  <span class="Statement">return</span> x <span class="Type">+</span> y;
<span id="L234" class="LineNr">234 </span>};
<span id="L235" class="LineNr">235 </span><span class="Identifier">sum</span>(<span class="Constant">3</span>, <span class="Constant">4</span>);
<span id="L236" class="LineNr">236 </span><span class="Comment">// ~&lt; Result: 7 &gt;~</span>
<span id="L237" class="LineNr">237 </span>
<span id="L238" class="LineNr">238 </span>
<span id="L239" class="LineNr">239 </span><span class="Comment">// Object-oriented Programming</span>
<span id="L240" class="LineNr">240 </span><span class="Type">class</span> <span class="Identifier">point</span>(x, y) {
<span id="L241" class="LineNr">241 </span>  x <span class="Statement">:=</span> x;
<span id="L242" class="LineNr">242 </span>  y <span class="Statement">:=</span> y;
<span id="L243" class="LineNr">243 </span>
<span id="L244" class="LineNr">244 </span>  <span class="Comment">// Instance procedure</span>
<span id="L245" class="LineNr">245 </span>  <span class="Identifier">dist_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(pt) {
<span id="L246" class="LineNr">246 </span>    <span class="Statement">return</span> <span class="Identifier">sqrt</span>( (pt.x <span class="Type">-</span> x) <span class="Type">**</span> <span class="Constant">2</span> <span class="Type">+</span> (pt.y <span class="Type">-</span> <a class="Identifier code-proc-link" href="#undefined-250">get_y</a>()) <span class="Type">**</span> <span class="Constant">2</span> );
<span id="L247" class="LineNr">247 </span>  };
<span id="L248" class="LineNr">248 </span>
<span id="L249" class="LineNr">249 </span>  <span class="Comment">// Not really necessary but just demonstrating calling another instance proc  </span>
<span id="L250" class="LineNr">250 </span>  <span class="Identifier">get_y</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L251" class="LineNr">251 </span>    <span class="Comment">// Also just demonstrating 'this' keyword, usually unneeded and implicit </span>
<span id="L252" class="LineNr">252 </span>    <span class="Statement">return</span> this.y;
<span id="L253" class="LineNr">253 </span>  };
<span id="L254" class="LineNr">254 </span>
<span id="L255" class="LineNr">255 </span>  <span class="Comment">// Class procedures</span>
<span id="L256" class="LineNr">256 </span>  <span class="Statement">static</span> {
<span id="L257" class="LineNr">257 </span>    <span class="Identifier">orig</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L258" class="LineNr">258 </span>      <span class="Statement">return</span> <span class="Identifier">point</span>(<span class="Constant">0</span>, <span class="Constant">0</span>);
<span id="L259" class="LineNr">259 </span>    };
<span id="L260" class="LineNr">260 </span>  }
<span id="L261" class="LineNr">261 </span>}
<span id="L262" class="LineNr">262 </span>pt <span class="Statement">:=</span> <span class="Identifier">point</span>(<span class="Constant">1</span>, <span class="Constant">1</span>);
<span id="L263" class="LineNr">263 </span>pt2 <span class="Statement">:=</span> <span class="Identifier">point</span>(<span class="Constant">4</span>, <span class="Constant">5</span>);
<span id="L264" class="LineNr">264 </span>pt.<span class="Identifier">dist_to</span>(pt2);
<span id="L265" class="LineNr">265 </span><span class="Comment">// ~&lt; Result: 5.0 &gt;~</span>
<span id="L266" class="LineNr">266 </span>pt3 <span class="Statement">:=</span> <span class="Identifier">point</span>(<span class="Constant">3</span>, <span class="Constant">4</span>);
<span id="L267" class="LineNr">267 </span>pt3.<span class="Identifier">dist_to</span>(point.<a class="Identifier code-proc-link" href="#undefined-257">orig</a>());
<span id="L268" class="LineNr">268 </span><span class="Comment">// ~&lt; Result: 5.0 &gt;~</span>
<span id="L269" class="LineNr">269 </span>
<span id="L270" class="LineNr">270 </span>
<span id="L271" class="LineNr">271 </span><span class="Comment Heading">/* SetlX Functors</span>
<span id="L272" class="LineNr">272 </span><span class="Comment Heading">   ==============</span>
<span id="L273" class="LineNr">273 </span><span class="Comment">   SetlX allows for the creation of data structures composed from what they call</span>
<span id="L274" class="LineNr">274 </span><span class="Comment">   functors and arguments. Functor names always start with a capital letter and </span>
<span id="L275" class="LineNr">275 </span><span class="Comment">   then are followed by parentheses enclosing its arguments, which can be of</span>
<span id="L276" class="LineNr">276 </span><span class="Comment">   more or less any type. And that's basically all they are, like strings that</span>
<span id="L277" class="LineNr">277 </span><span class="Comment">   can take arguments to enable tree-like structures.</span>
<span id="L278" class="LineNr">278 </span><span class="Comment">  </span>
<span id="L279" class="LineNr">279 </span><span class="Comment">   Here we demonstrate its usage to represent logical expressions where </span>
<span id="L280" class="LineNr">280 </span><span class="Comment">   arguments are either strings or other functor terms. (If you're familiar </span>
<span id="L281" class="LineNr">281 </span><span class="Comment">   with functors from category theory, the usage of that term here doesn't </span>
<span id="L282" class="LineNr">282 </span><span class="Comment">   really have anything to do with that notion.)</span>
<span id="L283" class="LineNr">283 </span><span class="Comment">*/</span>
<span id="L284" class="LineNr">284 </span><span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>);
<span id="L285" class="LineNr">285 </span><span class="Comment">// ~&lt; Result: And("A", "B") &gt;~</span>
<span id="L286" class="LineNr">286 </span>
<span id="L287" class="LineNr">287 </span><span class="Identifier">Implies</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'C'</span>);
<span id="L288" class="LineNr">288 </span><span class="Comment">// ~&lt; Result: Implies(And("A", "B"), "C") &gt;~</span>
<span id="L289" class="LineNr">289 </span>
<span id="L290" class="LineNr">290 </span><span class="Identifier">fct</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>));
<span id="L291" class="LineNr">291 </span><span class="Comment">// ~&lt; Result: "And" &gt;~</span>
<span id="L292" class="LineNr">292 </span>
<span id="L293" class="LineNr">293 </span><span class="Identifier">args</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>));
<span id="L294" class="LineNr">294 </span><span class="Comment">// ~&lt; Result: ["A", "B"] &gt;~</span>
<span id="L295" class="LineNr">295 </span>
<span id="L296" class="LineNr">296 </span><span class="Identifier">makeTerm</span>(<span class="Constant">'And'</span>, [<span class="Constant">'A'</span>, <span class="Constant">'B'</span>]);
<span id="L297" class="LineNr">297 </span><span class="Comment">// ~&lt; Result: And("A", "B") &gt;~</span>
<span id="L298" class="LineNr">298 </span>
<span id="L299" class="LineNr">299 </span>
<span id="L300" class="LineNr">300 </span><span class="Comment">// Meta-programming</span>
<span id="L301" class="LineNr">301 </span><span class="Identifier">eval</span>(<span class="Constant">"{1} + {2, 3}"</span>);
<span id="L302" class="LineNr">302 </span><span class="Comment">// ~&lt; Result: {1, 2, 3} &gt;~</span>
</div>
<div id="quick_ref">
<span id="L1" class="LineNr">  1 </span><span class="Comment">/* SetlX 2.2.0 Quick Reference</span>
<span id="L2" class="LineNr">  2 </span><span class="Comment">   This list of examples introduces much of the setlX language.</span>
<span id="L3" class="LineNr">  3 </span>
<span id="L4" class="LineNr">  4 </span><span class="Comment">   Nearly all of MetaEthical.AI is just a combination of the basic components</span>
<span id="L5" class="LineNr">  5 </span><span class="Comment">   demonstrated here. There is also a slightly more compact <a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank"></a><a class="cheat_sheet" target="_blank">cheat_sheet.stlx</a></span>
<span id="L6" class="LineNr">  6 </span><span class="Comment">   that focuses on just the aspects that are more unique to setlX and omits</span>
<span id="L7" class="LineNr">  7 </span><span class="Comment">   many commands that are more obvious or self-explanatory, especially among</span>
<span id="L8" class="LineNr">  8 </span><span class="Comment">   programmers.</span>
<span id="L9" class="LineNr">  9 </span>
<span id="L10" class="LineNr"> 10 </span><span class="Comment">   A much more thorough guide can be found in the official setlX <a href="/images/setlX_v2-2-0_tutorial.pdf" target="_blank">tutorial.pdf</a>.</span>
<span id="L11" class="LineNr"> 11 </span><span class="Comment">*/</span>
<span id="L12" class="LineNr"> 12 </span>
<span id="L13" class="LineNr"> 13 </span>
<span id="L14" class="LineNr"> 14 </span><span class="Comment">// This is a comment.</span>
<span id="L15" class="LineNr"> 15 </span><span class="Comment">/* This is a </span>
<span id="L16" class="LineNr"> 16 </span><span class="Comment">   multi-line comment  */</span>
<span id="L17" class="LineNr"> 17 </span>
<span id="L18" class="LineNr"> 18 </span>
<span id="L19" class="LineNr"> 19 </span><span class="Comment">// Standard Arithmetic Operations </span>
<span id="L20" class="LineNr"> 20 </span>x <span class="Statement">:=</span> (<span class="Constant">1</span> <span class="Type">+</span> <span class="Constant">2</span>) <span class="Type">*</span> <span class="Constant">3</span> <span class="Type">/</span> <span class="Constant">4</span>;
<span id="L21" class="LineNr"> 21 </span><span class="Comment">// ~&lt; Result: 9/4 &gt;~</span>
<span id="L22" class="LineNr"> 22 </span><span class="Comment">/* Note that lines always end with a semi-colon. </span>
<span id="L23" class="LineNr"> 23 </span><span class="Comment">   Assignment of a value to a variable is done with ":=", not "=".</span>
<span id="L24" class="LineNr"> 24 </span><span class="Comment">   Variable names start with a lowercase letter because capitalized names are</span>
<span id="L25" class="LineNr"> 25 </span><span class="Comment">     reserved for setlx functors.  */</span>
<span id="L26" class="LineNr"> 26 </span>
<span id="L27" class="LineNr"> 27 </span><span class="Comment">// Exponents</span>
<span id="L28" class="LineNr"> 28 </span><span class="Constant">2</span> <span class="Type">**</span> <span class="Constant">5</span>;
<span id="L29" class="LineNr"> 29 </span><span class="Comment">// ~&lt; Result: 32 &gt;~</span>
<span id="L30" class="LineNr"> 30 </span>
<span id="L31" class="LineNr"> 31 </span><span class="Identifier">sqrt</span>(<span class="Constant">81</span>);
<span id="L32" class="LineNr"> 32 </span><span class="Comment">// ~&lt; Result: 9.0 &gt;~</span>
<span id="L33" class="LineNr"> 33 </span>
<span id="L34" class="LineNr"> 34 </span><span class="Comment">// Absolute value</span>
<span id="L35" class="LineNr"> 35 </span><span class="Identifier">abs</span>(<span class="Type">-</span><span class="Constant">7</span>);
<span id="L36" class="LineNr"> 36 </span><span class="Comment">// ~&lt; Result: 7 &gt;~</span>
<span id="L37" class="LineNr"> 37 </span>
<span id="L38" class="LineNr"> 38 </span>
<span id="L39" class="LineNr"> 39 </span><span class="Comment Heading">// Strings </span>
<span id="L40" class="LineNr"> 40 </span><span class="Comment Heading">// =======</span>
<span id="L41" class="LineNr"> 41 </span>str1 <span class="Statement">:=</span> <span class="Constant">"abc"</span>;
<span id="L42" class="LineNr"> 42 </span>str2 <span class="Statement">:=</span> <span class="Constant">'def'</span>; <span class="Comment">// single quotes work too</span>
<span id="L43" class="LineNr"> 43 </span>
<span id="L44" class="LineNr"> 44 </span><span class="Comment">// String concatenation</span>
<span id="L45" class="LineNr"> 45 </span>str3 <span class="Statement">:=</span> str1 <span class="Type">+</span> str2;
<span id="L46" class="LineNr"> 46 </span><span class="Comment">// ~&lt; Result: "abcdef" &gt;~</span>
<span id="L47" class="LineNr"> 47 </span>
<span id="L48" class="LineNr"> 48 </span><span class="Comment">// Length</span>
<span id="L49" class="LineNr"> 49 </span><span class="Type">#</span>str3;
<span id="L50" class="LineNr"> 50 </span><span class="Comment">// ~&lt; Result: 6 &gt;~</span>
<span id="L51" class="LineNr"> 51 </span>
<span id="L52" class="LineNr"> 52 </span>
<span id="L53" class="LineNr"> 53 </span><span class="Comment Heading">// Boolean values</span>
<span id="L54" class="LineNr"> 54 </span><span class="Comment Heading">// ==============</span>
<span id="L55" class="LineNr"> 55 </span>p <span class="Statement">:=</span> <span class="Constant">true</span>;
<span id="L56" class="LineNr"> 56 </span>q <span class="Statement">:=</span> <span class="Constant">false</span>;
<span id="L57" class="LineNr"> 57 </span>
<span id="L58" class="LineNr"> 58 </span><span class="Comment">// Disjunction</span>
<span id="L59" class="LineNr"> 59 </span>p <span class="Type">||</span> q;
<span id="L60" class="LineNr"> 60 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L61" class="LineNr"> 61 </span>
<span id="L62" class="LineNr"> 62 </span><span class="Comment">// Conjunction</span>
<span id="L63" class="LineNr"> 63 </span>p <span class="Type">&amp;&amp;</span> q;
<span id="L64" class="LineNr"> 64 </span><span class="Comment">// ~&lt; Result: false &gt;~</span>
<span id="L65" class="LineNr"> 65 </span>
<span id="L66" class="LineNr"> 66 </span><span class="Comment">// Equality / Biconditional</span>
<span id="L67" class="LineNr"> 67 </span>p <span class="Type">==</span> q;
<span id="L68" class="LineNr"> 68 </span><span class="Comment">// ~&lt; Result: false &gt;~</span>
<span id="L69" class="LineNr"> 69 </span>
<span id="L70" class="LineNr"> 70 </span>p <span class="Type">!=</span> q;
<span id="L71" class="LineNr"> 71 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L72" class="LineNr"> 72 </span>
<span id="L73" class="LineNr"> 73 </span><span class="Comment">// Negation</span>
<span id="L74" class="LineNr"> 74 </span><span class="Type">!</span>p;
<span id="L75" class="LineNr"> 75 </span><span class="Comment">// ~&lt; Result: false &gt;~</span>
<span id="L76" class="LineNr"> 76 </span>
<span id="L77" class="LineNr"> 77 </span>
<span id="L78" class="LineNr"> 78 </span><span class="Comment Heading">// Sets</span>
<span id="L79" class="LineNr"> 79 </span><span class="Comment Heading">// ====</span>
<span id="L80" class="LineNr"> 80 </span>a <span class="Statement">:=</span> { <span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span> };
<span id="L81" class="LineNr"> 81 </span>b <span class="Statement">:=</span> { <span class="Constant">3</span>, <span class="Constant">4</span>, <span class="Constant">5</span> };
<span id="L82" class="LineNr"> 82 </span>
<span id="L83" class="LineNr"> 83 </span><span class="Comment">// Cardinality</span>
<span id="L84" class="LineNr"> 84 </span><span class="Type">#</span>b;
<span id="L85" class="LineNr"> 85 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L86" class="LineNr"> 86 </span>
<span id="L87" class="LineNr"> 87 </span><span class="Comment">// Union</span>
<span id="L88" class="LineNr"> 88 </span>a <span class="Type">+</span> b;
<span id="L89" class="LineNr"> 89 </span><span class="Comment">// ~&lt; Result: {1, 2, 3, 4, 5} &gt;~</span>
<span id="L90" class="LineNr"> 90 </span>
<span id="L91" class="LineNr"> 91 </span><span class="Comment">// Intersection</span>
<span id="L92" class="LineNr"> 92 </span>a <span class="Type">*</span> b;
<span id="L93" class="LineNr"> 93 </span><span class="Comment">// ~&lt; Result: {3} &gt;~</span>
<span id="L94" class="LineNr"> 94 </span>
<span id="L95" class="LineNr"> 95 </span><span class="Comment">// Difference</span>
<span id="L96" class="LineNr"> 96 </span>a <span class="Type">-</span> b;
<span id="L97" class="LineNr"> 97 </span><span class="Comment">// ~&lt; Result: {1, 2} &gt;~</span>
<span id="L98" class="LineNr"> 98 </span>
<span id="L99" class="LineNr"> 99 </span><span class="Comment">// Check Membership</span>
<span id="L100" class="LineNr">100 </span><span class="Constant">1</span> <span class="Type">in</span> a;
<span id="L101" class="LineNr">101 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L102" class="LineNr">102 </span>
<span id="L103" class="LineNr">103 </span><span class="Comment">// Check if Subset</span>
<span id="L104" class="LineNr">104 </span>{<span class="Constant">1</span>, <span class="Constant">2</span>} <span class="Type">&lt;</span> {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>};
<span id="L105" class="LineNr">105 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L106" class="LineNr">106 </span>{<span class="Constant">3</span>} <span class="Type">&lt;</span> {<span class="Constant">1</span>, <span class="Constant">2</span>};
<span id="L107" class="LineNr">107 </span><span class="Comment">// ~&lt; Result: false &gt;~</span>
<span id="L108" class="LineNr">108 </span>
<span id="L109" class="LineNr">109 </span><span class="Comment">// Powerset</span>
<span id="L110" class="LineNr">110 </span><span class="Identifier">pow</span>({ <span class="Constant">1</span>, <span class="Constant">2</span> });
<span id="L111" class="LineNr">111 </span><span class="Comment">// ~&lt; Result: {{}, {1}, {1, 2}, {2}} &gt;~</span>
<span id="L112" class="LineNr">112 </span><span class="Constant">2</span> <span class="Type">**</span> { <span class="Constant">1</span>, <span class="Constant">2</span> }; <span class="Comment">// alternate syntax</span>
<span id="L113" class="LineNr">113 </span><span class="Comment">// ~&lt; Result: {{}, {1}, {1, 2}, {2}} &gt;~</span>
<span id="L114" class="LineNr">114 </span>
<span id="L115" class="LineNr">115 </span><span class="Comment">// Cartesian Product</span>
<span id="L116" class="LineNr">116 </span>pairs <span class="Statement">:=</span> { <span class="Constant">'a'</span>, <span class="Constant">'b'</span> } <span class="Type">&gt;&lt;</span> { <span class="Constant">1</span>, <span class="Constant">2</span> };
<span id="L117" class="LineNr">117 </span><span class="Comment">// ~&lt; Result: {["a", 1], ["a", 2], ["b", 1], ["b", 2]} &gt;~</span>
<span id="L118" class="LineNr">118 </span>
<span id="L119" class="LineNr">119 </span><span class="Comment">// Set comprehension</span>
<span id="L120" class="LineNr">120 </span>{ x <span class="Type">*</span> <span class="Constant">2</span> <span class="Type">:</span> x <span class="Type">in</span> a };
<span id="L121" class="LineNr">121 </span><span class="Comment">// ~&lt; Result: {2, 4, 6} &gt;~</span>
<span id="L122" class="LineNr">122 </span>
<span id="L123" class="LineNr">123 </span><span class="Comment">// Set comprehension with filter</span>
<span id="L124" class="LineNr">124 </span>{ x <span class="Type">:</span> x <span class="Type">in</span> a <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">3</span> };
<span id="L125" class="LineNr">125 </span><span class="Comment">// ~&lt; Result: {1, 2} &gt;~</span>
<span id="L126" class="LineNr">126 </span>
<span id="L127" class="LineNr">127 </span><span class="Comment">// Set comprehension with list pattern matching</span>
<span id="L128" class="LineNr">128 </span><span class="Comment">// Also, since we don't use the first element of the ordered pair, we can </span>
<span id="L129" class="LineNr">129 </span><span class="Comment">// discard it with _ instead of giving it a variable name.</span>
<span id="L130" class="LineNr">130 </span>{ y <span class="Type">:</span> [_, y] <span class="Type">in</span> pairs };
<span id="L131" class="LineNr">131 </span><span class="Comment">// ~&lt; Result: {1, 2} &gt;~</span>
<span id="L132" class="LineNr">132 </span>
<span id="L133" class="LineNr">133 </span><span class="Comment">// Quantification</span>
<span id="L134" class="LineNr">134 </span><span class="Type">exists</span>(x <span class="Type">in</span> a <span class="Type">|</span> x <span class="Type">==</span> <span class="Constant">2</span>);
<span id="L135" class="LineNr">135 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L136" class="LineNr">136 </span><span class="Type">forall</span>(x <span class="Type">in</span> a <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">5</span>);
<span id="L137" class="LineNr">137 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L138" class="LineNr">138 </span>
<span id="L139" class="LineNr">139 </span><span class="Comment">// Returns the first element according to the language's internal order.</span>
<span id="L140" class="LineNr">140 </span><span class="Comment">// If the set is not all numbers or lists of them, the ordering should not be </span>
<span id="L141" class="LineNr">141 </span><span class="Comment">// relied upon.</span>
<span id="L142" class="LineNr">142 </span><span class="Identifier">first</span>(a);
<span id="L143" class="LineNr">143 </span><span class="Comment">// ~&lt; Result: 1 &gt;~</span>
<span id="L144" class="LineNr">144 </span>
<span id="L145" class="LineNr">145 </span><span class="Comment">// Sum of a Set of...</span>
<span id="L146" class="LineNr">146 </span><span class="Comment">//   Integers </span>
<span id="L147" class="LineNr">147 </span><span class="Type">+/</span> {<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>};
<span id="L148" class="LineNr">148 </span><span class="Comment">// ~&lt; Result: 6 &gt;~</span>
<span id="L149" class="LineNr">149 </span>
<span id="L150" class="LineNr">150 </span><span class="Comment">//   Strings</span>
<span id="L151" class="LineNr">151 </span><span class="Type">+/</span> {<span class="Constant">'a'</span>, <span class="Constant">'b'</span>, <span class="Constant">'c'</span>};
<span id="L152" class="LineNr">152 </span><span class="Comment">// ~&lt; Result: "abc" &gt;~</span>
<span id="L153" class="LineNr">153 </span>
<span id="L154" class="LineNr">154 </span><span class="Comment">//   Sets</span>
<span id="L155" class="LineNr">155 </span><span class="Type">+/</span> { {<span class="Constant">1</span>, <span class="Constant">2</span>}, {<span class="Constant">3</span>, <span class="Constant">4</span>} };
<span id="L156" class="LineNr">156 </span><span class="Comment">// ~&lt; Result: {1, 2, 3, 4} &gt;~</span>
<span id="L157" class="LineNr">157 </span>
<span id="L158" class="LineNr">158 </span><span class="Comment">//   Lists</span>
<span id="L159" class="LineNr">159 </span><span class="Type">+/</span> { [<span class="Constant">1</span>, <span class="Constant">2</span>], [<span class="Constant">3</span>, <span class="Constant">4</span>] };
<span id="L160" class="LineNr">160 </span><span class="Comment">// ~&lt; Result: [1, 2, 3, 4] &gt;~</span>
<span id="L161" class="LineNr">161 </span>
<span id="L162" class="LineNr">162 </span>
<span id="L163" class="LineNr">163 </span><span class="Comment Heading">// Lists</span>
<span id="L164" class="LineNr">164 </span><span class="Comment Heading">// =====</span>
<span id="L165" class="LineNr">165 </span>l <span class="Statement">:=</span> [ <span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span> ];
<span id="L166" class="LineNr">166 </span>m <span class="Statement">:=</span> [ <span class="Constant">3</span>, <span class="Constant">4</span>, <span class="Constant">5</span> ];
<span id="L167" class="LineNr">167 </span>
<span id="L168" class="LineNr">168 </span><span class="Comment">// Note that list indexes start at 1! </span>
<span id="L169" class="LineNr">169 </span><span class="Comment">// Not 0 as with most other programming languages.</span>
<span id="L170" class="LineNr">170 </span>m[<span class="Constant">1</span>];
<span id="L171" class="LineNr">171 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L172" class="LineNr">172 </span>
<span id="L173" class="LineNr">173 </span><span class="Comment">// Concatenation</span>
<span id="L174" class="LineNr">174 </span>l <span class="Type">+</span> m;
<span id="L175" class="LineNr">175 </span><span class="Comment">// ~&lt; Result: [ 1, 2, 3, 3, 4, 5] &gt;~</span>
<span id="L176" class="LineNr">176 </span><span class="Comment">// Note that unlike with sets, the 3 is duplicated</span>
<span id="L177" class="LineNr">177 </span>
<span id="L178" class="LineNr">178 </span><span class="Comment">// List comprehension</span>
<span id="L179" class="LineNr">179 </span>[ x <span class="Type">*</span> <span class="Constant">2</span> <span class="Type">:</span> x <span class="Type">in</span> l ];
<span id="L180" class="LineNr">180 </span><span class="Comment">// ~&lt; Result: [2, 4, 6] &gt;~</span>
<span id="L181" class="LineNr">181 </span>
<span id="L182" class="LineNr">182 </span><span class="Comment">// List comprehension with filter</span>
<span id="L183" class="LineNr">183 </span>[ x <span class="Type">:</span> x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">3</span> ];
<span id="L184" class="LineNr">184 </span><span class="Comment">// ~&lt; Result: [1, 2] &gt;~</span>
<span id="L185" class="LineNr">185 </span>
<span id="L186" class="LineNr">186 </span><span class="Comment">// Check Inclusion</span>
<span id="L187" class="LineNr">187 </span><span class="Constant">1</span> <span class="Type">in</span> l;
<span id="L188" class="LineNr">188 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L189" class="LineNr">189 </span>
<span id="L190" class="LineNr">190 </span><span class="Comment">// Quantification</span>
<span id="L191" class="LineNr">191 </span><span class="Type">exists</span>(x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">==</span> <span class="Constant">2</span>);
<span id="L192" class="LineNr">192 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L193" class="LineNr">193 </span><span class="Type">forall</span>(x <span class="Type">in</span> l <span class="Type">|</span> x <span class="Type">&lt;</span> <span class="Constant">5</span>);
<span id="L194" class="LineNr">194 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L195" class="LineNr">195 </span>
<span id="L196" class="LineNr">196 </span><span class="Comment">// Range</span>
<span id="L197" class="LineNr">197 </span>m[<span class="Constant">1</span><span class="Statement">..</span><span class="Constant">2</span>];
<span id="L198" class="LineNr">198 </span><span class="Comment">// ~&lt; Result: [3, 4] &gt;~</span>
<span id="L199" class="LineNr">199 </span>
<span id="L200" class="LineNr">200 </span>m[<span class="Statement">..</span><span class="Constant">2</span>];
<span id="L201" class="LineNr">201 </span><span class="Comment">// ~&lt; Result: [3, 4] &gt;~</span>
<span id="L202" class="LineNr">202 </span>
<span id="L203" class="LineNr">203 </span>m[<span class="Constant">2</span><span class="Statement">..</span>];
<span id="L204" class="LineNr">204 </span><span class="Comment">// ~&lt; Result: [4, 5] &gt;~</span>
<span id="L205" class="LineNr">205 </span>
<span id="L206" class="LineNr">206 </span><span class="Identifier">first</span>([<span class="Constant">3</span>,<span class="Constant">2</span>,<span class="Constant">1</span>]);
<span id="L207" class="LineNr">207 </span><span class="Comment">// ~&lt; Result: 3 &gt;~</span>
<span id="L208" class="LineNr">208 </span>
<span id="L209" class="LineNr">209 </span><span class="Identifier">last</span>([<span class="Constant">3</span>,<span class="Constant">2</span>,<span class="Constant">1</span>]);
<span id="L210" class="LineNr">210 </span><span class="Comment">// ~&lt; Result: 1 &gt;~</span>
<span id="L211" class="LineNr">211 </span>
<span id="L212" class="LineNr">212 </span><span class="Identifier">permutations</span>([<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>]);
<span id="L213" class="LineNr">213 </span><span class="Comment">// ~&lt; Result: {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]} &gt;~</span>
<span id="L214" class="LineNr">214 </span>
<span id="L215" class="LineNr">215 </span><span class="Comment">// Sum of a List of:</span>
<span id="L216" class="LineNr">216 </span><span class="Comment">//   Integers </span>
<span id="L217" class="LineNr">217 </span><span class="Type">+/</span> [<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>];
<span id="L218" class="LineNr">218 </span><span class="Comment">// ~&lt; Result: 6 &gt;~</span>
<span id="L219" class="LineNr">219 </span>
<span id="L220" class="LineNr">220 </span><span class="Comment">//   Strings</span>
<span id="L221" class="LineNr">221 </span><span class="Type">+/</span> [<span class="Constant">'a'</span>, <span class="Constant">'b'</span>, <span class="Constant">'c'</span>];
<span id="L222" class="LineNr">222 </span><span class="Comment">// ~&lt; Result: "abc" &gt;~</span>
<span id="L223" class="LineNr">223 </span>
<span id="L224" class="LineNr">224 </span><span class="Comment">//   Sets</span>
<span id="L225" class="LineNr">225 </span><span class="Type">+/</span> [ {<span class="Constant">1</span>, <span class="Constant">2</span>}, {<span class="Constant">3</span>, <span class="Constant">4</span>} ];
<span id="L226" class="LineNr">226 </span><span class="Comment">// ~&lt; Result: {1, 2, 3, 4} &gt;~</span>
<span id="L227" class="LineNr">227 </span>
<span id="L228" class="LineNr">228 </span><span class="Comment">//   Lists</span>
<span id="L229" class="LineNr">229 </span><span class="Type">+/</span> [ [<span class="Constant">1</span>, <span class="Constant">2</span>], [<span class="Constant">3</span>, <span class="Constant">4</span>] ];
<span id="L230" class="LineNr">230 </span><span class="Comment">// ~&lt; Result: [1, 2, 3, 4] &gt;~</span>
<span id="L231" class="LineNr">231 </span>
<span id="L232" class="LineNr">232 </span>
<span id="L233" class="LineNr">233 </span><span class="Comment Heading">// Functions</span>
<span id="L234" class="LineNr">234 </span><span class="Comment Heading">// =========</span>
<span id="L235" class="LineNr">235 </span><span class="Comment">// They are just sets of ordered pairs where each element of the domain is </span>
<span id="L236" class="LineNr">236 </span><span class="Comment">// mapped to one element of the range.</span>
<span id="L237" class="LineNr">237 </span>f <span class="Statement">:=</span> { [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">2</span>,<span class="Constant">4</span>], [<span class="Constant">3</span>,<span class="Constant">6</span>] };
<span id="L238" class="LineNr">238 </span>
<span id="L239" class="LineNr">239 </span><span class="Comment">// You can find the value given an input</span>
<span id="L240" class="LineNr">240 </span>f[<span class="Constant">2</span>];
<span id="L241" class="LineNr">241 </span><span class="Comment">// ~&lt; Result: 4 &gt;~</span>
<span id="L242" class="LineNr">242 </span>
<span id="L243" class="LineNr">243 </span><span class="Comment">// But if it's not a function (an input is mapped to more than one output)</span>
<span id="L244" class="LineNr">244 </span><span class="Comment">// then it's om (which is like javascript's null).</span>
<span id="L245" class="LineNr">245 </span>g <span class="Statement">:=</span> { [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">1</span>,<span class="Constant">3</span>] };
<span id="L246" class="LineNr">246 </span>g[<span class="Constant">1</span>];
<span id="L247" class="LineNr">247 </span><span class="Comment">// ~&lt; Result: om &gt;~</span>
<span id="L248" class="LineNr">248 </span>
<span id="L249" class="LineNr">249 </span><span class="Identifier">domain</span>(f);
<span id="L250" class="LineNr">250 </span><span class="Comment">// ~&lt; Result: {1, 2, 3} &gt;~</span>
<span id="L251" class="LineNr">251 </span>
<span id="L252" class="LineNr">252 </span><span class="Identifier">range</span>(f);
<span id="L253" class="LineNr">253 </span><span class="Comment">// ~&lt; Result: {2, 4, 6} &gt;~</span>
<span id="L254" class="LineNr">254 </span>
<span id="L255" class="LineNr">255 </span>
<span id="L256" class="LineNr">256 </span><span class="Comment Heading">// Control Structures</span>
<span id="L257" class="LineNr">257 </span><span class="Comment Heading">// ==================</span>
<span id="L258" class="LineNr">258 </span><span class="Statement">if</span> (<span class="Constant">true</span>) {
<span id="L259" class="LineNr">259 </span>  <span class="Identifier">print</span>(<span class="Constant">'hi'</span>);
<span id="L260" class="LineNr">260 </span>}
<span id="L261" class="LineNr">261 </span><span class="Comment">// hi</span>
<span id="L262" class="LineNr">262 </span>
<span id="L263" class="LineNr">263 </span><span class="Statement">if</span> (<span class="Constant">false</span>) {
<span id="L264" class="LineNr">264 </span>  <span class="Identifier">print</span>(<span class="Constant">'hi'</span>);
<span id="L265" class="LineNr">265 </span>} <span class="Statement">else</span> {
<span id="L266" class="LineNr">266 </span>  <span class="Identifier">print</span>(<span class="Constant">'bye'</span>);
<span id="L267" class="LineNr">267 </span>}
<span id="L268" class="LineNr">268 </span><span class="Comment">// bye</span>
<span id="L269" class="LineNr">269 </span>
<span id="L270" class="LineNr">270 </span><span class="Statement">if</span> (<span class="Constant">false</span>) {
<span id="L271" class="LineNr">271 </span>  <span class="Identifier">print</span>(<span class="Constant">'hi'</span>);
<span id="L272" class="LineNr">272 </span>} <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Constant">true</span>) {
<span id="L273" class="LineNr">273 </span>  <span class="Identifier">print</span>(<span class="Constant">'hey'</span>);
<span id="L274" class="LineNr">274 </span>} <span class="Statement">else</span> {
<span id="L275" class="LineNr">275 </span>  <span class="Identifier">print</span>(<span class="Constant">'bye'</span>);
<span id="L276" class="LineNr">276 </span>}
<span id="L277" class="LineNr">277 </span><span class="Comment">// hey</span>
<span id="L278" class="LineNr">278 </span>
<span id="L279" class="LineNr">279 </span><span class="Statement">switch</span> {
<span id="L280" class="LineNr">280 </span>  <span class="Statement">case</span> <span class="Constant">false</span> <span class="Type">:</span>
<span id="L281" class="LineNr">281 </span>    <span class="Identifier">print</span>(<span class="Constant">'hi'</span>);
<span id="L282" class="LineNr">282 </span>  <span class="Statement">case</span> <span class="Constant">false</span> <span class="Type">:</span>
<span id="L283" class="LineNr">283 </span>    <span class="Identifier">print</span>(<span class="Constant">'hey'</span>);
<span id="L284" class="LineNr">284 </span>  <span class="Statement">default</span> <span class="Type">:</span>
<span id="L285" class="LineNr">285 </span>    <span class="Identifier">print</span>(<span class="Constant">'bye'</span>);
<span id="L286" class="LineNr">286 </span>}
<span id="L287" class="LineNr">287 </span><span class="Comment">// bye</span>
<span id="L288" class="LineNr">288 </span>
<span id="L289" class="LineNr">289 </span>s <span class="Statement">:=</span> {};
<span id="L290" class="LineNr">290 </span><span class="Statement">for</span> (i <span class="Type">in</span> [<span class="Constant">1</span>, <span class="Constant">2</span>, <span class="Constant">3</span>]) {
<span id="L291" class="LineNr">291 </span>  s <span class="Statement">+=</span> { i<span class="Type">*</span><span class="Constant">2</span> };
<span id="L292" class="LineNr">292 </span>}
<span id="L293" class="LineNr">293 </span>s;
<span id="L294" class="LineNr">294 </span><span class="Comment">// ~&lt; Result: {2, 4, 6} &gt;~</span>
<span id="L295" class="LineNr">295 </span>
<span id="L296" class="LineNr">296 </span>x <span class="Statement">:=</span> <span class="Constant">0</span>;
<span id="L297" class="LineNr">297 </span><span class="Statement">while</span> (x <span class="Type">&lt;</span> <span class="Constant">5</span>) {
<span id="L298" class="LineNr">298 </span>  x <span class="Statement">+=</span> <span class="Constant">1</span>;
<span id="L299" class="LineNr">299 </span>}
<span id="L300" class="LineNr">300 </span>x;
<span id="L301" class="LineNr">301 </span><span class="Comment">// ~&lt; Result: 5 &gt;~</span>
<span id="L302" class="LineNr">302 </span>
<span id="L303" class="LineNr">303 </span><span class="Comment">// Todo: match, _</span>
<span id="L304" class="LineNr">304 </span>
<span id="L305" class="LineNr">305 </span>
<span id="L306" class="LineNr">306 </span><span class="Comment">// Procedures</span>
<span id="L307" class="LineNr">307 </span><span class="Identifier">sum</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(x, y) {
<span id="L308" class="LineNr">308 </span>  <span class="Statement">return</span> x <span class="Type">+</span> y;
<span id="L309" class="LineNr">309 </span>};
<span id="L310" class="LineNr">310 </span><span class="Identifier">sum</span>(<span class="Constant">3</span>, <span class="Constant">4</span>);
<span id="L311" class="LineNr">311 </span><span class="Comment">// ~&lt; Result: 7 &gt;~</span>
<span id="L312" class="LineNr">312 </span>
<span id="L313" class="LineNr">313 </span><span class="Comment">// It can also be cached to avoid recomputing when given the same inputs</span>
<span id="L314" class="LineNr">314 </span><span class="Identifier">sum</span> <span class="Statement">:=</span> <span class="Type">cachedProcedure</span>(x, y) {
<span id="L315" class="LineNr">315 </span>  <span class="Statement">return</span> x <span class="Type">+</span> y;
<span id="L316" class="LineNr">316 </span>};
<span id="L317" class="LineNr">317 </span><span class="Identifier">sum</span>(<span class="Constant">3</span>, <span class="Constant">4</span>);
<span id="L318" class="LineNr">318 </span><span class="Comment">// ~&lt; Result: 7 &gt;~</span>
<span id="L319" class="LineNr">319 </span>
<span id="L320" class="LineNr">320 </span>
<span id="L321" class="LineNr">321 </span><span class="Comment">// Object-oriented Programming</span>
<span id="L322" class="LineNr">322 </span><span class="Type">class</span> <span class="Identifier">point</span>(x, y) {
<span id="L323" class="LineNr">323 </span>  x <span class="Statement">:=</span> x;
<span id="L324" class="LineNr">324 </span>  y <span class="Statement">:=</span> y;
<span id="L325" class="LineNr">325 </span>
<span id="L326" class="LineNr">326 </span>  <span class="Comment">// Instance procedure</span>
<span id="L327" class="LineNr">327 </span>  <span class="Identifier">dist_to</span> <span class="Statement">:=</span> <span class="Type">procedure</span>(pt) {
<span id="L328" class="LineNr">328 </span>    <span class="Statement">return</span> <span class="Identifier">sqrt</span>( (pt.x <span class="Type">-</span> x) <span class="Type">**</span> <span class="Constant">2</span> <span class="Type">+</span> (pt.y <span class="Type">-</span> <a class="Identifier code-proc-link" href="#undefined-250">get_y</a>()) <span class="Type">**</span> <span class="Constant">2</span> );
<span id="L329" class="LineNr">329 </span>  };
<span id="L330" class="LineNr">330 </span>
<span id="L331" class="LineNr">331 </span>  <span class="Comment">// Not really necessary but just demonstrating calling another instance proc  </span>
<span id="L332" class="LineNr">332 </span>  <span class="Identifier">get_y</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L333" class="LineNr">333 </span>    <span class="Comment">// Also just demonstrating 'this' keyword, usually unneeded and implicit </span>
<span id="L334" class="LineNr">334 </span>    <span class="Statement">return</span> this.y;
<span id="L335" class="LineNr">335 </span>  };
<span id="L336" class="LineNr">336 </span>
<span id="L337" class="LineNr">337 </span>  <span class="Comment">// Class procedures</span>
<span id="L338" class="LineNr">338 </span>  <span class="Statement">static</span> {
<span id="L339" class="LineNr">339 </span>    <span class="Identifier">orig</span> <span class="Statement">:=</span> <span class="Type">procedure</span>() {
<span id="L340" class="LineNr">340 </span>      <span class="Statement">return</span> <span class="Identifier">point</span>(<span class="Constant">0</span>, <span class="Constant">0</span>);
<span id="L341" class="LineNr">341 </span>    };
<span id="L342" class="LineNr">342 </span>  }
<span id="L343" class="LineNr">343 </span>}
<span id="L344" class="LineNr">344 </span>pt <span class="Statement">:=</span> <span class="Identifier">point</span>(<span class="Constant">1</span>, <span class="Constant">1</span>);
<span id="L345" class="LineNr">345 </span>pt2 <span class="Statement">:=</span> <span class="Identifier">point</span>(<span class="Constant">4</span>, <span class="Constant">5</span>);
<span id="L346" class="LineNr">346 </span>pt.<span class="Identifier">dist_to</span>(pt2);
<span id="L347" class="LineNr">347 </span><span class="Comment">// ~&lt; Result: 5.0 &gt;~</span>
<span id="L348" class="LineNr">348 </span>pt3 <span class="Statement">:=</span> <span class="Identifier">point</span>(<span class="Constant">3</span>, <span class="Constant">4</span>);
<span id="L349" class="LineNr">349 </span>pt3.<span class="Identifier">dist_to</span>(point.<a class="Identifier code-proc-link" href="#undefined-257">orig</a>());
<span id="L350" class="LineNr">350 </span><span class="Comment">// ~&lt; Result: 5.0 &gt;~</span>
<span id="L351" class="LineNr">351 </span>
<span id="L352" class="LineNr">352 </span>
<span id="L353" class="LineNr">353 </span><span class="Comment Heading">/* SetlX Functors</span>
<span id="L354" class="LineNr">354 </span><span class="Comment Heading">   ==============</span>
<span id="L355" class="LineNr">355 </span><span class="Comment">   SetlX allows for the creation of data structures composed from what they call</span>
<span id="L356" class="LineNr">356 </span><span class="Comment">   functors and arguments. Functor names always start with a capital letter and </span>
<span id="L357" class="LineNr">357 </span><span class="Comment">   then are followed by parentheses enclosing its arguments, which can be of</span>
<span id="L358" class="LineNr">358 </span><span class="Comment">   more or less any type. And that's basically all they are, like strings that </span>
<span id="L359" class="LineNr">359 </span><span class="Comment">   can take arguments to enable tree-like structures.</span>
<span id="L360" class="LineNr">360 </span>
<span id="L361" class="LineNr">361 </span><span class="Comment">   Here we demonstrate its usage to represent logical expressions where </span>
<span id="L362" class="LineNr">362 </span><span class="Comment">   arguments are either strings or other functor terms. (If you're familiar </span>
<span id="L363" class="LineNr">363 </span><span class="Comment">   with functors from category theory, the usage of that term here doesn't </span>
<span id="L364" class="LineNr">364 </span><span class="Comment">   really have anything to do with that notion.)</span>
<span id="L365" class="LineNr">365 </span><span class="Comment">*/</span>
<span id="L366" class="LineNr">366 </span><span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>);
<span id="L367" class="LineNr">367 </span><span class="Comment">// ~&lt; Result: And("A", "B") &gt;~</span>
<span id="L368" class="LineNr">368 </span>
<span id="L369" class="LineNr">369 </span><span class="Identifier">Implies</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>), <span class="Constant">'C'</span>);
<span id="L370" class="LineNr">370 </span><span class="Comment">// ~&lt; Result: Implies(And("A", "B"), "C") &gt;~</span>
<span id="L371" class="LineNr">371 </span>
<span id="L372" class="LineNr">372 </span><span class="Identifier">fct</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>));
<span id="L373" class="LineNr">373 </span><span class="Comment">// ~&lt; Result: "And" &gt;~</span>
<span id="L374" class="LineNr">374 </span>
<span id="L375" class="LineNr">375 </span><span class="Identifier">args</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>));
<span id="L376" class="LineNr">376 </span><span class="Comment">// ~&lt; Result: ["A", "B"] &gt;~</span>
<span id="L377" class="LineNr">377 </span>
<span id="L378" class="LineNr">378 </span><span class="Identifier">makeTerm</span>(<span class="Constant">'And'</span>, [<span class="Constant">'A'</span>, <span class="Constant">'B'</span>]);
<span id="L379" class="LineNr">379 </span><span class="Comment">// ~&lt; Result: And("A", "B") &gt;~</span>
<span id="L380" class="LineNr">380 </span>
<span id="L381" class="LineNr">381 </span>
<span id="L382" class="LineNr">382 </span><span class="Comment Heading">// Type checking</span>
<span id="L383" class="LineNr">383 </span><span class="Comment Heading">// =============</span>
<span id="L384" class="LineNr">384 </span><span class="Identifier">isTerm</span>(<span class="Identifier">And</span>(<span class="Constant">'A'</span>, <span class="Constant">'B'</span>));
<span id="L385" class="LineNr">385 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L386" class="LineNr">386 </span>
<span id="L387" class="LineNr">387 </span><span class="Identifier">isString</span>(<span class="Constant">'abc'</span>);
<span id="L388" class="LineNr">388 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L389" class="LineNr">389 </span>
<span id="L390" class="LineNr">390 </span><span class="Identifier">isSet</span>({});
<span id="L391" class="LineNr">391 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L392" class="LineNr">392 </span>
<span id="L393" class="LineNr">393 </span><span class="Identifier">isList</span>([]);
<span id="L394" class="LineNr">394 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L395" class="LineNr">395 </span>
<span id="L396" class="LineNr">396 </span><span class="Identifier">isMap</span>({ [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">2</span>,<span class="Constant">4</span>] });
<span id="L397" class="LineNr">397 </span><span class="Comment">// ~&lt; Result: true &gt;~</span>
<span id="L398" class="LineNr">398 </span><span class="Identifier">isMap</span>({ [<span class="Constant">1</span>,<span class="Constant">2</span>], [<span class="Constant">1</span>,<span class="Constant">4</span>] });
<span id="L399" class="LineNr">399 </span><span class="Comment">// ~&lt; Result: false &gt;~</span>
<span id="L400" class="LineNr">400 </span>
<span id="L401" class="LineNr">401 </span>
<span id="L402" class="LineNr">402 </span><span class="Identifier">int</span>(<span class="Constant">'5'</span>);
<span id="L403" class="LineNr">403 </span><span class="Comment">// ~&lt; Result: 5 &gt;~</span>
<span id="L404" class="LineNr">404 </span>
<span id="L405" class="LineNr">405 </span><span class="Identifier">str</span>(<span class="Constant">5</span>);
<span id="L406" class="LineNr">406 </span><span class="Comment">// ~&lt; Result: "5" &gt;~</span>
<span id="L407" class="LineNr">407 </span>
<span id="L408" class="LineNr">408 </span><span class="Identifier">str</span>({});
<span id="L409" class="LineNr">409 </span><span class="Comment">// ~&lt; Result: "{}" &gt;~</span>
<span id="L410" class="LineNr">410 </span>
<span id="L411" class="LineNr">411 </span>
<span id="L412" class="LineNr">412 </span><span class="Comment">// Meta-programming</span>
<span id="L413" class="LineNr">413 </span><span class="Identifier">eval</span>(<span class="Constant">"{1} + {2, 3}"</span>);
<span id="L414" class="LineNr">414 </span><span class="Comment">// ~&lt; Result: {1, 2, 3} &gt;~</span>
</div>
</pre>
<nav id="files">
  <h4>Files:</h4> 
  <select name="version" id="version" autocomplete="off">
    <option value="v19-10">v19.10</option>
    <option value="v19-10-13">v19.10.13</option>
    <option value="v19-10-21">v19.10.21</option>
    <option value="v20-1" selected="">v20.1.1</option>
  </select>
  <a id="tract_tab" class="file selected" data-file="tract">tract</a>
  <a id="main_tab" class="file" data-file="main">main</a>
  <a id="decision_algorithm_tab" class="file" data-file="decision_algorithm">dec&hellip;_alg&hellip;</a>
  <a id="causal_markov_model_tab" class="file" data-file="causal_markov_model">causal_markov&hellip;</a>
  <a id="causal_model_tab" class="file" data-file="causal_model">causal_model</a>
  <a id="lib_tab" class="file" data-file="lib">lib</a>
  <a id="setlx_tab" class="file" data-file="setlx">setlX</a>
  <span class="icons">
    <!--
      <a title="Read the Blog" href="#" class="icon"><i class="fas fa-blog fa-2x"></i></a>
    -->
    <a target="_BLANK" title="Read the Blog" href="https://medium.com/@june_ku" class="icon"><i class="fab fa-medium fa-2x"></i></a>
    <!--<a title="Download files (__kb)" href="metaethical-ai.zip" class="icon" id="download"><i class="fas fa-file-download fa-2x"></i></a>-->
    <a title="Help" href="#" class="icon" id="help"><i class="fas fa-question-circle fa-2x"></i></a>
    <a target="_BLANK" title="Github" href="https://github.com/metaethical-ai/metaethical-ai" class="icon" id="github"><i class="fab fa-github fa-2x"></i></a>
  </span>
  <div id="grad"></div>
  <div id="right-files-ribbon"></div>
  <div id="right-files-ribbon-shadow"></div>
</nav>
<div id="sidebar">
  <div id="files-ribbon"></div>
  <img id="logo" src="http://www.metaethical.ai/img/logo.png">
  <h1>Meta<em>Ethical</em>.AI</h1>
  <h3>AI that does what we <br><em><b>should</b></em> want it to do</h3>
  <div id="sidebar-button">
    <span id="sidebar-triangle"><i class="fas fa-chevron-left"></i></span>
  </div>
  <div class="ribbon">
    <div id="concepts-heading" class="heading"><i class="fas fa-list"></i> Key Concepts<i class="fas fa-chevron-down"></i></div>
    <div class="shadow"></div>
    <div class="left-shadow shadow"></div>
  </div>
  <div id="concepts" class="links">
    <ul>
      <li>
        <i class="fas fa-caret-down"></i>
        MetaEthics
        <ul>
          <li>
            <i class="fas fa-caret-down"></i>
            <a data-file="decision_algorithm" data-name="ruf" href="#da-1669">
						  Rational Utility Function
            </a>
            <ul>
              <li>
                <a data-file="decision_algorithm" data-num="63">
                  Higher Order Preferences
                </a>
              </li>
              <li>
                <a data-file="decision_algorithm" data-name="optimal_rxs" href="#da-1750">
                  Optimal Normative Judgments
                </a>
              </li>
            </ul>
          </li> <!-- end rat_u -->
          <li>
            <i class="fas fa-caret-down"></i>
            <a data-file="main" data-name="metaethical_ai_u" href="#m-49">
              Inter</a>/<a data-file="decision_algorithm" data-name="voter_weight" href="#da-1708">Intrapersonal Social Choice
            </a>
            <ul>
               <li>
                <a data-file="lib" data-name="hausdorff_dist" href="#l-566">Hausdorff</a>
                <a data-file="lib" data-name="kendalls_tau_dist" href="#l-585">Kendall Tau</a>
                <a data-file="lib" data-name="ord_u_dist" href="#l-674">Distance</a>
              </li>
              <li>
                <a data-file="decision_algorithm" data-name="agential_identity" href="#da-1906">
                  Agential Identity
                </a>
              </li>
            </ul>
          </li>
        </ul>
      </li><!-- end metaeethics -->
     <li>
        <i class="fas fa-caret-down"></i>
        MetaSemantics
        <ul>
          <li>
            <i class="fas fa-caret-down"></i>
            <a data-file="decision_algorithm" data-name="better_explanation" href="#da-2415">
						  Best Intentional Explanation
            </a>
            <ul>
              <li>
                <i class="fas fa-caret-down"></i>
                <a data-file="decision_algorithm" data-name="complexity" href="#da-1383">
                  Minimum Description Length
                </a>
                <ul>
                  <li>
                    <a data-file="lib" data-name="k" href="#l-769">
                      Kolmogorov Complexity
                    </a>
                  </li>
                </ul>
              </li>
              <li style="">
                <i class="fas fa-caret-right"></i>
                Coherence
                <ul style="display: none;">
                  <li>
                    <a data-file="decision_algorithm" data-name="instr_irrat" href="#da-789">
                      Instrumental Rationality
                    </a>
                  </li>
                  <li>
                    <a data-file="decision_algorithm" data-name="prob_distance" href="#da-1275">
                      Probabilistic</a>
                    <a data-file="decision_algorithm" data-name="incoherence" href="#da-866">
                      Coherence
                    </a>
                  </li>
                  <li>
                    <a data-file="decision_algorithm" data-name="coh_cm_ps" href="#da-1034">
                      Coherence over Causal Models
                    </a>
                  </li>
                </ul>
              </li><!-- end coherence -->
              <li>
                <a data-file="decision_algorithm" data-name="ambitiousness" href="#da-1434">
                  Ambitiousness
                </a>
              </li>
            </ul>
          </li><!-- end best intentional explanation -->
          <li>
            <a data-file="decision_algorithm" data-name="commutes" href="#da-315">
              Implementation Functor              
            </a>
          </li>
          <li>
            <i class="fas fa-caret-down"></i>
            <a data-file="decision_algorithm" data-name="ref" href="#da-538">
              Content of Mental Representations
            </a>
            <ul>
              <li>
                <a data-file="decision_algorithm" data-name="ref" href="#da-538">
                  Self-Referential Sense Data
                </a>
              </li>
              <li>
                <a data-file="decision_algorithm" data-name="full_ref" href="#da-604">
                  First-Order Structures
                </a>
              </li>
            </ul>
          </li><!-- end content of mental representations -->
        </ul>
      </li>
    </ul>      
  </div>
  <div class="ribbon">
    <div id="glossary-heading" class="heading"><i class="fas fa-book-open"></i> Glossary<i class="fas fa-chevron-down"></i></div>
    <div class="shadow"></div>
    <div class="left-shadow shadow"></div>
  </div>
	<div id="glossary" class="links">
		<div id="col1" class="col">
		 <a href="#cmm-92" data-file="causal_markov_model" class="Identifier" title="actual_events">actual_events</a>  <a href="#da-750" data-file="decision_algorithm" class="Identifier" title="actual_p_events">actual_p_events</a>  <a href="#cmm-96" data-file="causal_markov_model" class="Identifier" title="actual_state">actual_state</a>  <a href="#cmm-102" data-file="causal_markov_model" class="Identifier" title="actual_sync_events">actual_sync_events</a>  <a href="#da-2333" data-file="decision_algorithm" class="Identifier" title="add_one">add_one</a>  <a href="#da-1083" data-file="decision_algorithm" class="Identifier" title="add_p_distr">add_p_distr</a>  <a href="#l-635" data-file="lib" class="Identifier" title="add_u_to_card_u">add_u_to_card_u</a>  <a href="#da-2342" data-file="decision_algorithm" class="Identifier" title="add_up_to">add_up_to</a>  <a href="#da-2168" data-file="decision_algorithm" class="Identifier" title="additive_to_ordinal">additive_to_ordinal</a>  <a href="#da-1917" data-file="decision_algorithm" class="Identifier" title="agential_connection">agential_connection</a>  <a href="#da-1912" data-file="decision_algorithm" class="Identifier" title="agential_continuity">agential_continuity</a>  <a href="#da-1906" data-file="decision_algorithm" class="Identifier" title="agential_identity">agential_identity</a>  <a href="#da-2293" data-file="decision_algorithm" class="Identifier" title="all">all</a>  <a href="#l-116" data-file="lib" class="Identifier" title="all_atomic_formulas">all_atomic_formulas</a>  <a href="#da-2299" data-file="decision_algorithm" class="Identifier" title="all_lte">all_lte</a>  <a href="#l-740" data-file="lib" class="Identifier" title="all_strs_lte">all_strs_lte</a>  <a href="#da-1434" data-file="decision_algorithm" class="Identifier" title="ambitiousness">ambitiousness</a>  <a href="#da-1472" data-file="decision_algorithm" class="Identifier" title="ambitiousness_with_hs">ambitiousness_with_hs</a>  <a href="#da-1592" data-file="decision_algorithm" class="Identifier" title="apply_fm_m">apply_fm_m</a>  <a href="#l-245" data-file="lib" class="Identifier" title="arity">arity</a>  <a href="#l-425" data-file="lib" class="Identifier" title="as_p2">as_p2</a>  <a href="#l-427" data-file="lib" class="Identifier" title="as_p3">as_p3</a>  <a href="#l-434" data-file="lib" class="Identifier" title="as_p4">as_p4</a>  <a href="#l-438" data-file="lib" class="Identifier" title="as_q5">as_q5</a>  <a href="#l-443" data-file="lib" class="Identifier" title="as_q6">as_q6</a>  <a href="#l-448" data-file="lib" class="Identifier" title="as_q7">as_q7</a>  <a href="#l-403" data-file="lib" class="Identifier" title="assign_time">assign_time</a>  <a href="#l-599" data-file="lib" class="Identifier" title="atom_u">atom_u</a>  <a href="#l-94" data-file="lib" class="Identifier" title="atomic_exprs">atomic_exprs</a>  <a href="#l-125" data-file="lib" class="Identifier" title="atomic_forms">atomic_forms</a>  <a href="#l-120" data-file="lib" class="Identifier" title="atomic_formulas">atomic_formulas</a>  <a href="#l-104" data-file="lib" class="Identifier" title="atomic_terms">atomic_terms</a>  <a href="#l-20" data-file="lib" class="Identifier" title="avg">avg</a>  <a href="#da-1312" data-file="decision_algorithm" class="Identifier" title="avg_p_class">avg_p_class</a>  <a href="#da-2415" data-file="decision_algorithm" class="Identifier" title="better_explanation">better_explanation</a>  <a href="#da-2208" data-file="decision_algorithm" class="Identifier" title="bs_msr_paths">bs_msr_paths</a>  <a href="#da-1001" data-file="decision_algorithm" class="Identifier" title="calc_cond_prob">calc_cond_prob</a>  <a href="#l-611" data-file="lib" class="Identifier" title="card_u_to_ord_u">card_u_to_ord_u</a>  <a href="#l-269" data-file="lib" class="Identifier" title="cart_prod">cart_prod</a>  <a href="#da-218" data-file="decision_algorithm" class="Identifier" title="children">children</a>  <a href="#l-297" data-file="lib" class="Identifier" title="choices">choices</a>  <a href="#cmm-38" data-file="causal_markov_model" class="Identifier" title="cm">cm</a>  <a href="#cmm-67" data-file="causal_markov_model" class="Identifier" title="cm_f">cm_f</a>  <a href="#cmm-63" data-file="causal_markov_model" class="Identifier" title="cm_r">cm_r</a>  <a href="#cmm-49" data-file="causal_markov_model" class="Identifier" title="cm_u">cm_u</a>  <a href="#cmm-58" data-file="causal_markov_model" class="Identifier" title="cm_v">cm_v</a>  <a href="#da-1955" data-file="decision_algorithm" class="Identifier" title="cog_change">cog_change</a>  <a href="#da-1034" data-file="decision_algorithm" class="Identifier" title="coh_cm_ps">coh_cm_ps</a>  <a href="#da-930" data-file="decision_algorithm" class="Identifier" title="coh_pcms">coh_pcms</a>  <a href="#da-315" data-file="decision_algorithm" class="Identifier" title="commutes">commutes</a>  <a href="#l-616" data-file="lib" class="Identifier" title="compare_lots">compare_lots</a>  <a href="#l-346" data-file="lib" class="Identifier" title="compat">compat</a>  <a href="#l-356" data-file="lib" class="Identifier" title="compat_compl_sts">compat_compl_sts</a>  <a href="#l-352" data-file="lib" class="Identifier" title="compatible_complete_states">compatible_complete_states</a>  <a href="#l-342" data-file="lib" class="Identifier" title="compatible_values">compatible_values</a>  <a href="#da-1383" data-file="decision_algorithm" class="Identifier" title="complexity">complexity</a>  <a href="#cmm-45" data-file="causal_markov_model" class="Identifier" title="compute_cm">compute_cm</a>  <a href="#da-269" data-file="decision_algorithm" class="Identifier" title="compute_f">compute_f</a>  <a href="#da-371" data-file="decision_algorithm" class="Identifier" title="compute_lf">compute_lf</a>  <a href="#cm-95" data-file="causal_model" class="Identifier" title="compute_poss_states">compute_poss_states</a>  <a href="#da-545" data-file="decision_algorithm" class="Identifier" title="compute_ref">compute_ref</a>  <a href="#da-997" data-file="decision_algorithm" class="Identifier" title="cond_probs">cond_probs</a>  <a href="#l-462" data-file="lib" class="Identifier" title="conj_elim">conj_elim</a>  <a href="#l-458" data-file="lib" class="Identifier" title="conj_intr">conj_intr</a>  <a href="#l-72" data-file="lib" class="Identifier" title="connectives">connectives</a>  <a href="#da-1495" data-file="decision_algorithm" class="Identifier" title="d_star_sim">d_star_sim</a>  <a href="#da-2441" data-file="decision_algorithm" class="Identifier" title="da">da</a>  <a href="#cm-108" data-file="causal_model" class="Identifier" title="depth">depth</a>  <a href="#l-516" data-file="lib" class="Identifier" title="derive">derive</a>  <a href="#l-502" data-file="lib" class="Identifier" title="derive_more">derive_more</a>  <a href="#da-1400" data-file="decision_algorithm" class="Identifier" title="df_to_str">df_to_str</a>  <a href="#l-473" data-file="lib" class="Identifier" title="disj_elim">disj_elim</a>  <a href="#l-468" data-file="lib" class="Identifier" title="disj_intr">disj_intr</a>  <a href="#da-2102" data-file="decision_algorithm" class="Identifier" title="da:dist_to">da:dist_to</a>  <a href="#l-567" data-file="lib" class="Identifier" title="dist_to_closest">dist_to_closest</a>  <a href="#da-1073" data-file="decision_algorithm" class="Identifier" title="distr_p_cm">distr_p_cm</a>  <a href="#da-356" data-file="decision_algorithm" class="Identifier" title="drop_i">drop_i</a>  <a href="#l-409" data-file="lib" class="Identifier" title="drop_time">drop_time</a>  <a href="#da-796" data-file="decision_algorithm" class="Identifier" title="e_dist">e_dist</a>  <a href="#da-2144" data-file="decision_algorithm" class="Identifier" title="e_func">e_func</a>  <a href="#da-804" data-file="decision_algorithm" class="Identifier" title="e_i_dist">e_i_dist</a>  <a href="#da-489" data-file="decision_algorithm" class="Identifier" title="e_in_u">e_in_u</a>  <a href="#da-2013" data-file="decision_algorithm" class="Identifier" title="e_vars">e_vars</a>  <a href="#cm-27" data-file="causal_model" class="Identifier" title="effect_of_do">effect_of_do</a>  <a href="#da-783" data-file="decision_algorithm" class="Identifier" title="eo">eo</a>  <a href="#l-36" data-file="lib" class="Identifier" title="equiv_expr">equiv_expr</a>  <a href="#da-1108" data-file="decision_algorithm" class="Identifier" title="equiv_p_expr">equiv_p_expr</a>  <a href="#l-143" data-file="lib" class="Identifier" title="ete">ete</a>  <a href="#da-1855" data-file="decision_algorithm" class="Identifier" title="eval_expr">eval_expr</a>  <a href="#l-791" data-file="lib" class="Identifier" title="eval_str">eval_str</a>  <a href="#l-484" data-file="lib" class="Identifier" title="ex_elim">ex_elim</a>  <a href="#l-480" data-file="lib" class="Identifier" title="ex_intr">ex_intr</a>  <a href="#da-821" data-file="decision_algorithm" class="Identifier" title="exp_u">exp_u</a>  <a href="#l-138" data-file="lib" class="Identifier" title="expand">expand</a>  <a href="#da-2421" data-file="decision_algorithm" class="Identifier" title="expl_score">expl_score</a>  <a href="#l-134" data-file="lib" class="Identifier" title="expr_to_events">expr_to_events</a>  <a href="#da-2350" data-file="decision_algorithm" class="Identifier" title="expr_to_ltr_var">expr_to_ltr_var</a>  <a href="#da-1022" data-file="decision_algorithm" class="Identifier" title="expr_to_p_funcs">expr_to_p_funcs</a>  <a href="#l-647" data-file="lib" class="Identifier" title="exprs_to_state_space">exprs_to_state_space</a>  <a href="#da-1866" data-file="decision_algorithm" class="Identifier" title="ext_ruf">ext_ruf</a>  <a href="#da-262" data-file="decision_algorithm" class="Identifier" title="f">f</a>  <a href="#da-1396" data-file="decision_algorithm" class="Identifier" title="f_to_s">f_to_s</a>  <a href="#l-223" data-file="lib" class="Identifier" title="fctize">fctize</a>  <a href="#cmm-71" data-file="causal_markov_model" class="Identifier" title="fix_time">fix_time</a>  <a href="#l-254" data-file="lib" class="Identifier" title="flatten">flatten</a>  <a href="#l-259" data-file="lib" class="Identifier" title="flatten_list">flatten_list</a>  <a href="#da-1597" data-file="decision_algorithm" class="Identifier" title="fm_commutes">fm_commutes</a>  <a href="#l-210" data-file="lib" class="Identifier" title="foldr">foldr</a>  <a href="#da-1170" data-file="decision_algorithm" class="Identifier" title="da:force_list">da:force_list</a>  <a href="#da-1251" data-file="decision_algorithm" class="Identifier" title="da:force_list">da:force_list</a>  <a href="#da-604" data-file="decision_algorithm" class="Identifier" title="full_ref">full_ref</a>  <a href="#l-111" data-file="lib" class="Identifier" title="func_to_expr">func_to_expr</a>  <a href="#l-319" data-file="lib" class="Identifier" title="function_space">function_space</a>  <a href="#da-1459" data-file="decision_algorithm" class="Identifier" title="h">h</a>  <a href="#da-1468" data-file="decision_algorithm" class="Identifier" title="h_complexity">h_complexity</a>  <a href="#l-566" data-file="lib" class="Identifier" title="hausdorff_dist">hausdorff_dist</a>  <a href="#da-1449" data-file="decision_algorithm" class="Identifier" title="hs_score">hs_score</a>  <a href="#da-1453" data-file="decision_algorithm" class="Identifier" title="hs_similarity">hs_similarity</a>  <a href="#cm-84" data-file="causal_model" class="Identifier" title="i_proc_to_func">i_proc_to_func</a>  <a href="#da-560" data-file="decision_algorithm" class="Identifier" title="i_ref">i_ref</a>  <a href="#da-1989" data-file="decision_algorithm" class="Identifier" title="id_expr">id_expr</a>  <a href="#da-2005" data-file="decision_algorithm" class="Identifier" title="id_var">id_var</a>  <a href="#da-2277" data-file="decision_algorithm" class="Identifier" title="implemented_by">implemented_by</a>  <a href="#da-866" data-file="decision_algorithm" class="Identifier" title="incoherence">incoherence</a>  <a href="#l-24" data-file="lib" class="Identifier" title="index_of">index_of</a>  <a href="#da-789" data-file="decision_algorithm" class="Identifier" title="instr_irrat">instr_irrat</a>  <a href="#da-502" data-file="decision_algorithm" class="Identifier" title="intension">intension</a>  <a href="#l-239" data-file="lib" class="Identifier" title="inv">inv</a>  <a href="#l-84" data-file="lib" class="Identifier" title="inv_maybe_not">inv_maybe_not</a>  <a href="#da-1214" data-file="decision_algorithm" class="Identifier" title="is_coherent">is_coherent</a>  <a href="#da-1555" data-file="decision_algorithm" class="Identifier" title="is_equal_to">is_equal_to</a>  <a href="#da-293" data-file="decision_algorithm" class="Identifier" title="is_implemented_by">is_implemented_by</a>  <a href="#da-1561" data-file="decision_algorithm" class="Identifier" title="is_isomorphic_to">is_isomorphic_to</a>  <a href="#l-416" data-file="lib" class="Identifier" title="is_logical_truth">is_logical_truth</a>  <a href="#cm-72" data-file="causal_model" class="Identifier" title="is_nec_parent_of">is_nec_parent_of</a>  <a href="#da-202" data-file="decision_algorithm" class="Identifier" title="is_necessary_parent_of">is_necessary_parent_of</a>  <a href="#da-1539" data-file="decision_algorithm" class="Identifier" title="is_simplest_version">is_simplest_version</a>  <a href="#da-1517" data-file="decision_algorithm" class="Identifier" title="is_subset_of">is_subset_of</a>  <a href="#da-963" data-file="decision_algorithm" class="Identifier" title="is_superset_of">is_superset_of</a>  <a href="#l-658" data-file="lib" class="Identifier" title="is_true_in">is_true_in</a>  <a href="#da-455" data-file="decision_algorithm" class="Identifier" title="is_valid">is_valid</a>  <a href="#l-233" data-file="lib" class="Identifier" title="iter_fct">iter_fct</a>  <a href="#l-287" data-file="lib" class="Identifier" title="iter_mult">iter_mult</a>  <a href="#l-279" data-file="lib" class="Identifier" title="iter_prod">iter_prod</a>  <a href="#da-188" data-file="decision_algorithm" class="Identifier" title="just_p_u_m2">just_p_u_m2</a>  <a href="#l-769" data-file="lib" class="Identifier" title="k">k</a>  <a href="#l-790" data-file="lib" class="Identifier" title="k_given">k_given</a>  <a href="#l-585" data-file="lib" class="Identifier" title="kendalls_tau_dist">kendalls_tau_dist</a>  <a href="#da-721" data-file="decision_algorithm" class="Identifier" title="less_sq_err">less_sq_err</a>  <a href="#da-364" data-file="decision_algorithm" class="Identifier" title="lf">lf</a>  <a href="#da-414" data-file="decision_algorithm" class="Identifier" title="lf_cm">lf_cm</a>  <a href="#da-430" data-file="decision_algorithm" class="Identifier" title="lf_cm_p_inv">lf_cm_p_inv</a>  <a href="#da-419" data-file="decision_algorithm" class="Identifier" title="lf_cm_vs">lf_cm_vs</a>  <a href="#da-386" data-file="decision_algorithm" class="Identifier" title="lf_commutes">lf_commutes</a>  <a href="#da-401" data-file="decision_algorithm" class="Identifier" title="lf_inv">lf_inv</a> </div>
		<div id="col2" class="col">
		 <a href="#da-407" data-file="decision_algorithm" class="Identifier" title="lf_inv_at">lf_inv_at</a>  <a href="#l-309" data-file="lib" class="Identifier" title="list_choices">list_choices</a>  <a href="#l-678" data-file="lib" class="Identifier" title="list_to_ord">list_to_ord</a>  <a href="#l-702" data-file="lib" class="Identifier" title="lots_of_u">lots_of_u</a>  <a href="#da-2325" data-file="decision_algorithm" class="Identifier" title="ltr_up_to">ltr_up_to</a>  <a href="#da-463" data-file="decision_algorithm" class="Identifier" title="m2s_are_valid">m2s_are_valid</a>  <a href="#l-15" data-file="lib" class="Identifier" title="max">max</a>  <a href="#da-883" data-file="decision_algorithm" class="Identifier" title="max_p_dist">max_p_dist</a>  <a href="#l-76" data-file="lib" class="Identifier" title="maybe_not">maybe_not</a>  <a href="#m-71" data-file="main" class="Identifier" title="meai_psc_dist">meai_psc_dist</a>  <a href="#l-720" data-file="lib" class="Identifier" title="merge">merge</a>  <a href="#m-49" data-file="main" class="Identifier" title="metaethical_ai_u">metaethical_ai_u</a>  <a href="#l-10" data-file="lib" class="Identifier" title="min">min</a>  <a href="#l-494" data-file="lib" class="Identifier" title="modus_ponens">modus_ponens</a>  <a href="#l-6" data-file="lib" class="Identifier" title="ne_pow">ne_pow</a>  <a href="#cmm-122" data-file="causal_markov_model" class="Identifier" title="cmm:new">cmm:new</a>  <a href="#cm-126" data-file="causal_model" class="Identifier" title="cm:new">cm:new</a>  <a href="#da-2432" data-file="decision_algorithm" class="Identifier" title="da:new">da:new</a>  <a href="#da-1730" data-file="decision_algorithm" class="Identifier" title="new_wb">new_wb</a>  <a href="#da-2224" data-file="decision_algorithm" class="Identifier" title="next_bs_msrs">next_bs_msrs</a>  <a href="#da-485" data-file="decision_algorithm" class="Identifier" title="no_e_in_u">no_e_in_u</a>  <a href="#da-225" data-file="decision_algorithm" class="Identifier" title="non_shared_ancestors">non_shared_ancestors</a>  <a href="#da-240" data-file="decision_algorithm" class="Identifier" title="non_shared_descendants">non_shared_descendants</a>  <a href="#da-170" data-file="decision_algorithm" class="Identifier" title="ns">ns</a>  <a href="#da-1178" data-file="decision_algorithm" class="Identifier" title="obeys_axiom_3">obeys_axiom_3</a>  <a href="#da-2069" data-file="decision_algorithm" class="Identifier" title="observed">observed</a>  <a href="#da-1167" data-file="decision_algorithm" class="Identifier" title="old_is_coherent">old_is_coherent</a>  <a href="#da-1750" data-file="decision_algorithm" class="Identifier" title="optimal_rxs">optimal_rxs</a>  <a href="#da-1762" data-file="decision_algorithm" class="Identifier" title="optimality">optimality</a>  <a href="#l-674" data-file="lib" class="Identifier" title="ord_u_dist">ord_u_dist</a>  <a href="#l-393" data-file="lib" class="Identifier" title="orig_var">orig_var</a>  <a href="#da-1931" data-file="decision_algorithm" class="Identifier" title="p_conn">p_conn</a>  <a href="#da-1923" data-file="decision_algorithm" class="Identifier" title="p_conn_continuity">p_conn_continuity</a>  <a href="#da-1146" data-file="decision_algorithm" class="Identifier" title="p_cp_inv">p_cp_inv</a>  <a href="#da-1116" data-file="decision_algorithm" class="Identifier" title="p_dist">p_dist</a>  <a href="#da-1296" data-file="decision_algorithm" class="Identifier" title="p_equiv_classes">p_equiv_classes</a>  <a href="#da-1949" data-file="decision_algorithm" class="Identifier" title="p_i_sim">p_i_sim</a>  <a href="#da-1137" data-file="decision_algorithm" class="Identifier" title="p_inv">p_inv</a>  <a href="#da-942" data-file="decision_algorithm" class="Identifier" title="p_range">p_range</a>  <a href="#da-951" data-file="decision_algorithm" class="Identifier" title="p_u_is_coherent">p_u_is_coherent</a>  <a href="#da-182" data-file="decision_algorithm" class="Identifier" title="p_u_vars">p_u_vars</a>  <a href="#da-1155" data-file="decision_algorithm" class="Identifier" title="p_var_inv">p_var_inv</a>  <a href="#da-178" data-file="decision_algorithm" class="Identifier" title="p_vars">p_vars</a>  <a href="#cm-65" data-file="causal_model" class="Identifier" title="cm:parents">cm:parents</a>  <a href="#da-197" data-file="decision_algorithm" class="Identifier" title="da:parents">da:parents</a>  <a href="#l-382" data-file="lib" class="Identifier" title="parse_var">parse_var</a>  <a href="#l-526" data-file="lib" class="Identifier" title="parse_vars">parse_vars</a>  <a href="#l-336" data-file="lib" class="Identifier" title="partial_functions">partial_functions</a>  <a href="#da-439" data-file="decision_algorithm" class="Identifier" title="plf_to_pf">plf_to_pf</a>  <a href="#da-580" data-file="decision_algorithm" class="Identifier" title="poss_base_expr_refs">poss_base_expr_refs</a>  <a href="#da-587" data-file="decision_algorithm" class="Identifier" title="poss_base_refs">poss_base_refs</a>  <a href="#da-895" data-file="decision_algorithm" class="Identifier" title="poss_cms">poss_cms</a>  <a href="#da-903" data-file="decision_algorithm" class="Identifier" title="poss_cms_from_l">poss_cms_from_l</a>  <a href="#da-916" data-file="decision_algorithm" class="Identifier" title="poss_cms_from_p_pars">poss_cms_from_p_pars</a>  <a href="#da-2396" data-file="decision_algorithm" class="Identifier" title="poss_ds">poss_ds</a>  <a href="#cmm-88" data-file="causal_markov_model" class="Identifier" title="cmm:poss_events">cmm:poss_events</a>  <a href="#cm-99" data-file="causal_model" class="Identifier" title="cm:poss_events">cm:poss_events</a>  <a href="#da-2354" data-file="decision_algorithm" class="Identifier" title="poss_expr_to_ltr">poss_expr_to_ltr</a>  <a href="#da-2009" data-file="decision_algorithm" class="Identifier" title="poss_i_events">poss_i_events</a>  <a href="#da-1344" data-file="decision_algorithm" class="Identifier" title="poss_i_states">poss_i_states</a>  <a href="#da-1324" data-file="decision_algorithm" class="Identifier" title="poss_io_states">poss_io_states</a>  <a href="#da-1348" data-file="decision_algorithm" class="Identifier" title="poss_is_states">poss_is_states</a>  <a href="#da-1336" data-file="decision_algorithm" class="Identifier" title="poss_m2_states">poss_m2_states</a>  <a href="#da-1332" data-file="decision_algorithm" class="Identifier" title="poss_m_states">poss_m_states</a>  <a href="#da-1340" data-file="decision_algorithm" class="Identifier" title="poss_ms_states">poss_ms_states</a>  <a href="#da-2359" data-file="decision_algorithm" class="Identifier" title="poss_nj">poss_nj</a>  <a href="#da-1352" data-file="decision_algorithm" class="Identifier" title="poss_o_states">poss_o_states</a>  <a href="#da-2022" data-file="decision_algorithm" class="Identifier" title="poss_p_i_events">poss_p_i_events</a>  <a href="#da-938" data-file="decision_algorithm" class="Identifier" title="poss_p_us">poss_p_us</a>  <a href="#da-2026" data-file="decision_algorithm" class="Identifier" title="poss_p_var_events">poss_p_var_events</a>  <a href="#da-2387" data-file="decision_algorithm" class="Identifier" title="poss_r_ue">poss_r_ue</a>  <a href="#da-2392" data-file="decision_algorithm" class="Identifier" title="poss_r_z">poss_r_z</a>  <a href="#da-2367" data-file="decision_algorithm" class="Identifier" title="poss_rs">poss_rs</a>  <a href="#da-2031" data-file="decision_algorithm" class="Identifier" title="poss_rx_states">poss_rx_states</a>  <a href="#da-2037" data-file="decision_algorithm" class="Identifier" title="poss_rxs">poss_rxs</a>  <a href="#da-1328" data-file="decision_algorithm" class="Identifier" title="poss_s_states">poss_s_states</a>  <a href="#cmm-84" data-file="causal_markov_model" class="Identifier" title="cmm:poss_states">cmm:poss_states</a>  <a href="#cm-88" data-file="causal_model" class="Identifier" title="cm:poss_states">cm:poss_states</a>  <a href="#da-289" data-file="decision_algorithm" class="Identifier" title="da:poss_states">da:poss_states</a>  <a href="#da-1356" data-file="decision_algorithm" class="Identifier" title="poss_u_states">poss_u_states</a>  <a href="#da-2017" data-file="decision_algorithm" class="Identifier" title="poss_ue_events">poss_ue_events</a>  <a href="#da-1572" data-file="decision_algorithm" class="Identifier" title="possible_fms">possible_fms</a>  <a href="#da-285" data-file="decision_algorithm" class="Identifier" title="possible_fs">possible_fs</a>  <a href="#l-328" data-file="lib" class="Identifier" title="possible_states">possible_states</a>  <a href="#da-1305" data-file="decision_algorithm" class="Identifier" title="pp_equiv">pp_equiv</a>  <a href="#da-573" data-file="decision_algorithm" class="Identifier" title="preds">preds</a>  <a href="#da-1275" data-file="decision_algorithm" class="Identifier" title="prob_distance">prob_distance</a>  <a href="#da-764" data-file="decision_algorithm" class="Identifier" title="prob_states">prob_states</a>  <a href="#da-772" data-file="decision_algorithm" class="Identifier" title="prob_states_t">prob_states_t</a>  <a href="#da-983" data-file="decision_algorithm" class="Identifier" title="probs">probs</a>  <a href="#l-377" data-file="lib" class="Identifier" title="proc2func">proc2func</a>  <a href="#cm-121" data-file="causal_model" class="Identifier" title="proc_to_func">proc_to_func</a>  <a href="#l-55" data-file="lib" class="Identifier" title="range_for_arity">range_for_arity</a>  <a href="#da-1723" data-file="decision_algorithm" class="Identifier" title="rat_psc_dist">rat_psc_dist</a>  <a href="#da-538" data-file="decision_algorithm" class="Identifier" title="ref">ref</a>  <a href="#da-741" data-file="decision_algorithm" class="Identifier" title="ref_expr">ref_expr</a>  <a href="#cmm-108" data-file="causal_markov_model" class="Identifier" title="cmm:response">cmm:response</a>  <a href="#cm-37" data-file="causal_model" class="Identifier" title="cm:response">cm:response</a>  <a href="#l-751" data-file="lib" class="Identifier" title="restrict_domain">restrict_domain</a>  <a href="#l-755" data-file="lib" class="Identifier" title="restricted_eq">restricted_eq</a>  <a href="#da-626" data-file="decision_algorithm" class="Identifier" title="rr">rr</a>  <a href="#da-1669" data-file="decision_algorithm" class="Identifier" title="ruf">ruf</a>  <a href="#da-2126" data-file="decision_algorithm" class="Identifier" title="rx_e_i_val">rx_e_i_val</a>  <a href="#da-2062" data-file="decision_algorithm" class="Identifier" title="rx_to_tuple">rx_to_tuple</a>  <a href="#da-123" data-file="decision_algorithm" class="Identifier" title="s">s</a>  <a href="#l-303" data-file="lib" class="Identifier" title="set_choices">set_choices</a>  <a href="#l-733" data-file="lib" class="Identifier" title="setlx_chars">setlx_chars</a>  <a href="#l-676" data-file="lib" class="Identifier" title="sharpenings">sharpenings</a>  <a href="#da-1944" data-file="decision_algorithm" class="Identifier" title="sim_cog_scores">sim_cog_scores</a>  <a href="#da-2426" data-file="decision_algorithm" class="Identifier" title="simpler">simpler</a>  <a href="#da-1548" data-file="decision_algorithm" class="Identifier" title="simplest_version">simplest_version</a>  <a href="#cm-45" data-file="causal_model" class="Identifier" title="solve_for">solve_for</a>  <a href="#l-708" data-file="lib" class="Identifier" title="sort_list">sort_list</a>  <a href="#l-716" data-file="lib" class="Identifier" title="sort_set">sort_set</a>  <a href="#da-1124" data-file="decision_algorithm" class="Identifier" title="sorted_rat">sorted_rat</a>  <a href="#cm-103" data-file="causal_model" class="Identifier" title="sorted_v">sorted_v</a>  <a href="#da-725" data-file="decision_algorithm" class="Identifier" title="sq_err">sq_err</a>  <a href="#da-947" data-file="decision_algorithm" class="Identifier" title="state_space">state_space</a>  <a href="#l-362" data-file="lib" class="Identifier" title="states2events">states2events</a>  <a href="#l-606" data-file="lib" class="Identifier" title="states_u">states_u</a>  <a href="#da-568" data-file="decision_algorithm" class="Identifier" title="str_exprs">str_exprs</a>  <a href="#l-540" data-file="lib" class="Identifier" title="sub">sub</a>  <a href="#l-552" data-file="lib" class="Identifier" title="subformulas">subformulas</a>  <a href="#da-1014" data-file="decision_algorithm" class="Identifier" title="subj_conds">subj_conds</a>  <a href="#da-1091" data-file="decision_algorithm" class="Identifier" title="sum_p">sum_p</a>  <a href="#da-1053" data-file="decision_algorithm" class="Identifier" title="sum_p_cms">sum_p_cms</a>  <a href="#da-968" data-file="decision_algorithm" class="Identifier" title="superset_is_coherent">superset_is_coherent</a>  <a href="#da-1511" data-file="decision_algorithm" class="Identifier" title="supersets_lte">supersets_lte</a>  <a href="#da-1795" data-file="decision_algorithm" class="Identifier" title="sync_psc_dist">sync_psc_dist</a>  <a href="#da-152" data-file="decision_algorithm" class="Identifier" title="t">t</a>  <a href="#cmm-116" data-file="causal_markov_model" class="Identifier" title="t_to_str">t_to_str</a>  <a href="#l-3" data-file="lib" class="Identifier" title="tf">tf</a>  <a href="#da-1706" data-file="decision_algorithm" class="Identifier" title="time_wt">time_wt</a>  <a href="#da-1392" data-file="decision_algorithm" class="Identifier" title="to_s">to_s</a>  <a href="#da-732" data-file="decision_algorithm" class="Identifier" title="true_p">true_p</a>  <a href="#da-2050" data-file="decision_algorithm" class="Identifier" title="u_conn">u_conn</a>  <a href="#cmm-28" data-file="causal_markov_model" class="Identifier" title="u_t">u_t</a>  <a href="#da-2152" data-file="decision_algorithm" class="Identifier" title="ue">ue</a>  <a href="#da-2160" data-file="decision_algorithm" class="Identifier" title="ue_base_exprs">ue_base_exprs</a>  <a href="#da-1756" data-file="decision_algorithm" class="Identifier" title="ue_state_space">ue_state_space</a>  <a href="#l-637" data-file="lib" class="Identifier" title="util">util</a>  <a href="#da-1844" data-file="decision_algorithm" class="Identifier" title="util_of_future">util_of_future</a>  <a href="#l-617" data-file="lib" class="Identifier" title="util_of_lot">util_of_lot</a>  <a href="#da-1801" data-file="decision_algorithm" class="Identifier" title="util_of_rxs">util_of_rxs</a>  <a href="#cmm-24" data-file="causal_markov_model" class="Identifier" title="cmm:uv">cmm:uv</a>  <a href="#cm-21" data-file="causal_model" class="Identifier" title="cm:uv">cm:uv</a>  <a href="#cmm-34" data-file="causal_markov_model" class="Identifier" title="uv_t">uv_t</a>  <a href="#cmm-31" data-file="causal_markov_model" class="Identifier" title="v_t">v_t</a>  <a href="#da-212" data-file="decision_algorithm" class="Identifier" title="vals_diff">vals_diff</a>  <a href="#cm-78" data-file="causal_model" class="Identifier" title="values_diff">values_diff</a>  <a href="#l-397" data-file="lib" class="Identifier" title="var_time">var_time</a>  <a href="#da-2329" data-file="decision_algorithm" class="Identifier" title="vars_up_to">vars_up_to</a>  <a href="#da-1708" data-file="decision_algorithm" class="Identifier" title="voter_weight">voter_weight</a>  <a href="#da-1875" data-file="decision_algorithm" class="Identifier" title="w_util">w_util</a> </div>
	</div>
  <div class="ribbon">
    <div id="about-heading" class="heading"><i class="fas fa-address-card"></i> About Me<i class="fas fa-chevron-right"></i></div>
    <div class="shadow"></div>
    <div class="left-shadow shadow"></div>
  </div>
  <div id="about" class="links">
    <p>
      <img id="june" src="http://www.metaethical.ai/images/june-ku.png">    
      June Ku earned a graduate degree in philosophy from the top-ranked metaethics program. Now working as a software developer, she has continued pursuing her philosophical research interests and unified them with software engineering. She hopes her work can help bring about safe and beneficial smarter-than-human artificial intelligence. She lives in the San Francisco Bay Area, California.
    </p>    
  </div>
  <div id="sidebar-footer">

		<div id="donate" style="width: auto; top: 3px">
			<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_BLANK">
			<input type="hidden" name="cmd" value="_donations">
			<input type="hidden" name="business" value="LRHJAB4AQTQ64">
			<input type="hidden" name="currency_code" value="USD">
			<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" border="0">
			<img alt="" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" border="0">
			</form>
			
			<img src="../images/bitcoin-64.png" height="18" 
					 style="position: relative; top: -2px; margin-right: 3px; cursor: pointer;"
					 onclick="window.alert_coin('BTC');"> 
			<img src="../images/ether-64.png" height="18" 
					 style="position: relative; top: -2px; margin-right: 3px; cursor: pointer;"
					 onclick="window.alert_coin('ETH');"> 
			<img src="../images/xrp.png" width="15" 
					 style="position: relative; top: -4px; cursor: pointer;"
					 onclick="window.alert_coin('XRP');">
			<script type="text/javascript">
				window.digest = async function(msg) {
					const encoder = new TextEncoder();
					const data = encoder.encode(msg);
					const hashBuffer = await crypto.subtle.digest('SHA-256', data);
					const hashArray = Array.from(new Uint8Array(hashBuffer));
					const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
					return hashHex;
				}
				window.alert_coin = function(coin) {
					if (window.addrs[coin]) {
						alert('Donate ' + coin + ' to ' + window.addrs[coin]);
					} else {
						alert('Error retrieving ' + coin + ' address.');
					}
				}
				$(document).ready(function() {
					$.get('http://addr.metaethical.ai/index.json', 
								function(data) {
									window.addrs = {};
									shas = ['94889bfbc857b53282601506295e42aad62ddce2cb4635f2c92f68d2ba316bf4',
												  '56a5b027a4b4f02d8c522c91aadef11473fc263a77f2c657058528908f1182e6',
													'f71e1eff8826559e2ec644d4f4b59f6fe800ecb46f134d06f1e4714285592fac'];
									for (const coin of ['BTC', 'ETH', 'XRP']) {
										if (data[coin]) {
											window.digest(data[coin]).then(function(str) {
												if (shas.includes(str)) {
													window.addrs[coin] = data[coin];
												}
											});
										}
									}									
								});
				});
			</script>
		</div>

		<div id="soc-priv" style="width: auto; float: left;">
		  <a id="twitter-link" target="_BLANK" href="https://twitter.com/metaethical_ai"><img id="twitter" src="http://www.metaethical.ai/images/twitter-32.png" height="18" style="height: 18px; position: relative; top: 2px;"></a>
			<a style="display: none;" id="reddit-link" target="_BLANK" href="https://www.reddit.com/r/MetaEthicalAI"><img id="reddit" src="http://www.metaethical.ai/images/reddit-logo.png"></a>
			&nbsp; 
			<a style="font-size: 14px; position: relative; top: -2px; left: 15px;" target="_BLANK" href="https://www.termsfeed.com/privacy-policy/3265880085ae5635c07999a4c31857ba">Privacy Policy</a>
		</div>

		<div id="mailchimp" style="display: none">
			<span id="hear">Hear the latest updates:</span><br>
			<form action="https://metaethical.us12.list-manage.com/subscribe/post" method="POST">
				<input type="hidden" name="u" value="6110b72a0185b44f836985783">
				<input type="hidden" name="id" value="4df9075f50">
				<input id="email" name="MERGE0" type="text" placeholder="Email">
				<input id="button" type="submit" value="Notify Me">
			</form>
		</div>
    <div class="left-shadow shadow"></div>
  </div>
</div>
</div> <!-- end container -->
<menu type="context" id="tree-menu">
  <menuitem label="Collapse All" onclick="window.menu_collapse_all();"></menuitem>
  <menuitem label="Expand All" onclick="window.menu_expand_all();"></menuitem>
</menu>



</body></html>
